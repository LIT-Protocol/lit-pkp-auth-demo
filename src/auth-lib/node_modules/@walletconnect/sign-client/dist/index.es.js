import{RELAYER_DEFAULT_PROTOCOL as de,RELAYER_EVENTS as b,EXPIRER_EVENTS as ge,Store as k,Core as ue}from"@walletconnect/core";import{pino as me,getDefaultLoggerOptions as we,generateChildLogger as ye,getLoggerContext as Se}from"@walletconnect/logger";import{IEngine as Ie,ISignClient as Ee}from"@walletconnect/types";import{TYPE_1 as _e,createDelayedPromise as x,engineEvent as p,getInternalError as c,calcExpiry as _,isValidObject as Q,getRequiredNamespacesFromNamespaces as Re,getSdkError as R,handleDeeplinkRedirect as Ne,isSessionCompatible as qe,isBrowser as fe,hashMessage as z,isExpired as v,isValidParams as S,isUndefined as D,isValidRelays as ve,isValidRequiredNamespaces as Pe,isValidNamespaces as j,isConformingNamespaces as W,isValidString as C,isValidErrorReason as Oe,isValidRelay as Ve,isValidController as Te,isValidNamespacesChainId as Z,isValidRequest as xe,isValidNamespacesRequest as De,isValidRequestExpiry as Ce,isValidResponse as Ae,isValidEvent as Le,isValidNamespacesEvent as be,parseExpirerTarget as Ge,isValidId as $e,getAppMetadata as Me}from"@walletconnect/utils";import Ue,{EventEmitter as Ke}from"events";import{THIRTY_DAYS as ke,SEVEN_DAYS as ee,FIVE_MINUTES as m,ONE_DAY as P,THIRTY_SECONDS as se,ONE_SECOND as Qe,toMiliseconds as te}from"@walletconnect/time";import{isJsonRpcResult as N,isJsonRpcError as q,getBigIntRpcId as ze,formatJsonRpcRequest as je,formatJsonRpcResult as Ye,formatJsonRpcError as Je,isJsonRpcRequest as Xe,isJsonRpcResponse as He}from"@walletconnect/jsonrpc-utils";const Y="wc",J=2,X="client",G=`${Y}@${J}:${X}:`,$={name:X,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},Fe={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire"},Be={database:":memory:"},H="WALLETCONNECT_DEEPLINK_CHOICE",We={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ze="history",es="0.3",ie="proposal",ss=ke,re="Proposal expired",ne="session",A=ee,oe="engine",O={wc_sessionPropose:{req:{ttl:m,prompt:!0,tag:1100},res:{ttl:m,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:m,prompt:!1,tag:1102},res:{ttl:m,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:P,prompt:!1,tag:1104},res:{ttl:P,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:P,prompt:!1,tag:1106},res:{ttl:P,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:m,prompt:!0,tag:1108},res:{ttl:m,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:m,prompt:!0,tag:1110},res:{ttl:m,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:P,prompt:!1,tag:1112},res:{ttl:P,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:se,prompt:!1,tag:1114},res:{ttl:se,prompt:!1,tag:1115}}},M={min:m,max:ee},V={idle:"idle",active:"active"},ae="request",ce=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"];var ts=Object.defineProperty,is=Object.defineProperties,rs=Object.getOwnPropertyDescriptors,le=Object.getOwnPropertySymbols,ns=Object.prototype.hasOwnProperty,os=Object.prototype.propertyIsEnumerable,pe=(d,r,e)=>r in d?ts(d,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[r]=e,w=(d,r)=>{for(var e in r||(r={}))ns.call(r,e)&&pe(d,e,r[e]);if(le)for(var e of le(r))os.call(r,e)&&pe(d,e,r[e]);return d},F=(d,r)=>is(d,rs(r));class as extends Ie{constructor(r){super(r),this.name=oe,this.events=new Ue,this.initialized=!1,this.ignoredPayloadTypes=[_e],this.requestQueue={state:V.idle,requests:[]},this.requestQueueDelay=Qe,this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.client.core.pairing.register({methods:Object.keys(O)}),this.initialized=!0,setTimeout(()=>{this.requestQueue.requests=this.getPendingSessionRequests(),this.processRequestQueue()},te(this.requestQueueDelay)))},this.connect=async e=>{this.isInitialized();const s=F(w({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(s);const{pairingTopic:t,requiredNamespaces:i,optionalNamespaces:n,sessionProperties:o,relays:a}=s;let l=t,h,I=!1;if(l&&(I=this.client.core.pairing.pairings.get(l).active),!l||!I){const{topic:f,uri:y}=await this.client.core.pairing.create();l=f,h=y}const g=await this.client.core.crypto.generateKeyPair(),E=w({requiredNamespaces:i,optionalNamespaces:n,relays:a??[{protocol:de}],proposer:{publicKey:g,metadata:this.client.metadata}},o&&{sessionProperties:o}),{reject:u,resolve:T,done:K}=x(m,re);if(this.events.once(p("session_connect"),async({error:f,session:y})=>{if(f)u(f);else if(y){y.self.publicKey=g;const B=F(w({},y),{requiredNamespaces:y.requiredNamespaces,optionalNamespaces:y.optionalNamespaces});await this.client.session.set(y.topic,B),await this.setExpiry(y.topic,y.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:y.peer.metadata}),T(B)}}),!l){const{message:f}=c("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(f)}const L=await this.sendRequest(l,"wc_sessionPropose",E),he=_(m);return await this.setProposal(L,w({id:L,expiry:he},E)),{uri:h,approval:K}},this.pair=async e=>(this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:i,sessionProperties:n}=e,o=this.client.proposal.get(s);let{pairingTopic:a,proposer:l,requiredNamespaces:h,optionalNamespaces:I}=o;a=a||"",Q(h)||(h=Re(i,"approve()"));const g=await this.client.core.crypto.generateKeyPair(),E=l.publicKey,u=await this.client.core.crypto.generateSharedKey(g,E);a&&s&&(await this.client.core.pairing.updateMetadata({topic:a,metadata:l.metadata}),await this.sendResult(s,a,{relay:{protocol:t??"irn"},responderPublicKey:g}),await this.client.proposal.delete(s,R("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:a}));const T=w({relay:{protocol:t??"irn"},namespaces:i,requiredNamespaces:h,optionalNamespaces:I,pairingTopic:a,controller:{publicKey:g,metadata:this.client.metadata},expiry:_(A)},n&&{sessionProperties:n});await this.client.core.relayer.subscribe(u),await this.sendRequest(u,"wc_sessionSettle",T);const K=F(w({},T),{topic:u,pairingTopic:a,acknowledged:!1,self:T.controller,peer:{publicKey:l.publicKey,metadata:l.metadata},controller:g});return await this.client.session.set(u,K),await this.setExpiry(u,_(A)),{topic:u,acknowledged:()=>new Promise(L=>setTimeout(()=>L(this.client.session.get(u)),500))}},this.reject=async e=>{this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:i}=this.client.proposal.get(s);i&&(await this.sendError(s,i,t),await this.client.proposal.delete(s,R("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.isValidUpdate(e);const{topic:s,namespaces:t}=e,i=await this.sendRequest(s,"wc_sessionUpdate",{namespaces:t}),{done:n,resolve:o,reject:a}=x();return this.events.once(p("session_update",i),({error:l})=>{l?a(l):o()}),await this.client.session.update(s,{namespaces:t}),{acknowledged:n}},this.extend=async e=>{this.isInitialized(),await this.isValidExtend(e);const{topic:s}=e,t=await this.sendRequest(s,"wc_sessionExtend",{}),{done:i,resolve:n,reject:o}=x();return this.events.once(p("session_extend",t),({error:a})=>{a?o(a):n()}),await this.setExpiry(s,_(A)),{acknowledged:i}},this.request=async e=>{this.isInitialized(),await this.isValidRequest(e);const{chainId:s,request:t,topic:i,expiry:n}=e,o=await this.sendRequest(i,"wc_sessionRequest",{request:t,chainId:s},n),{done:a,resolve:l,reject:h}=x(n);this.events.once(p("session_request",o),({error:g,result:E})=>{g?h(g):l(E)}),this.client.events.emit("session_request_sent",{topic:i,request:t,chainId:s,id:o});const I=await this.client.core.storage.getItem(H);return Ne({id:o,topic:i,wcDeepLink:I}),await a()},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:s,response:t}=e,{id:i}=t;N(t)?await this.sendResult(i,s,t.result):q(t)&&await this.sendError(i,s,t.error),this.cleanupAfterResponse(e)},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=await this.sendRequest(s,"wc_sessionPing",{}),{done:i,resolve:n,reject:o}=x();this.events.once(p("session_ping",t),({error:a})=>{a?o(a):n()}),await i()}else this.client.core.pairing.pairings.keys.includes(s)&&await this.client.core.pairing.ping({topic:s})},this.emit=async e=>{this.isInitialized(),await this.isValidEmit(e);const{topic:s,event:t,chainId:i}=e;await this.sendRequest(s,"wc_sessionEvent",{event:t,chainId:i})},this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=ze().toString();let i;const n=o=>{o?.id.toString()===t&&(this.client.core.relayer.events.removeListener(b.message_ack,n),i())};await Promise.all([new Promise(o=>{i=o,this.client.core.relayer.on(b.message_ack,n)}),this.sendRequest(s,"wc_sessionDelete",R("USER_DISCONNECTED"),void 0,t)]),await this.deleteSession(s)}else await this.client.core.pairing.disconnect({topic:s})},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(s=>qe(s,e))),this.getPendingSessionRequests=()=>(this.isInitialized(),this.client.pendingRequest.getAll()),this.cleanupDuplicatePairings=async e=>{if(e.pairingTopic)try{const s=this.client.core.pairing.pairings.get(e.pairingTopic),t=this.client.core.pairing.pairings.getAll().filter(i=>{var n,o;return((n=i.peerMetadata)==null?void 0:n.url)&&((o=i.peerMetadata)==null?void 0:o.url)===e.peer.metadata.url&&i.topic&&i.topic!==s.topic});if(t.length===0)return;this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`),await Promise.all(t.map(i=>this.client.core.pairing.disconnect({topic:i.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(s){this.client.logger.error(s)}},this.deleteSession=async(e,s)=>{const{self:t}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),this.client.session.delete(e,R("USER_DISCONNECTED")),this.client.core.crypto.keychain.has(t.publicKey)&&await this.client.core.crypto.deleteKeyPair(t.publicKey),this.client.core.crypto.keychain.has(e)&&await this.client.core.crypto.deleteSymKey(e),s||this.client.core.expirer.del(e),this.client.core.storage.removeItem(H).catch(i=>this.client.logger.warn(i))},this.deleteProposal=async(e,s)=>{await Promise.all([this.client.proposal.delete(e,R("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deletePendingSessionRequest=async(e,s,t=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,s),t?Promise.resolve():this.client.core.expirer.del(e)]),this.requestQueue.requests=this.requestQueue.requests.filter(i=>i.id!==e),t&&(this.requestQueue.state=V.idle)},this.setExpiry=async(e,s)=>{this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:s}),this.client.core.expirer.set(e,s)},this.setProposal=async(e,s)=>{await this.client.proposal.set(e,s),this.client.core.expirer.set(e,s.expiry)},this.setPendingSessionRequest=async e=>{const s=O.wc_sessionRequest.req.ttl,{id:t,topic:i,params:n}=e;await this.client.pendingRequest.set(t,{id:t,topic:i,params:n}),s&&this.client.core.expirer.set(t,_(s))},this.sendRequest=async(e,s,t,i,n)=>{const o=je(s,t);if(fe()&&ce.includes(s)){const h=z(JSON.stringify(o));await this.client.core.verify.register({attestationId:h})}const a=await this.client.core.crypto.encode(e,o),l=O[s].req;return i&&(l.ttl=i),n&&(l.id=n),this.client.core.history.set(e,o),this.client.core.relayer.publish(e,a,l),o.id},this.sendResult=async(e,s,t)=>{const i=Ye(e,t),n=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),a=O[o.request.method].res;this.client.core.relayer.publish(s,n,a),await this.client.core.history.resolve(i)},this.sendError=async(e,s,t)=>{const i=Je(e,t),n=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),a=O[o.request.method].res;this.client.core.relayer.publish(s,n,a),await this.client.core.history.resolve(i)},this.cleanup=async()=>{const e=[],s=[];this.client.session.getAll().forEach(t=>{v(t.expiry)&&e.push(t.topic)}),this.client.proposal.getAll().forEach(t=>{v(t.expiry)&&s.push(t.id)}),await Promise.all([...e.map(t=>this.deleteSession(t)),...s.map(t=>this.deleteProposal(t))])},this.onRelayEventRequest=e=>{const{topic:s,payload:t}=e,i=t.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeRequest(s,t);case"wc_sessionSettle":return this.onSessionSettleRequest(s,t);case"wc_sessionUpdate":return this.onSessionUpdateRequest(s,t);case"wc_sessionExtend":return this.onSessionExtendRequest(s,t);case"wc_sessionPing":return this.onSessionPingRequest(s,t);case"wc_sessionDelete":return this.onSessionDeleteRequest(s,t);case"wc_sessionRequest":return this.onSessionRequest(s,t);case"wc_sessionEvent":return this.onSessionEventRequest(s,t);default:return this.client.logger.info(`Unsupported request method ${i}`)}},this.onRelayEventResponse=async e=>{const{topic:s,payload:t}=e,i=(await this.client.core.history.get(s,t.id)).request.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeResponse(s,t);case"wc_sessionSettle":return this.onSessionSettleResponse(s,t);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,t);case"wc_sessionExtend":return this.onSessionExtendResponse(s,t);case"wc_sessionPing":return this.onSessionPingResponse(s,t);case"wc_sessionRequest":return this.onSessionRequestResponse(s,t);default:return this.client.logger.info(`Unsupported response method ${i}`)}},this.onRelayEventUnknownPayload=e=>{const{topic:s}=e,{message:t}=c("MISSING_OR_INVALID",`Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);throw new Error(t)},this.onSessionProposeRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidConnect(w({},s.params));const n=_(m),o=w({id:i,pairingTopic:e,expiry:n},t);await this.setProposal(i,o);const a=z(JSON.stringify(s)),l=await this.getVerifyContext(a,o.proposer.metadata);this.client.events.emit("session_proposal",{id:i,params:o,verifyContext:l})}catch(n){await this.sendError(i,e,n),this.client.logger.error(n)}},this.onSessionProposeResponse=async(e,s)=>{const{id:t}=s;if(N(s)){const{result:i}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:i});const n=this.client.proposal.get(t);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const o=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:o});const a=i.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const l=await this.client.core.crypto.generateSharedKey(o,a);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const h=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:e})}else q(s)&&(await this.client.proposal.delete(t,R("USER_DISCONNECTED")),this.events.emit(p("session_connect"),{error:s.error}))},this.onSessionSettleRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidSessionSettleRequest(i);const{relay:n,controller:o,expiry:a,namespaces:l,requiredNamespaces:h,optionalNamespaces:I,sessionProperties:g,pairingTopic:E}=s.params,u=w({topic:e,relay:n,expiry:a,namespaces:l,acknowledged:!0,pairingTopic:E,requiredNamespaces:h,optionalNamespaces:I,controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},g&&{sessionProperties:g});await this.sendResult(s.id,e,!0),this.events.emit(p("session_connect"),{session:u}),this.cleanupDuplicatePairings(u)}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionSettleResponse=async(e,s)=>{const{id:t}=s;N(s)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(p("session_approve",t),{})):q(s)&&(await this.client.session.delete(e,R("USER_DISCONNECTED")),this.events.emit(p("session_approve",t),{error:s.error}))},this.onSessionUpdateRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidUpdate(w({topic:e},t)),await this.client.session.update(e,{namespaces:t.namespaces}),await this.sendResult(i,e,!0),this.client.events.emit("session_update",{id:i,topic:e,params:t})}catch(n){await this.sendError(i,e,n),this.client.logger.error(n)}},this.onSessionUpdateResponse=(e,s)=>{const{id:t}=s;N(s)?this.events.emit(p("session_update",t),{}):q(s)&&this.events.emit(p("session_update",t),{error:s.error})},this.onSessionExtendRequest=async(e,s)=>{const{id:t}=s;try{this.isValidExtend({topic:e}),await this.setExpiry(e,_(A)),await this.sendResult(t,e,!0),this.client.events.emit("session_extend",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionExtendResponse=(e,s)=>{const{id:t}=s;N(s)?this.events.emit(p("session_extend",t),{}):q(s)&&this.events.emit(p("session_extend",t),{error:s.error})},this.onSessionPingRequest=async(e,s)=>{const{id:t}=s;try{this.isValidPing({topic:e}),await this.sendResult(t,e,!0),this.client.events.emit("session_ping",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionPingResponse=(e,s)=>{const{id:t}=s;setTimeout(()=>{N(s)?this.events.emit(p("session_ping",t),{}):q(s)&&this.events.emit(p("session_ping",t),{error:s.error})},500)},this.onSessionDeleteRequest=async(e,s)=>{const{id:t}=s;try{this.isValidDisconnect({topic:e,reason:s.params}),await Promise.all([new Promise(i=>{this.client.core.relayer.once(b.publish,async()=>{i(await this.deleteSession(e))})}),this.sendResult(t,e,!0)]),this.client.events.emit("session_delete",{id:t,topic:e})}catch(i){this.client.logger.error(i)}},this.onSessionRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidRequest(w({topic:e},i)),await this.setPendingSessionRequest({id:t,topic:e,params:i}),this.addRequestToQueue({id:t,topic:e,params:i}),await this.processRequestQueue()}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionRequestResponse=(e,s)=>{const{id:t}=s;N(s)?this.events.emit(p("session_request",t),{result:s.result}):q(s)&&this.events.emit(p("session_request",t),{error:s.error})},this.onSessionEventRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidEmit(w({topic:e},i)),this.client.events.emit("session_event",{id:t,topic:e,params:i})}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.addRequestToQueue=e=>{this.requestQueue.requests.push(e)},this.cleanupAfterResponse=e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.requestQueue.state=V.idle,this.processRequestQueue()},te(this.requestQueueDelay))},this.processRequestQueue=async()=>{if(this.requestQueue.state===V.active){this.client.logger.info("session request queue is already active.");return}const e=this.requestQueue.requests[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{const{id:s,topic:t,params:i}=e,n=z(JSON.stringify({id:s,params:i})),o=this.client.session.get(t),a=await this.getVerifyContext(n,o.peer.metadata);this.requestQueue.state=V.active,this.client.events.emit("session_request",{id:s,topic:t,params:i,verifyContext:a})}catch(s){this.client.logger.error(s)}},this.isValidConnect=async e=>{if(!S(e)){const{message:a}=c("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(a)}const{pairingTopic:s,requiredNamespaces:t,optionalNamespaces:i,sessionProperties:n,relays:o}=e;if(D(s)||await this.isValidPairingTopic(s),!ve(o,!0)){const{message:a}=c("MISSING_OR_INVALID",`connect() relays: ${o}`);throw new Error(a)}!D(t)&&Q(t)!==0&&this.validateNamespaces(t,"requiredNamespaces"),!D(i)&&Q(i)!==0&&this.validateNamespaces(i,"optionalNamespaces"),D(n)||this.validateSessionProps(n,"sessionProperties")},this.validateNamespaces=(e,s)=>{const t=Pe(e,"connect()",s);if(t)throw new Error(t.message)},this.isValidApprove=async e=>{if(!S(e))throw new Error(c("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:s,namespaces:t,relayProtocol:i,sessionProperties:n}=e;await this.isValidProposalId(s);const o=this.client.proposal.get(s),a=j(t,"approve()");if(a)throw new Error(a.message);const l=W(o.requiredNamespaces,t,"approve()");if(l)throw new Error(l.message);if(!C(i,!0)){const{message:h}=c("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(h)}D(n)||this.validateSessionProps(n,"sessionProperties")},this.isValidReject=async e=>{if(!S(e)){const{message:i}=c("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(i)}const{id:s,reason:t}=e;if(await this.isValidProposalId(s),!Oe(t)){const{message:i}=c("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidSessionSettleRequest=e=>{if(!S(e)){const{message:l}=c("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:s,controller:t,namespaces:i,expiry:n}=e;if(!Ve(s)){const{message:l}=c("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const o=Te(t,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=j(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(v(n)){const{message:l}=c("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async e=>{if(!S(e)){const{message:a}=c("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(a)}const{topic:s,namespaces:t}=e;await this.isValidSessionTopic(s);const i=this.client.session.get(s),n=j(t,"update()");if(n)throw new Error(n.message);const o=W(i.requiredNamespaces,t,"update()");if(o)throw new Error(o.message)},this.isValidExtend=async e=>{if(!S(e)){const{message:t}=c("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionTopic(s)},this.isValidRequest=async e=>{if(!S(e)){const{message:a}=c("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(a)}const{topic:s,request:t,chainId:i,expiry:n}=e;await this.isValidSessionTopic(s);const{namespaces:o}=this.client.session.get(s);if(!Z(o,i)){const{message:a}=c("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(a)}if(!xe(t)){const{message:a}=c("MISSING_OR_INVALID",`request() ${JSON.stringify(t)}`);throw new Error(a)}if(!De(o,i,t.method)){const{message:a}=c("MISSING_OR_INVALID",`request() method: ${t.method}`);throw new Error(a)}if(n&&!Ce(n,M)){const{message:a}=c("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${M.min} and ${M.max}`);throw new Error(a)}},this.isValidRespond=async e=>{if(!S(e)){const{message:i}=c("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(i)}const{topic:s,response:t}=e;if(await this.isValidSessionTopic(s),!Ae(t)){const{message:i}=c("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidPing=async e=>{if(!S(e)){const{message:t}=c("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.isValidEmit=async e=>{if(!S(e)){const{message:o}=c("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(o)}const{topic:s,event:t,chainId:i}=e;await this.isValidSessionTopic(s);const{namespaces:n}=this.client.session.get(s);if(!Z(n,i)){const{message:o}=c("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!Le(t)){const{message:o}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}if(!be(n,i,t.name)){const{message:o}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}},this.isValidDisconnect=async e=>{if(!S(e)){const{message:t}=c("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.getVerifyContext=async(e,s)=>{const t={verified:{verifyUrl:s.verifyUrl||"",validation:"UNKNOWN",origin:s.url||""}};try{const i=await this.client.core.verify.resolve({attestationId:e,verifyUrl:s.verifyUrl});i&&(t.verified.origin=i,t.verified.validation=i===s.url?"VALID":"INVALID")}catch(i){this.client.logger.error(i)}return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`),t},this.validateSessionProps=(e,s)=>{Object.values(e).forEach(t=>{if(!C(t,!1)){const{message:i}=c("MISSING_OR_INVALID",`${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);throw new Error(i)}})}}isInitialized(){if(!this.initialized){const{message:r}=c("NOT_INITIALIZED",this.name);throw new Error(r)}}registerRelayerEvents(){this.client.core.relayer.on(b.message,async r=>{const{topic:e,message:s}=r;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))return;const t=await this.client.core.crypto.decode(e,s);try{Xe(t)?(this.client.core.history.set(e,t),this.onRelayEventRequest({topic:e,payload:t})):He(t)?(await this.client.core.history.resolve(t),await this.onRelayEventResponse({topic:e,payload:t}),this.client.core.history.delete(e,t.id)):this.onRelayEventUnknownPayload({topic:e,payload:t})}catch(i){this.client.logger.error(i)}})}registerExpirerEvents(){this.client.core.expirer.on(ge.expired,async r=>{const{topic:e,id:s}=Ge(r.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,c("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession(e,!0),this.client.events.emit("session_expire",{topic:e})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s}))})}isValidPairingTopic(r){if(!C(r,!1)){const{message:e}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${r}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(r)){const{message:e}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${r}`);throw new Error(e)}if(v(this.client.core.pairing.pairings.get(r).expiry)){const{message:e}=c("EXPIRED",`pairing topic: ${r}`);throw new Error(e)}}async isValidSessionTopic(r){if(!C(r,!1)){const{message:e}=c("MISSING_OR_INVALID",`session topic should be a string: ${r}`);throw new Error(e)}if(!this.client.session.keys.includes(r)){const{message:e}=c("NO_MATCHING_KEY",`session topic doesn't exist: ${r}`);throw new Error(e)}if(v(this.client.session.get(r).expiry)){await this.deleteSession(r);const{message:e}=c("EXPIRED",`session topic: ${r}`);throw new Error(e)}}async isValidSessionOrPairingTopic(r){if(this.client.session.keys.includes(r))await this.isValidSessionTopic(r);else if(this.client.core.pairing.pairings.keys.includes(r))this.isValidPairingTopic(r);else if(C(r,!1)){const{message:e}=c("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${r}`);throw new Error(e)}else{const{message:e}=c("MISSING_OR_INVALID",`session or pairing topic should be a string: ${r}`);throw new Error(e)}}async isValidProposalId(r){if(!$e(r)){const{message:e}=c("MISSING_OR_INVALID",`proposal id should be a number: ${r}`);throw new Error(e)}if(!this.client.proposal.keys.includes(r)){const{message:e}=c("NO_MATCHING_KEY",`proposal id doesn't exist: ${r}`);throw new Error(e)}if(v(this.client.proposal.get(r).expiry)){await this.deleteProposal(r);const{message:e}=c("EXPIRED",`proposal id: ${r}`);throw new Error(e)}}}class cs extends k{constructor(r,e){super(r,e,ie,G),this.core=r,this.logger=e}}class ls extends k{constructor(r,e){super(r,e,ne,G),this.core=r,this.logger=e}}class ps extends k{constructor(r,e){super(r,e,ae,G,s=>s.id),this.core=r,this.logger=e}}class U extends Ee{constructor(r){super(r),this.protocol=Y,this.version=J,this.name=$.name,this.events=new Ke,this.on=(s,t)=>this.events.on(s,t),this.once=(s,t)=>this.events.once(s,t),this.off=(s,t)=>this.events.off(s,t),this.removeListener=(s,t)=>this.events.removeListener(s,t),this.removeAllListeners=s=>this.events.removeAllListeners(s),this.connect=async s=>{try{return await this.engine.connect(s)}catch(t){throw this.logger.error(t.message),t}},this.pair=async s=>{try{return await this.engine.pair(s)}catch(t){throw this.logger.error(t.message),t}},this.approve=async s=>{try{return await this.engine.approve(s)}catch(t){throw this.logger.error(t.message),t}},this.reject=async s=>{try{return await this.engine.reject(s)}catch(t){throw this.logger.error(t.message),t}},this.update=async s=>{try{return await this.engine.update(s)}catch(t){throw this.logger.error(t.message),t}},this.extend=async s=>{try{return await this.engine.extend(s)}catch(t){throw this.logger.error(t.message),t}},this.request=async s=>{try{return await this.engine.request(s)}catch(t){throw this.logger.error(t.message),t}},this.respond=async s=>{try{return await this.engine.respond(s)}catch(t){throw this.logger.error(t.message),t}},this.ping=async s=>{try{return await this.engine.ping(s)}catch(t){throw this.logger.error(t.message),t}},this.emit=async s=>{try{return await this.engine.emit(s)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async s=>{try{return await this.engine.disconnect(s)}catch(t){throw this.logger.error(t.message),t}},this.find=s=>{try{return this.engine.find(s)}catch(t){throw this.logger.error(t.message),t}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}},this.name=r?.name||$.name,this.metadata=r?.metadata||Me();const e=typeof r?.logger<"u"&&typeof r?.logger!="string"?r.logger:me(we({level:r?.logger||$.logger}));this.core=r?.core||new ue(r),this.logger=ye(e,this.name),this.session=new ls(this.core,this.logger),this.proposal=new cs(this.core,this.logger),this.pendingRequest=new ps(this.core,this.logger),this.engine=new as(this)}static async init(r){const e=new U(r);return await e.initialize(),e}get context(){return Se(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success")}catch(r){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(r.message),r}}}const hs=U;export{oe as ENGINE_CONTEXT,O as ENGINE_RPC_OPTS,Ze as HISTORY_CONTEXT,We as HISTORY_EVENTS,es as HISTORY_STORAGE_VERSION,ce as METHODS_TO_VERIFY,ie as PROPOSAL_CONTEXT,ss as PROPOSAL_EXPIRY,re as PROPOSAL_EXPIRY_MESSAGE,ae as REQUEST_CONTEXT,V as REQUEST_QUEUE_STATES,ne as SESSION_CONTEXT,A as SESSION_EXPIRY,M as SESSION_REQUEST_EXPIRY_BOUNDARIES,X as SIGN_CLIENT_CONTEXT,$ as SIGN_CLIENT_DEFAULT,Fe as SIGN_CLIENT_EVENTS,Y as SIGN_CLIENT_PROTOCOL,Be as SIGN_CLIENT_STORAGE_OPTIONS,G as SIGN_CLIENT_STORAGE_PREFIX,J as SIGN_CLIENT_VERSION,hs as SignClient,H as WALLETCONNECT_DEEPLINK_CHOICE,U as default};
//# sourceMappingURL=index.es.js.map
