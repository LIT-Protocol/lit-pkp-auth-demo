"use strict";
var _RecapSessionCapabilityObject_instances, _RecapSessionCapabilityObject_inner, _RecapSessionCapabilityObject_getResourceKeyToMatchAgainst;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecapSessionCapabilityObject = void 0;
const tslib_1 = require("tslib");
const siwe_recap_1 = require("siwe-recap");
const utils_1 = require("./utils");
const siwe_1 = require("../siwe");
class RecapSessionCapabilityObject {
    constructor(att = {}, prf = []) {
        _RecapSessionCapabilityObject_instances.add(this);
        _RecapSessionCapabilityObject_inner.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _RecapSessionCapabilityObject_inner, new siwe_recap_1.Recap(att, prf), "f");
    }
    // static async sha256(data: Buffer): Promise<ArrayBuffer> {
    //   const digest = await crypto.subtle.digest('SHA-256', data);
    //   return digest;
    // }
    // This should ideally be placed in the IPFSBundledSDK package, but for some reasons
    // there seems to be bundling issues where the jest test would fail, but somehow
    // works here.
    // public static async strToCID(
    //   data: string | Uint8Array | object
    // ): Promise<string> {
    //   let content: Uint8Array;
    //   // Check the type of data and convert accordingly
    //   if (typeof data === 'string') {
    //     // console.log("Type A");
    //     // Encode the string directly if data is a string
    //     content = new TextEncoder().encode(data);
    //   } else if (data instanceof Uint8Array) {
    //     // console.log("Type B");
    //     // Use the Uint8Array directly
    //     content = data;
    //   } else if (typeof data === 'object') {
    //     // console.log("Type C");
    //     // Stringify and encode if data is an object
    //     const contentStr = JSON.stringify(data);
    //     content = new TextEncoder().encode(contentStr);
    //   } else {
    //     // console.log("Type D");
    //     throw new Error('Invalid content type');
    //   }
    //   // Create the CID
    //   let ipfsId;
    //   for await (const { cid } of IPFSBundledSDK.importer(
    //     [{ content }],
    //     new IPFSBundledSDK.MemoryBlockstore(),
    //     { onlyHash: true }
    //   )) {
    //     ipfsId = cid;
    //   }
    //   // Validate the IPFS ID
    //   if (!ipfsId) {
    //     throw new Error('Could not create IPFS ID');
    //   }
    //   // Return the IPFS ID as a string
    //   return ipfsId.toString();
    // }
    /**
     * Adds a Rate Limit Authorization Signature (AuthSig) as an proof to the Recap object.
     * This method serializes the AuthSig object into a JSON string and adds it to the proof
     * of the Recap object. The AuthSig typically contains authentication details like signature,
     * method of derivation, the signed message, and the address of the signer. This proof is
     * used to verify that the user has the necessary authorization, such as a Rate Limit Increase NFT.
     *
     * @param authSig The AuthSig object containing the rate limit authorization details.
     */
    async addRateLimitAuthSig(authSig) {
        throw new Error('Not implemented yet. ');
        // const ipfsId = await RecapSessionCapabilityObject.strToCID(authSig);
        // try {
        //   this.addProof(ipfsId);
        // } catch (e: any) {
        //   throw new Error(e);
        // }
    }
    static decode(encoded) {
        const recap = siwe_recap_1.Recap.decode_urn(encoded);
        return new this(recap.attenuations, recap.proofs.map((cid) => cid.toString()));
    }
    static extract(siwe) {
        const recap = siwe_recap_1.Recap.extract_and_verify(siwe);
        return new this(recap.attenuations, recap.proofs.map((cid) => cid.toString()));
    }
    get attenuations() {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").attenuations;
    }
    get proofs() {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").proofs.map((cid) => cid.toString());
    }
    get statement() {
        return (0, siwe_1.sanitizeSiweMessage)(tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").statement);
    }
    addProof(proof) {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").addProof(proof);
    }
    addAttenuation(resource, namespace = '*', name = '*', restriction = {}) {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").addAttenuation(resource, namespace, name, restriction);
    }
    addToSiweMessage(siwe) {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").add_to_siwe_message(siwe);
    }
    encodeAsSiweResource() {
        return tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_inner, "f").encode();
    }
    /** LIT specific methods */
    addCapabilityForResource(litResource, ability, data = {}) {
        // Validate Lit ability is compatible with the Lit resource.
        if (!litResource.isValidLitAbility(ability)) {
            throw new Error(`The specified Lit resource does not support the specified ability.`);
        }
        const { recapNamespace, recapAbility } = (0, utils_1.getRecapNamespaceAndAbility)(ability);
        if (!data) {
            return this.addAttenuation(litResource.getResourceKey(), recapNamespace, recapAbility);
        }
        return this.addAttenuation(litResource.getResourceKey(), recapNamespace, recapAbility, data);
    }
    verifyCapabilitiesForResource(litResource, ability) {
        // Validate Lit ability is compatible with the Lit resource.
        // The only exception is if there's a wildcard resource key in the session capability object.
        if (!litResource.isValidLitAbility(ability)) {
            return false;
        }
        // Get the attenuations object.
        const attenuations = this.attenuations;
        const { recapNamespace, recapAbility } = (0, utils_1.getRecapNamespaceAndAbility)(ability);
        const recapAbilityToCheckFor = `${recapNamespace}/${recapAbility}`;
        // Find an attenuated resource key to match against.
        const attenuatedResourceKey = tslib_1.__classPrivateFieldGet(this, _RecapSessionCapabilityObject_instances, "m", _RecapSessionCapabilityObject_getResourceKeyToMatchAgainst).call(this, litResource);
        if (!attenuations[attenuatedResourceKey]) {
            // No attenuations specified for this resource.
            return false;
        }
        // Check whether the exact Recap namespace/ability pair is present.
        const attenuatedRecapAbilities = Object.keys(attenuations[attenuatedResourceKey]);
        for (const attenuatedRecapAbility of attenuatedRecapAbilities) {
            // Return early if the attenuated recap ability is a wildcard.
            if (attenuatedRecapAbility === '*/*') {
                return true;
            }
            if (attenuatedRecapAbility === recapAbilityToCheckFor) {
                return true;
            }
        }
        return false;
    }
    addAllCapabilitiesForResource(litResource) {
        return this.addAttenuation(litResource.getResourceKey(), '*', '*');
    }
}
exports.RecapSessionCapabilityObject = RecapSessionCapabilityObject;
_RecapSessionCapabilityObject_inner = new WeakMap(), _RecapSessionCapabilityObject_instances = new WeakSet(), _RecapSessionCapabilityObject_getResourceKeyToMatchAgainst = function _RecapSessionCapabilityObject_getResourceKeyToMatchAgainst(litResource) {
    const attenuatedResourceKeysToMatchAgainst = [
        `${litResource.resourcePrefix}://*`,
        litResource.getResourceKey(),
    ];
    for (const attenuatedResourceKeyToMatchAgainst of attenuatedResourceKeysToMatchAgainst) {
        if (this.attenuations[attenuatedResourceKeyToMatchAgainst]) {
            return attenuatedResourceKeyToMatchAgainst;
        }
    }
    return '';
};
//# sourceMappingURL=recap-session-capability-object.js.map