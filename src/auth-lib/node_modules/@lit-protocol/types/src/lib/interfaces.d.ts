import { Provider } from '@ethersproject/abstract-provider';
import { AcceptedFileType, AccessControlConditions, Chain, EvmContractConditions, IRelayAuthStatus, JsonRequest, LIT_NETWORKS_KEYS, LitContractContext, LitContractResolverContext, SolRpcConditions, SymmetricKey, UnifiedAccessControlConditions } from './types';
import { ILitNodeClient } from './ILitNodeClient';
import { ISessionCapabilityObject, LitResourceAbilityRequest } from '@lit-protocol/auth-helpers';
import * as JSZip from 'jszip/dist/jszip.js';
/** ---------- Access Control Conditions Interfaces ---------- */
export interface ABIParams {
    name: string;
    type: string;
}
export interface AccsOperatorParams {
    operator: string;
}
/** ---------- Auth Sig ---------- */
export interface AuthSig {
    sig: any;
    derivedVia: string;
    signedMessage: string;
    address: string;
}
export declare type CosmosWalletType = 'keplr' | 'leap';
export interface AuthCallbackParams {
    chain: Chain;
    statement?: string;
    nonce: string;
    resources?: string[];
    switchChain?: boolean;
    expiration?: string;
    uri?: string;
    cosmosWalletType?: CosmosWalletType;
    /**
     * Optional project ID for WalletConnect V2. Only required if one is using checkAndSignAuthMessage and wants to display WalletConnect as an option.
     */
    walletConnectProjectId?: string;
    resourceAbilityRequests?: LitResourceAbilityRequest[];
}
/** ---------- Web3 ---------- */
export interface IProvider {
    provider: any;
    account: string;
}
/** ---------- Crypto ---------- */
export interface EncryptedZip {
    symmetricKey: SymmetricKey;
    encryptedZip: Blob;
}
export interface DecryptZipFileWithMetadata {
    decryptedFile: Uint8Array;
    metadata: MetadataForFile;
}
export interface MetadataForFile {
    name: string | any;
    type: string | any;
    size: string | number | any;
    accessControlConditions: any[] | any;
    evmContractConditions: any[] | any;
    solRpcConditions: any[] | any;
    unifiedAccessControlConditions: any[] | any;
    chain: string;
    dataToEncryptHash: string;
}
export interface EncryptedFile {
    encryptedFile: Blob;
    symmetricKey: SymmetricKey;
}
export interface DecryptFileProps {
    file: AcceptedFileType;
    symmetricKey: SymmetricKey;
}
export interface VerifyJWTProps {
    publicKey: string;
    jwt: string;
}
export interface IJWT<T> {
    verified: boolean;
    header: JWTHeader;
    payload: T;
    signature: Uint8Array;
}
export interface JWTHeader {
    alg: string;
    typ: string;
}
export interface SigningAccessControlConditionJWTPayload extends MultipleAccessControlConditions {
    iss: string;
    sub: string;
    chain?: string;
    iat: number;
    exp: number;
}
export interface HumanizedAccsProps {
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    tokenList?: Array<any | string>;
    myWalletAddress?: string;
}
/** ---------- Key Value Type ---------- */
export interface KV {
    [key: string]: any;
}
/** ---------- Lit Node Client ---------- */
export interface LitNodeClientConfig {
    alertWhenUnauthorized: boolean;
    minNodeCount: number;
    debug: boolean;
    bootstrapUrls: Array<string>;
    litNetwork: LIT_NETWORKS_KEYS;
    connectTimeout: number;
    checkNodeAttestation: boolean;
    contractContext?: LitContractContext | LitContractResolverContext;
    storageProvider?: StorageProvider;
    retryTolerance?: RetryTolerance;
    defaultAuthCallback?: (authSigParams: AuthCallbackParams) => Promise<AuthSig>;
}
export interface CustomNetwork {
    litNetwork: LIT_NETWORKS_KEYS;
    bootstrapUrls: Array<string>;
    minNodeCount?: number;
    contractContext?: LitContractContext;
}
/**
 * Override for LocalStorage and SessionStorage
 * if running in NodeJs and this is implicitly
 * binded globally
 */
export interface StorageProvider {
    provider: Storage;
}
export interface Signature {
    r: string;
    s: string;
    v: number;
}
export interface ClaimKeyResponse {
    signatures: Signature[];
    claimedKeyId: string;
    pubkey: string;
    mintTx: string;
}
/**
 * Struct in rust
 * -----
 pub struct JsonExecutionRequest {
    pub code: Option<String>,
    pub ipfs_id: Option<String>,
    pub auth_sig: AuthSigItem,
    pub js_params: Option<serde_json::Value>,
}
 */
export interface BaseJsonExecutionRequest {
    jsParams: any;
    code?: string;
    ipfsId?: string;
    targetNodeRange?: number;
    authMethods?: Array<Object>;
}
export interface WithAuthSig extends BaseJsonExecutionRequest {
    authSig: AuthSig;
    sessionSigs?: any;
}
export interface WithSessionSigs extends BaseJsonExecutionRequest {
    sessionSigs: any;
    authSig?: AuthSig;
}
export declare type JsonExecutionRequest = WithAuthSig | WithSessionSigs;
export interface BaseJsonPkpSignRequest {
    toSign: ArrayLike<number>;
    pubKey: string;
}
export interface WithAuthMethodSigning extends BaseJsonPkpSignRequest {
    authMethods: Array<AuthMethod>;
    sessionSigs?: any;
    authSig?: AuthSig;
}
export interface WithSessionSigsSigning extends BaseJsonPkpSignRequest {
    sessionSigs: any;
    authSig?: AuthSig;
    authMethods?: Array<AuthMethod>;
}
export interface WithAuthSigSigning extends BaseJsonPkpSignRequest {
    authSig: AuthSig;
    sessionSigs?: any;
    authMethods?: Array<AuthMethod>;
}
export declare type JsonPkpSignRequest = WithSessionSigsSigning | WithAuthSigSigning | WithAuthMethodSigning;
/**
 * Struct in rust
 * -----
pub struct JsonSignChainDataRequest {
    pub call_requests: Vec<web3::types::CallRequest>,
    pub chain: Chain,
    pub iat: u64,
    pub exp: u64,
}
*/
export interface JsonSignChainDataRequest {
    callRequests: Array<CallRequest>;
    chain: Chain;
    iat: number;
    exp: number;
}
/**
 * Struct in rust
 * -----
 pub struct JsonSigningResourceId {
    pub base_url: String,
    pub path: String,
    pub org_id: String,
    pub role: String,
    pub extra_data: String,
}
*/
export interface JsonSigningResourceId {
    baseUrl: string;
    path: string;
    orgId: string;
    role: string;
    extraData: string;
}
export interface MultipleAccessControlConditions {
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
}
export interface JsonAccsRequest {
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain?: string;
    resourceId?: JsonSigningResourceId;
    authSig?: AuthSig;
    sessionSigs?: SessionSig;
}
/**
 * Struct in rust
 * -----
pub struct JsonSigningRetrieveRequest {
    pub access_control_conditions: Option<Vec<AccessControlConditionItem>>,
    pub evm_contract_conditions: Option<Vec<EVMContractConditionItem>>,
    pub sol_rpc_conditions: Option<Vec<SolRpcConditionItem>>,
    pub unified_access_control_conditions: Option<Vec<UnifiedAccessControlConditionItem>>,
    pub chain: Option<String>,
    pub resource_id: JsonSigningResourceId,
    pub auth_sig: AuthSigItem,
    pub iat: u64,
    pub exp: u64,
}
*/
export interface JsonSigningRetrieveRequest extends JsonAccsRequest {
    iat?: number;
    exp?: number;
    sessionSigs?: any;
}
export interface GetSignedTokenRequest extends SigningAccessControlConditionRequest {
    sessionSigs?: SessionSigsMap;
}
export interface SigningAccessControlConditionRequest {
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain?: string;
    authSig?: SessionSig;
    iat?: number;
    exp?: number;
}
/**
 * Struct in rust
 * -----
pub struct JsonSigningStoreRequest {
    pub key: String,
    pub val: String,
    pub chain: Option<String>,
    pub permanant: Option<usize>,
    pub auth_sig: AuthSigItem,
}
 */
export interface JsonSigningStoreRequest {
    key: string;
    val: string;
    chain?: string;
    permanant?: 0 | 1;
    permanent?: 0 | 1;
    authSig?: AuthSig;
    sessionSigs?: object;
}
/**
 * Struct in rust
 * -----
 pub struct JsonEncryptionRetrieveRequest {
    pub access_control_conditions: Option<Vec<AccessControlConditionItem>>,
    pub evm_contract_conditions: Option<Vec<EVMContractConditionItem>>,
    pub sol_rpc_conditions: Option<Vec<SolRpcConditionItem>>,
    pub unified_access_control_conditions: Option<Vec<UnifiedAccessControlConditionItem>>,
    pub chain: Option<String>,
    pub to_decrypt: String,
    pub auth_sig: AuthSigItem,
}
 */
export interface JsonEncryptionRetrieveRequest extends JsonAccsRequest {
    toDecrypt: string;
}
export declare type ExecuteJsProps = JsonExecutionRequest & {
    debug?: boolean;
};
export interface EncryptRequestBase {
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain: Chain;
    authSig?: AuthSig;
    sessionSigs?: SessionSigsMap;
}
export interface EncryptRequest extends EncryptRequestBase {
    dataToEncrypt: Uint8Array;
}
export interface EncryptResponse {
    ciphertext: string;
    dataToEncryptHash: string;
}
export interface EncryptStringRequest extends EncryptRequestBase {
    dataToEncrypt: string;
}
export interface EncryptZipRequest extends EncryptRequestBase {
    zip: JSZip;
}
export interface EncryptFileRequest extends EncryptRequestBase {
    file: AcceptedFileType;
}
export interface DecryptRequest extends EncryptRequestBase {
    ciphertext: string;
    dataToEncryptHash: string;
}
export interface DecryptResponse {
    decryptedData: Uint8Array;
}
export interface GetSigningShareForDecryptionRequest extends JsonAccsRequest {
    dataToEncryptHash: string;
}
export interface SignConditionECDSA {
    accessControlConditions: any;
    evmContractConditions: undefined;
    solRpcConditions: undefined;
    auth_sig: AuthSig;
    chain: Chain;
    iat: number;
    exp: number;
}
/**
 *
 * An object containing the resulting signatures.  Each signature comes with the public key and the data signed.
 *
 */
export interface ExecuteJsResponse {
    signatures: any;
    decryptions: any[];
    response: string;
    logs: string;
    claims?: Record<string, {
        signatures: Signature[];
        derivedKeyId: string;
    }>;
    debug?: {
        allNodeResponses: NodeResponse[];
        allNodeLogs: NodeLog[];
        rawNodeHTTPResponses: any;
    };
}
export interface LitNodePromise {
}
export interface SendNodeCommand {
    url: string;
    data: any;
    requestId: string;
}
export interface NodeShare {
    claimData: any;
    shareIndex: any;
    unsignedJwt: any;
    signedData: any;
    decryptedData: any;
    response: any;
    logs: any;
    success?: any;
}
export interface PKPSignShare {
    success: boolean;
    signedData: any;
    signatureShare: any;
}
export interface NodeBlsSigningShare {
    shareIndex: any;
    unsignedJwt?: any;
    signatureShare: BlsSignatureShare;
    response?: any;
    logs?: any;
}
export interface BlsSignatureShare {
    ProofOfPossession: string;
}
export interface SuccessNodePromises<T> {
    success: boolean;
    values: Array<T>;
}
export interface RejectedNodePromises {
    success: boolean;
    error: NodeErrorV1;
}
export interface NodePromiseResponse {
    status?: string;
    value?: any;
    reason?: any;
}
export interface NodeErrorV1 {
    errorKind: string;
    status: number;
    details: string[];
    message?: string;
    errorCode?: string;
}
export interface NodeErrorV3 {
    errorKind: string;
    errorCode: string;
    status: number;
    message: string;
    correlationId: string;
    details: string[];
}
/**
 *
 * @deprecated - This is the old error object.  It will be removed in the future. Use NodeClientErrorV1 instead.
 *
 */
export interface NodeClientErrorV0 {
    errorCode?: string;
    message: string;
    error: any;
    name?: string;
}
export interface NodeClientErrorV1 {
    message: string;
    errorKind: string;
    errorCode: string;
    details?: string[];
    status?: number;
    requestId?: string;
}
export interface SigShare {
    sigType: any;
    signatureShare: any;
    shareIndex: any;
    bigr?: string;
    bigR?: string;
    publicKey: any;
    dataSigned: any;
    siweMessage?: string;
    sigName?: string;
}
export interface SignedData {
    signedData: any;
}
export interface DecryptedData {
    decryptedData: any;
}
export interface NodeResponse {
    response: any;
}
export interface NodeLog {
    logs: any;
}
export interface CallRequest {
    to: string;
    from?: string;
    data: string;
}
export interface SignedChainDataToken {
    callRequests: Array<CallRequest>;
    chain: Chain;
}
export interface NodeCommandResponse {
    url: string;
    data: JsonRequest;
}
export interface NodeCommandServerKeysResponse {
    serverPublicKey: any;
    subnetPublicKey: any;
    networkPublicKey: any;
    networkPublicKeySet: any;
    attestation: NodeAttestation;
    latestBlockhash?: string;
}
export interface FormattedMultipleAccs {
    error: boolean;
    formattedAccessControlConditions: any;
    formattedEVMContractConditions: any;
    formattedSolRpcConditions: any;
    formattedUnifiedAccessControlConditions: any;
}
export interface SignWithECDSA {
    message: string;
    chain: Chain;
    iat: number;
    exp: number;
}
export interface CombinedECDSASignature {
    r: string;
    s: string;
    recid: number;
}
export interface ValidateAndSignECDSA {
    accessControlConditions: AccessControlConditions;
    chain: Chain;
    auth_sig: AuthSig;
}
export interface HandshakeWithNode {
    url: string;
    challenge: string;
}
export interface NodeAttestation {
    type: string;
    noonce: string;
    data: {
        INSTANCE_ID: string;
        RELEASE_ID: string;
        UNIX_TIME: string;
    };
    signatures: string[];
    report: string;
}
export interface JsonHandshakeResponse {
    serverPubKey: string;
    subnetPubKey: string;
    networkPubKey: string;
    networkPubKeySet: string;
    hdRootPubkeys: string[];
    latestBlockhash?: string;
}
export interface EncryptToIpfsProps {
    authSig?: AuthSig;
    sessionSigs?: any;
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain: Chain;
    string?: string;
    file?: AcceptedFileType;
    litNodeClient: ILitNodeClient;
    infuraId: string;
    infuraSecretKey: string;
}
export declare type EncryptToIpfsDataType = 'string' | 'file';
export interface EncryptToIpfsPayload {
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain: Chain;
    ciphertext: string;
    dataToEncryptHash: string;
    dataType: EncryptToIpfsDataType;
}
export interface DecryptFromIpfsProps {
    authSig?: AuthSig;
    sessionSigs?: any;
    ipfsCid: string;
    litNodeClient: ILitNodeClient;
}
export interface EncryptFileAndZipWithMetadataProps {
    authSig?: AuthSig;
    sessionSigs?: any;
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain: string;
    file: File;
    litNodeClient: ILitNodeClient;
    readme: string;
}
export interface DecryptZipFileWithMetadataProps {
    authSig?: AuthSig;
    sessionSigs?: any;
    file: File | Blob;
    litNodeClient: ILitNodeClient;
}
/**
 * Struct in rust
 * -----
 pub struct SessionKeySignedMessage {
    pub session_key: String,
    pub resources: Vec<String>,
    pub capabilities: Vec<String>,
    pub issued_at: String,
    pub expiration: String,
    pub node_address: String,
}
 */
export interface SessionKeySignedMessage {
    sessionKey: string;
    resources?: any[];
    capabilities: string[];
    issuedAt: string;
    expiration: string;
    nodeAddress: string;
}
export interface SessionSigsProp {
    expiration?: any;
    chain: Chain;
    resources: any[];
    sessionCapabilities?: any;
    switchChain?: boolean;
    litNodeClient: ILitNodeClient;
}
export interface SessionKeyPair {
    publicKey: string;
    secretKey: string;
}
/** ========== Session ========== */
export interface AuthMethod {
    authMethodType: number;
    accessToken: string;
}
export interface SignSessionKeyProp {
    sessionKey?: SessionKeyPair;
    statement?: string;
    authMethods: AuthMethod[];
    pkpPublicKey?: string;
    authSig?: AuthSig;
    expiration?: string;
    resources: any;
    chainId?: number;
    domain?: string;
    resourceAbilityRequests?: LitResourceAbilityRequest[];
}
export interface SignSessionKeyResponse {
    pkpPublicKey: string;
    authSig: AuthSig;
}
export interface GetSignSessionKeySharesProp {
    body: SessionRequestBody;
}
export interface GetSessionSigsProps {
    expiration?: any;
    chain: Chain;
    /**
     * An array of resource abilities that you want to request for this session. These will be signed with the session key.
     *
     * @example If you want to request the ability to decrypt an access control condition, then you would pass
     * [{ resource: new LitAccessControlConditionResource('someResource), ability: LitAbility.AccessControlConditionDecryption }]
     */
    resourceAbilityRequests: LitResourceAbilityRequest[];
    /**
     * The session capability object that you want to request for this session.
     * If you pass nothing, then this will default to a wildcard for each type of resource you're accessing.
     *
     * @example If you passed nothing, and you're requesting to perform a decryption operation for an access
     * control condition, then the session capability object will be a wildcard for the access control condition,
     * which grants this session signature the ability to decrypt this access control condition.
     */
    sessionCapabilityObject?: ISessionCapabilityObject;
    switchChain?: boolean;
    authNeededCallback?: AuthCallback;
    sessionKey?: any;
    capacityDelegationAuthSig?: AuthSig;
}
export interface AuthCallback {
    (params: AuthCallbackParams): Promise<AuthSig>;
}
/**
 * A map of node addresses to the session signature payload
 * for that node specifically.
 */
export interface SessionSigsMap {
    [nodeAddress: string]: SessionSig;
}
export interface SessionSig {
    sig: string;
    derivedVia: string;
    signedMessage: string;
    address: string;
    algo?: string;
}
export interface SessionSigs {
    /**
     * Map of Lit node urls to session signatures
     */
    [key: string]: SessionSig;
}
export interface SessionRequestBody {
    sessionKey: string;
    authMethods: Array<AuthMethod>;
    pkpPublicKey?: string;
    authSig?: AuthSig;
    siweMessage: string;
}
export interface GetWalletSigProps {
    authNeededCallback?: AuthCallback;
    chain: string;
    sessionCapabilityObject: ISessionCapabilityObject;
    switchChain?: boolean;
    expiration: string;
    sessionKeyUri: string;
    nonce: string;
}
export interface SessionSigningTemplate {
    sessionKey: string;
    resourceAbilityRequests: LitResourceAbilityRequest[];
    capabilities: any[];
    issuedAt: string;
    expiration: string;
    nodeAddress: string;
}
export interface WebAuthnAuthenticationVerificationParams {
    id: string;
    rawId: string;
    response: {
        authenticatorData: string;
        clientDataJSON: string;
        signature: string;
        userHandle: string;
    };
    type: string;
    clientExtensionResults: object;
    authenticatorAttachment: AuthenticatorAttachment;
}
export declare type AuthenticatorAttachment = 'cross-platform' | 'platform';
/**
 * ========== PKP ==========
 */
export interface LitClientSessionManager {
    getSessionKey: () => SessionKeyPair;
    isSessionKeyPair(obj: any): boolean;
    getExpiration: () => string;
    getWalletSig: (getWalletSigProps: GetWalletSigProps) => Promise<AuthSig>;
    checkNeedToResignSessionKey: (params: {
        authSig: AuthSig;
        sessionKeyUri: any;
        resourceAbilityRequests: Array<LitResourceAbilityRequest>;
    }) => Promise<boolean>;
    getSessionSigs: (params: GetSessionSigsProps) => Promise<SessionSigsMap>;
    signSessionKey: (params: SignSessionKeyProp) => Promise<SignSessionKeyResponse>;
}
export interface AuthenticationProps {
    client: LitClientSessionManager;
    getSessionSigsProps: GetSessionSigsProps;
    authMethods: AuthMethod[];
}
export interface PKPBaseProp {
    pkpPubKey: string;
    rpc?: string;
    rpcs?: RPCUrls;
    controllerAuthSig?: AuthSig;
    controllerAuthMethods?: AuthMethod[];
    controllerSessionSigs?: SessionSigs;
    sessionSigsExpiration?: string;
    authContext?: AuthenticationProps;
    litNetwork?: any;
    debug?: boolean;
    bootstrapUrls?: string[];
    minNodeCount?: number;
    litActionCode?: string;
    litActionIPFS?: string;
    litActionJsParams?: any;
    provider?: Provider;
}
export interface RPCUrls {
    eth?: string;
    cosmos?: string;
    btc?: string;
}
export interface PKPEthersWalletProp extends PKPBaseProp {
}
export interface PKPCosmosWalletProp extends PKPBaseProp {
    addressPrefix: string | 'cosmos';
}
export interface PKPClientProp extends PKPBaseProp {
    cosmosAddressPrefix?: string | 'cosmos';
}
export interface PKPBaseDefaultParams {
    toSign: Uint8Array;
    publicKey: Uint8Array;
    sigName: string;
}
export interface PKPClientHelpers {
    handleRequest: (request: any) => Promise<any>;
    setRpc: (rpc: string) => void;
    getRpc: () => string;
}
/**
 * ========== LitAuthClient ==========
 */
export interface LitAuthClientOptions {
    /**
     * Endpoint to interact with a blockchain network. Defaults to the Lit Chronicle.
     */
    rpcUrl?: string;
    /**
     * Options for Lit's relay server
     */
    litRelayConfig?: LitRelayConfig;
    /**
     * Pass in a custom relay server
     */
    customRelay?: IRelay;
    /**
     * Lit Node Client
     */
    litNodeClient?: any;
    /**
     * If enable will turn on logging
     */
    debug?: boolean;
    litOtpConfig?: OtpProviderOptions;
}
export interface OtpSessionResult {
    /**
     * Status message of the request
     */
    message?: string;
    /**
     * jwt from successful otp check
     */
    token_jwt?: string;
    /**
     * status of the otp check
     */
    status?: string;
}
export interface LoginUrlParams {
    /**
     * Auth method name
     */
    provider: string | null;
    /**
     * Access token
     */
    accessToken: string | null;
    /**
     * ID token
     */
    idToken: string | null;
    /**
     * OAuth state param
     */
    state: string | null;
    /**
     * Error codes from Lit's login server
     */
    error: string | null;
}
export interface IRelay {
    /**
     * Mint a new PKP for the given auth method
     *
     * @param {string} body - Body of the request
     *
     * @returns {Promise<IRelayMintResponse>} Response from the relay server
     */
    mintPKP(body: string): Promise<IRelayMintResponse>;
    /**
     * Poll the relay server for status of minting request
     *
     * @param {string} requestId - Request ID to poll, likely the minting transaction hash
     *
     * @returns {Promise<IRelayPollStatusResponse>} Response from the relay server
     */
    pollRequestUntilTerminalState(requestId: string): Promise<IRelayPollStatusResponse>;
    /**
     * Fetch PKPs associated with the given auth method
     *
     * @param {string} body - Body of the request
     *
     * @returns {Promise<IRelayFetchResponse>} Response from the relay server
     */
    fetchPKPs(body: string): Promise<IRelayFetchResponse>;
    /**
     * Generate options for registering a new credential to pass to the authenticator
     *
     * @param {string} [username] - Optional username to associate with the credential
     *
     * @returns {Promise<any>} Registration options for the browser to pass to the authenticator
     */
    generateRegistrationOptions(username?: string): Promise<any>;
}
export interface LitRelayConfig {
    /**
     * Lit's relay server URL
     */
    relayUrl?: string;
    /**
     * API key for Lit's relay server
     */
    relayApiKey?: string;
}
export interface MintRequestBody {
    keyType?: number;
    permittedAuthMethodTypes?: number[];
    permittedAuthMethodIds?: string[];
    permittedAuthMethodPubkeys?: string[];
    permittedAuthMethodScopes?: any[][];
    addPkpEthAddressAsPermittedAddress?: boolean;
    sendPkpToItself?: boolean;
}
export interface IRelayRequestData {
    /**
     * Type of auth method
     */
    authMethodType: number;
    /**
     * ID of auth method
     */
    authMethodId: string;
    /**
     * Public key associated with the auth method (used only in WebAuthn)
     */
    authMethodPubKey?: string;
}
export interface IRelayMintResponse {
    /**
     * Transaction hash of PKP being minted
     */
    requestId?: string;
    /**
     * Error from relay server
     */
    error?: string;
}
export interface IRelayFetchResponse {
    /**
     * Fetched PKPs
     */
    pkps?: IRelayPKP[];
    /**
     * Error from relay server
     */
    error?: string;
}
export interface IRelayPollingEvent {
    /**
     * Polling count
     */
    pollCount: number;
    /**
     * Transaction hash of PKP being minted
     */
    requestId: string;
}
export interface IRelayPollStatusResponse {
    /**
     * Polling status
     */
    status?: IRelayAuthStatus;
    /**
     * Token ID of PKP being minted
     */
    pkpTokenId?: string;
    /**
     * Eth address of new PKP
     */
    pkpEthAddress?: string;
    /**
     * Public key of new PKP
     */
    pkpPublicKey?: string;
    /**
     * Polling error
     */
    error?: string;
}
export interface IRelayPKP {
    /**
     * PKP token ID
     */
    tokenId: string;
    /**
     * PKP public key
     */
    publicKey: string;
    /**
     * PKP Eth address
     */
    ethAddress: string;
}
export interface BaseProviderOptions {
    /**
     * Endpoint to interact with a blockchain network. Defaults to the Lit Chronicle.
     */
    rpcUrl: string;
    /**
     * Relay server to use
     */
    relay: IRelay;
    /**
     * Lit Node Client to use
     */
    litNodeClient: any;
}
export interface OAuthProviderOptions {
    /**
     * The redirect URI that Lit's login server should send the user back to
     */
    redirectUri?: string;
    /**
     * OAuth client ID
     */
    clientId?: string;
}
export interface EthWalletProviderOptions {
    /**
     * The domain from which the signing request is made
     */
    domain?: string;
    /**
     * The origin from which the signing request is made
     */
    origin?: string;
}
export interface WebAuthnProviderOptions {
    /**
     * Name of relying party. Defaults to "lit"
     */
    rpName?: string;
}
export interface SignInWithOTPParams {
    /**
     * otp transport (email or phone #)
     * used as the user ID for the auth method
     */
    userId: string;
    /**
     * tracking for the session
     */
    requestId?: string;
    /**
     * Allows for specifying custom sender information
     * Note: for most users the `from_name` is the configurable option and `from` should not be populated
     */
    emailCustomizationOptions: OtpEmailCustomizationOptions;
    customName?: string;
}
export interface OtpProviderOptions {
    baseUrl?: string;
    port?: string;
    startRoute?: string;
    checkRoute?: string;
}
export interface OtpEmailCustomizationOptions {
    from?: string;
    fromName: string;
}
export interface SignInWithStytchOTPParams {
    accessToken?: string;
    userId: string;
}
export interface StytchOtpProviderOptions {
    appId: string;
    userId?: string;
}
export interface StytchToken {
    [key: string]: any;
}
export interface BaseProviderSessionSigsParams {
    /**
     * Public key of PKP to auth with
     */
    pkpPublicKey: string;
    /**
     * Auth method verifying ownership of PKP
     */
    authMethod: AuthMethod;
    /**
     * Params for getSessionSigs function
     */
    sessionSigsParams: GetSessionSigsProps;
    /**
     * Lit Node Client to use. If not provided, will use an existing Lit Node Client or create a new one
     */
    litNodeClient?: any;
    resourceAbilityRequests?: LitResourceAbilityRequest[];
}
export interface LoginUrlParams {
    /**
     * Auth method name
     */
    provider: string | null;
    /**
     * Access token
     */
    accessToken: string | null;
    /**
     * ID token
     */
    idToken: string | null;
    /**
     * OAuth state param
     */
    state: string | null;
    /**
     * Error codes from Lit's login server
     */
    error: string | null;
}
export interface BaseAuthenticateOptions {
}
export interface EthWalletAuthenticateOptions extends BaseAuthenticateOptions {
    /**
     * Ethereum wallet address
     */
    address?: string;
    /**
     * Function to sign message
     *
     * @param {string} message - Message to sign
     *
     * @returns {Promise<string>} - Raw signature of message
     */
    signMessage?: (message: string) => Promise<string>;
    /**
     * Name of chain to use for signature
     */
    chain?: string;
    /**
     * When the auth signature expires
     */
    expiration?: string;
}
export interface OtpAuthenticateOptions extends BaseAuthenticateOptions {
    /**
     * User provided authentication code
     */
    code: string;
}
export interface StytchOtpAuthenticateOptions extends BaseAuthenticateOptions {
    accessToken: string;
    userId?: string;
}
/**
 * Configuration for retry operations
 */
export interface RetryTolerance {
    /**
     * An amount of time to wait for canceling the operating (in milliseconds)
     */
    timeout?: number;
    /**
     * How long to wait between retries (in milliseconds)
     */
    interval?: number;
    /**
     * How many times to retry the operation
     */
    maxRetryCount?: number;
}
export interface BaseMintCapacityContext {
    daysUntilUTCMidnightExpiration: number;
}
export interface MintCapacityCreditsPerDay extends BaseMintCapacityContext {
    requestsPerDay?: number;
}
export interface MintCapacityCreditsPerSecond extends BaseMintCapacityContext {
    requestsPerSecond?: number;
}
export interface MintCapacityCreditsPerKilosecond extends BaseMintCapacityContext {
    requestsPerKilosecond?: number;
}
export interface MintCapacityCreditsContext extends MintCapacityCreditsPerDay, MintCapacityCreditsPerSecond, MintCapacityCreditsPerKilosecond {
}
export interface MintCapacityCreditsRes {
    rliTxHash: string;
    capacityTokenId: any;
    capacityTokenIdStr: string;
}
