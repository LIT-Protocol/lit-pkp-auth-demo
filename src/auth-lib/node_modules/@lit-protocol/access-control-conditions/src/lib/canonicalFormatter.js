"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.canonicalResourceIdFormatter = exports.canonicalCosmosConditionFormatter = exports.canonicalEVMContractConditionFormatter = exports.canonicalAccessControlConditionFormatter = exports.canonicalSolRpcConditionFormatter = exports.canonicalUnifiedAccessControlConditionFormatter = void 0;
const constants_1 = require("@lit-protocol/constants");
const misc_1 = require("@lit-protocol/misc");
/** ---------- Local Functions ---------- */
/**
 *
 * Get operator param
 *
 * @param { ConditionItem } cond
 * @returns { AccsOperatorParams }
 */
const getOperatorParam = (cond) => {
    const _cond = cond;
    return {
        operator: _cond.operator,
    };
};
/**
 *
 * Canonical ABI Params
 *
 * @param { Array<ABIParams> } params
 * @returns { Array<ABIParams> }
 */
const canonicalAbiParamss = (params) => {
    return params.map((param) => ({
        name: param.name,
        type: param.type,
    }));
};
/**
 *
 * Canonical Unified Access Control Condition Formatter
 *
 * @param { UnifiedAccessControlConditions | ConditionItem } cond
 * @returns { any[] | AccsOperatorParams | any }
 */
const canonicalUnifiedAccessControlConditionFormatter = (cond) => {
    // -- if it's an array
    if (Array.isArray(cond)) {
        return cond.map((c) => (0, exports.canonicalUnifiedAccessControlConditionFormatter)(c));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        return getOperatorParam(cond);
    }
    // -- otherwise
    if ('returnValueTest' in cond) {
        const _cond = cond;
        const _conditionType = _cond.conditionType;
        switch (_conditionType) {
            case 'solRpc':
                return (0, exports.canonicalSolRpcConditionFormatter)(cond, true);
            case 'evmBasic':
                return (0, exports.canonicalAccessControlConditionFormatter)(cond);
            case 'evmContract':
                return (0, exports.canonicalEVMContractConditionFormatter)(cond);
            case 'cosmos':
                return (0, exports.canonicalCosmosConditionFormatter)(cond);
            default:
                (0, misc_1.throwError)({
                    message: `You passed an invalid access control condition that is missing or has a wrong "conditionType": ${JSON.stringify(cond)}`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name,
                });
        }
    }
    (0, misc_1.throwError)({
        message: `You passed an invalid access control condition: ${cond}`,
        errorKind: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
        errorCode: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name,
    });
};
exports.canonicalUnifiedAccessControlConditionFormatter = canonicalUnifiedAccessControlConditionFormatter;
/**
*
* (SOLANA) Canonical Solana RPC Condition Formatter
*
* need to return in the exact format below:
* but make sure we don't include the optional fields:
 ---
  #[derive(Debug, Serialize, Deserialize, Clone)]
  #[serde(rename_all = "camelCase")]
  pub struct SolRpcCondition {
      pub method: String,
      pub params: Vec<serde_json::Value>,
      pub pda_params: Option<Vec<serde_json::Value>>,
      pub pda_interface: Option<SolPdaInterface>,
      pub chain: String,
      pub return_value_test: JsonReturnValueTestV2,
  }

  #[derive(Debug, Serialize, Deserialize, Clone)]
  #[serde(rename_all = "camelCase")]
  pub struct SolPdaInterface {
      pub offset: u64,
      pub fields: serde_json::Value,
  }
  ---
*
* @param { object } cond
* @param { boolean } requireV2Conditions
*
* @returns { any[] | AccsOperatorParams | AccsSOLV2Params | ILitError | any }
*/
const canonicalSolRpcConditionFormatter = (cond, requireV2Conditions = false) => {
    // -- if is array
    if (Array.isArray(cond)) {
        return cond.map((c) => (0, exports.canonicalSolRpcConditionFormatter)(c, requireV2Conditions));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        return getOperatorParam(cond);
    }
    // -- if it has a return value
    if ('returnValueTest' in cond) {
        const { returnValueTest } = cond;
        const canonicalReturnValueTest = {
            // @ts-ignore
            key: returnValueTest.key,
            comparator: returnValueTest.comparator,
            value: returnValueTest.value,
        };
        // -- check if this is a sol v1 or v2 condition
        // -- v1 conditions didn't have any pda params or pda interface or pda key
        // -- SOL version 1:: return V2 must have params
        if ('pdaParams' in cond || requireV2Conditions) {
            const _assumedV2Cond = cond;
            if (!('pdaInterface' in _assumedV2Cond) ||
                !('pdaKey' in _assumedV2Cond) ||
                !('offset' in _assumedV2Cond.pdaInterface) ||
                !('fields' in _assumedV2Cond.pdaInterface)) {
                (0, misc_1.throwError)({
                    message: `Solana RPC Conditions have changed and there are some new fields you must include in your condition.  Check the docs here: https://developer.litprotocol.com/AccessControlConditions/solRpcConditions`,
                    errorKind: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name,
                });
            }
            // -- else
            const canonicalPdaInterface = {
                offset: _assumedV2Cond.pdaInterface.offset,
                fields: _assumedV2Cond.pdaInterface.fields,
            };
            const _solV2Cond = cond;
            const _requiredParams = {
                method: _solV2Cond.method,
                params: _solV2Cond.params,
                pdaParams: _solV2Cond.pdaParams,
                pdaInterface: canonicalPdaInterface,
                pdaKey: _solV2Cond.pdaKey,
                chain: _solV2Cond.chain,
                returnValueTest: canonicalReturnValueTest,
            };
            return _requiredParams;
            // -- SOL version 2:: return default params
        }
        else {
            const _solV1Cond = cond;
            const _requiredParams = {
                // @ts-ignore
                method: _solV1Cond.method,
                // @ts-ignore
                params: _solV1Cond.params,
                chain: _solV1Cond.chain,
                returnValueTest: canonicalReturnValueTest,
            };
            return _requiredParams;
        }
    }
    // -- else
    (0, misc_1.throwError)({
        message: `You passed an invalid access control condition: ${cond}`,
        errorKind: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
        errorCode: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name,
    });
};
exports.canonicalSolRpcConditionFormatter = canonicalSolRpcConditionFormatter;
/**
*
* (DEFAULT) Canonical Access Control Condition Formatter
*
* need to return in the exact format below:
 ---
  pub struct JsonAccessControlCondition {
    pub contract_address: String,
    pub chain: String,
    pub standard_contract_type: String,
    pub method: String,
    pub parameters: Vec<String>,
    pub return_value_test: JsonReturnValueTest,
  }
  ---
*
* @param { AccsDefaultParams | AccsOperatorParams | AccessControlConditions } cond
*
* @returns { any[] | AccsOperatorParams | AccsDefaultParams | any }
*/
const canonicalAccessControlConditionFormatter = (cond) => {
    // -- if it's an array
    if (Array.isArray(cond)) {
        return cond.map((c) => (0, exports.canonicalAccessControlConditionFormatter)(c));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        return getOperatorParam(cond);
    }
    if ('returnValueTest' in cond) {
        const _cond = cond;
        const _return = {
            contractAddress: _cond.contractAddress,
            chain: _cond.chain,
            standardContractType: _cond.standardContractType,
            method: _cond.method,
            parameters: _cond.parameters,
            returnValueTest: {
                comparator: _cond.returnValueTest.comparator,
                value: _cond.returnValueTest.value,
            },
        };
        return _return;
    }
    (0, misc_1.throwError)({
        message: `You passed an invalid access control condition: ${cond}`,
        errorKind: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
        errorCode: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name,
    });
};
exports.canonicalAccessControlConditionFormatter = canonicalAccessControlConditionFormatter;
/**
*
* (EVM) Canonical EVM Contract Condition Formatter
*
*  need to return in the exact format below:
  ---
  pub struct JsonAccessControlCondition {
      pub contract_address: String,
      pub chain: String,
      pub standard_contract_type: String,
      pub method: String,
      pub parameters: Vec<String>,
      pub return_value_test: JsonReturnValueTest,
  }
  ---
*
* @param { AccsEVMParams | AccsOperatorParams | EvmContractConditions } cond
*
* @returns
*/
const canonicalEVMContractConditionFormatter = (cond) => {
    // -- if it's an array
    if (Array.isArray(cond)) {
        return cond.map((c) => (0, exports.canonicalEVMContractConditionFormatter)(c));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        const _cond = cond;
        return {
            operator: _cond.operator,
        };
    }
    if ('returnValueTest' in cond) {
        /* abi needs to match:
          pub name: String,
          /// Function input.
          pub inputs: Vec<Param>,
          /// Function output.
          pub outputs: Vec<Param>,
          #[deprecated(note = "The constant attribute was removed in Solidity 0.5.0 and has been \
              replaced with stateMutability. If parsing a JSON AST created with \
              this version or later this value will always be false, which may be wrong.")]
          /// Constant function.
          #[cfg_attr(feature = "full-serde", serde(default))]
          pub constant: bool,
          /// Whether the function reads or modifies blockchain state
          #[cfg_attr(feature = "full-serde", serde(rename = "stateMutability", default))]
          pub state_mutability: StateMutability,
          */
        const evmCond = cond;
        const { functionAbi, returnValueTest } = evmCond;
        const canonicalAbi = {
            name: functionAbi.name,
            inputs: canonicalAbiParamss(functionAbi.inputs),
            outputs: canonicalAbiParamss(functionAbi.outputs),
            constant: typeof functionAbi.constant === 'undefined'
                ? false
                : functionAbi.constant,
            stateMutability: functionAbi.stateMutability,
        };
        const canonicalReturnValueTest = {
            key: returnValueTest.key,
            comparator: returnValueTest.comparator,
            value: returnValueTest.value,
        };
        const _return = {
            contractAddress: evmCond.contractAddress,
            functionName: evmCond.functionName,
            functionParams: evmCond.functionParams,
            functionAbi: canonicalAbi,
            chain: evmCond.chain,
            returnValueTest: canonicalReturnValueTest,
        };
        return _return;
    }
    (0, misc_1.throwError)({
        message: `You passed an invalid access control condition: ${cond}`,
        errorKind: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
        errorCode: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name,
    });
};
exports.canonicalEVMContractConditionFormatter = canonicalEVMContractConditionFormatter;
/**
*
* (COSMOS) Canonical Condition Formmater for Cosmos
*
* need to return in the exact format below:
 ---
  pub struct CosmosCondition {
      pub path: String,
      pub chain: String,
      pub return_value_test: JsonReturnValueTestV2,
  }
 ---
*
*
* @param { ConditionItem } cond
* @returns
*/
const canonicalCosmosConditionFormatter = (cond) => {
    // -- if it's an array
    if (Array.isArray(cond)) {
        return cond.map((c) => (0, exports.canonicalCosmosConditionFormatter)(c));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        const _cond = cond;
        return {
            operator: _cond.operator,
        };
    }
    if ('returnValueTest' in cond) {
        const _cosmosCond = cond;
        const { returnValueTest } = _cosmosCond;
        const canonicalReturnValueTest = {
            key: returnValueTest.key,
            comparator: returnValueTest.comparator,
            value: returnValueTest.value,
        };
        return {
            path: _cosmosCond.path,
            chain: _cosmosCond.chain,
            method: _cosmosCond?.method,
            parameters: _cosmosCond?.parameters,
            returnValueTest: canonicalReturnValueTest,
        };
    }
    (0, misc_1.throwError)({
        message: `You passed an invalid access control condition: ${cond}`,
        errorKind: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.kind,
        errorCode: constants_1.LIT_ERROR.INVALID_ACCESS_CONTROL_CONDITIONS.name,
    });
};
exports.canonicalCosmosConditionFormatter = canonicalCosmosConditionFormatter;
/**
 *
 * Canonical ResourceId Formatter returning JSON signing resource id
 *
 * @param { JsonSigningResourceId } resId
 *
 * @returns { JsonSigningResourceId }
 *
 */
const canonicalResourceIdFormatter = (resId) => {
    // need to return in the exact format below:
    return {
        baseUrl: resId.baseUrl,
        path: resId.path,
        orgId: resId.orgId,
        role: resId.role,
        extraData: resId.extraData,
    };
};
exports.canonicalResourceIdFormatter = canonicalResourceIdFormatter;
//# sourceMappingURL=canonicalFormatter.js.map