"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateUnifiedAccessControlConditionsSchema = exports.validateSolRpcConditionsSchema = exports.validateEVMContractConditionsSchema = exports.validateAccessControlConditionsSchema = void 0;
const constants_1 = require("@lit-protocol/constants");
const misc_1 = require("@lit-protocol/misc");
const accs_schemas_1 = require("@lit-protocol/accs-schemas");
const SCHEMA_NAME_MAP = {
    cosmos: 'LPACC_ATOM',
    evmBasic: 'LPACC_EVM_BASIC',
    evmContract: 'LPACC_EVM_CONTRACT',
    solRpc: 'LPACC_SOL',
};
async function getSchema(accType) {
    try {
        const schemaName = SCHEMA_NAME_MAP[accType];
        return (0, accs_schemas_1.loadSchema)(schemaName);
    }
    catch (err) {
        return (0, misc_1.throwError)({
            message: `No schema found for condition type ${accType}`,
            errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
            errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
        });
    }
}
/**
 * Validates EVM basic access control conditions schema
 * @param { AccessControlConditions } accs
 */
const validateAccessControlConditionsSchema = async (accs) => {
    for (const acc of accs) {
        // conditions can be nested to make boolean expressions
        if (Array.isArray(acc)) {
            await (0, exports.validateAccessControlConditionsSchema)(acc);
            continue;
        }
        if ('operator' in acc) {
            // condition is operator, skip
            continue;
        }
        (0, misc_1.checkSchema)(acc, await getSchema('evmBasic'), 'accessControlConditions', 'validateAccessControlConditionsSchema');
    }
    return true;
};
exports.validateAccessControlConditionsSchema = validateAccessControlConditionsSchema;
/**
 * Validates EVM contract access control conditions schema
 * @param { EvmContractConditions } accs
 */
const validateEVMContractConditionsSchema = async (accs) => {
    for (const acc of accs) {
        // conditions can be nested to make boolean expressions
        if (Array.isArray(acc)) {
            await (0, exports.validateEVMContractConditionsSchema)(acc);
            continue;
        }
        if ('operator' in acc) {
            // condition is operator, skip
            continue;
        }
        (0, misc_1.checkSchema)(acc, await getSchema('evmContract'), 'evmContractConditions', 'validateEVMContractConditionsSchema');
    }
    return true;
};
exports.validateEVMContractConditionsSchema = validateEVMContractConditionsSchema;
/**
 * Validates Sol access control conditions schema
 * @param { SolRpcConditions } accs
 */
const validateSolRpcConditionsSchema = async (accs) => {
    for (const acc of accs) {
        // conditions can be nested to make boolean expressions
        if (Array.isArray(acc)) {
            await (0, exports.validateSolRpcConditionsSchema)(acc);
            continue;
        }
        if ('operator' in acc) {
            // condition is operator, skip
            continue;
        }
        (0, misc_1.checkSchema)(acc, await getSchema('solRpc'), 'solRpcConditions', 'validateSolRpcConditionsSchema');
    }
    return true;
};
exports.validateSolRpcConditionsSchema = validateSolRpcConditionsSchema;
/**
 * Validates unified access control conditions schema
 * @param { UnifiedAccessControlConditions } accs
 */
const validateUnifiedAccessControlConditionsSchema = async (accs) => {
    for (const acc of accs) {
        // conditions can be nested to make boolean expressions
        if (Array.isArray(acc)) {
            await (0, exports.validateUnifiedAccessControlConditionsSchema)(acc);
            continue;
        }
        if ('operator' in acc) {
            // condition is operator, skip
            continue;
        }
        let schema;
        switch (acc.conditionType) {
            case 'evmBasic':
                schema = await getSchema('evmBasic');
                break;
            case 'evmContract':
                schema = await getSchema('evmContract');
                break;
            case 'solRpc':
                schema = await getSchema('solRpc');
                break;
            case 'cosmos':
                schema = await getSchema('cosmos');
                break;
        }
        if (schema) {
            (0, misc_1.checkSchema)(acc, schema, 'accessControlConditions', 'validateUnifiedAccessControlConditionsSchema');
        }
        else {
            (0, misc_1.throwError)({
                message: `Missing schema to validate condition type ${acc.conditionType}`,
                errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
            });
        }
    }
    return true;
};
exports.validateUnifiedAccessControlConditionsSchema = validateUnifiedAccessControlConditionsSchema;
//# sourceMappingURL=validator.js.map