import { BigNumberish, BytesLike, ethers } from 'ethers';
import { hexToDec, decToHex } from './hex2dec';
import { AuthMethod, LitContractContext, LitContractResolverContext, MintCapacityCreditsContext, MintCapacityCreditsRes } from '@lit-protocol/types';
import * as allowlistContract from '../abis/Allowlist.sol/Allowlist';
import * as litTokenContract from '../abis/LITToken.sol/LITToken';
import * as multisenderContract from '../abis/Multisender.sol/Multisender';
import * as pkpHelperContract from '../abis/PKPHelper.sol/PKPHelper';
import * as pkpNftContract from '../abis/PKPNFT.sol/PKPNFT';
import * as pkpNftMetadataContract from '../abis/PKPNFTMetadata.sol/PKPNFTMetadata';
import * as pkpPermissionsContract from '../abis/PKPPermissions.sol/PKPPermissions';
import * as pubkeyRouterContract from '../abis/PubkeyRouter.sol/PubkeyRouter';
import * as rateLimitNftContract from '../abis/RateLimitNFT.sol/RateLimitNFT';
import * as stakingContract from '../abis/Staking.sol/Staking';
import * as stakingBalancesContract from '../abis/StakingBalances.sol/StakingBalances';
import { TokenInfo } from './addresses';
import { IPubkeyRouter } from '../abis/PKPNFT.sol/PKPNFT';
import { Logger } from '@lit-protocol/logger';
export declare const asyncForEachReturn: (array: Array<any>, callback: Function) => Promise<any[]>;
export interface IPFSHash {
    digest: string;
    hashFunction: number;
    size: number;
}
declare global {
    interface Window {
        ethereum: any;
    }
}
export declare class LitContracts {
    provider: ethers.providers.JsonRpcProvider | any;
    rpc: string;
    rpcs: string[];
    signer: ethers.Signer | ethers.Wallet;
    privateKey: string | undefined;
    options?: {
        storeOrUseStorageKey?: boolean;
    };
    randomPrivateKey: boolean;
    connected: boolean;
    isPKP: boolean;
    debug: boolean;
    network: 'cayenne' | 'manzano' | 'habanero' | 'custom' | 'localhost';
    customContext?: LitContractContext | LitContractResolverContext;
    static logger: Logger;
    allowlistContract: {
        read: allowlistContract.Allowlist;
        write: allowlistContract.Allowlist;
    };
    litTokenContract: {
        read: litTokenContract.LITToken;
        write: litTokenContract.LITToken;
    };
    multisenderContract: {
        read: multisenderContract.Multisender;
        write: multisenderContract.Multisender;
    };
    pkpHelperContract: {
        read: pkpHelperContract.PKPHelper;
        write: pkpHelperContract.PKPHelper;
    };
    pkpNftContract: {
        read: pkpNftContract.PKPNFT;
        write: pkpNftContract.PKPNFT;
    };
    pkpNftMetadataContract: {
        read: pkpNftMetadataContract.PKPNFTMetadata;
        write: pkpNftMetadataContract.PKPNFTMetadata;
    };
    pkpPermissionsContract: {
        read: pkpPermissionsContract.PKPPermissions;
        write: pkpPermissionsContract.PKPPermissions;
    };
    pubkeyRouterContract: {
        read: pubkeyRouterContract.PubkeyRouter;
        write: pubkeyRouterContract.PubkeyRouter;
    };
    rateLimitNftContract: {
        read: rateLimitNftContract.RateLimitNFT;
        write: rateLimitNftContract.RateLimitNFT;
    };
    stakingContract: {
        read: stakingContract.Staking;
        write: stakingContract.Staking;
    };
    stakingBalancesContract: {
        read: stakingBalancesContract.StakingBalances;
        write: stakingBalancesContract.StakingBalances;
    };
    constructor(args?: {
        provider?: ethers.providers.JsonRpcProvider | any;
        customContext?: LitContractContext | LitContractResolverContext;
        rpcs?: string[] | any;
        rpc?: string | any;
        signer?: ethers.Signer | any;
        privateKey?: string | undefined;
        randomPrivatekey?: boolean;
        options?: {
            storeOrUseStorageKey?: boolean;
        };
        debug?: boolean;
        network?: 'cayenne' | 'custom' | 'localhost' | 'manzano' | 'habanero';
    });
    /**
     * Logs a message to the console.
     *
     * @param {any} [args] An optional value to log with the message.
     */
    log: (...args: any) => void;
    connect: () => Promise<void>;
    static getStakingContract(network: 'cayenne' | 'manzano' | 'habanero' | 'custom' | 'localhost', context?: LitContractContext | LitContractResolverContext): Promise<ethers.Contract>;
    private static _getContractsFromResolver;
    static getContractAddresses(network: 'cayenne' | 'custom' | 'localhost' | 'manzano' | 'habanero', provider: ethers.providers.JsonRpcProvider, context?: LitContractContext | LitContractResolverContext): Promise<any>;
    static getMinNodeCount: (network: 'cayenne' | 'manzano' | 'habanero' | 'custom' | 'localhost', context?: LitContractContext | LitContractResolverContext) => Promise<any>;
    static getValidators: (network: 'cayenne' | 'manzano' | 'habanero' | 'custom' | 'localhost', context?: LitContractContext | LitContractResolverContext) => Promise<string[]>;
    private static _resolveContractContext;
    mintWithAuth: ({ authMethod, scopes, pubkey, }: {
        authMethod: AuthMethod;
        scopes: string[] | number[] | BigNumberish[];
        pubkey?: string | undefined;
    }) => Promise<{
        pkp: {
            tokenId: string;
            publicKey: string;
            ethAddress: string;
        };
        tx: ethers.ContractReceipt;
    }>;
    mintCapacityCreditsNFT: ({ requestsPerDay, requestsPerSecond, requestsPerKilosecond, daysUntilUTCMidnightExpiration, }: MintCapacityCreditsContext) => Promise<MintCapacityCreditsRes>;
    utils: {
        hexToDec: typeof hexToDec;
        decToHex: typeof decToHex;
        /**
         * Partition multihash string into object representing multihash
         *
         * @param {string} multihash A base58 encoded multihash string
         * @returns {Multihash}
         */
        getBytesFromMultihash: (multihash: string) => string;
        /**
         *
         * Convert bytes32 to IPFS ID
         * @param { string } byte32 0x1220baa0d1e91f2a22fef53659418ddc3ac92da2a76d994041b86ed62c0c999de477
         * @returns { string } QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
         */
        getMultihashFromBytes: (byte32: string) => string;
        /**
         * Partition multihash string into object representing multihash
         *
         * @param {string} multihash A base58 encoded multihash string
         * @returns {Multihash}
         */
        getBytes32FromMultihash: (ipfsId: string) => Promise<IPFSHash>;
        timestamp2Date: (timestamp: string) => string;
    };
    pkpNftContractUtils: {
        read: {
            /**
             * (IERC721Enumerable)
             *
             * Get all PKPs by a given address
             *
             * @param { string } ownerAddress
             * @retu
             * */
            getTokensByAddress: (ownerAddress: string) => Promise<Array<string>>;
            /**
             * (IERC721Enumerable)
             *
             * Get the x latest number of tokens
             *
             * @param { number } latestNumberOfTokens
             *
             * @returns { Array<string> } a list of PKP NFTs
             *
             */
            getTokens: (latestNumberOfTokens: number) => Promise<Array<string>>;
            /**
             * Get info of all PKPs by a given address
             */
            getTokensInfoByAddress: (ownerAddress: string) => Promise<Array<TokenInfo>>;
        };
        write: {
            mint: () => Promise<{
                pkp: {
                    tokenId: any;
                    publicKey: string;
                    ethAddress: string;
                };
                tx: ethers.providers.TransactionResponse;
                tokenId: any;
                res: any;
            }>;
            claimAndMint: (derivedKeyId: BytesLike, signatures: IPubkeyRouter.SignatureStruct[], txOpts?: any) => Promise<{
                tx: ethers.ContractTransaction;
                res: ethers.ContractReceipt;
                tokenId: any;
            }>;
        };
    };
    pkpPermissionsContractUtils: {
        read: {
            /**
             *
             * Check if an address is permitted
             *
             * @param { string } tokenId
             * @param { string } address
             *
             * @returns { Promise<boolean> }
             */
            isPermittedAddress: (tokenId: string, address: string) => Promise<boolean>;
            getPermittedAddresses: (tokenId: string) => Promise<Array<string>>;
            /**
             *
             * Get permitted action
             *
             * @param { any } id
             *
             * @returns { Promise<Array<any>> }
             *
             */
            getPermittedActions: (tokenId: any) => Promise<Array<any>>;
            /**
             *
             * Check if an action is permitted given the pkpid and ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             *
             * @return { object } transaction
             */
            isPermittedAction: (pkpId: string, ipfsId: string) => Promise<boolean>;
        };
        write: {
            /**
             *
             * Add permitted action to a given PKP id & ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             *
             * @return { object } transaction
             */
            addPermittedAction: (pkpId: string, ipfsId: string) => Promise<any>;
            /**
             * TODO: add transaction type
             * Add permitted action to a given PKP id & ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ownerAddress  0x3B5dD2605.....22aDC499A1
             *
             * @return { object } transaction
             */
            addPermittedAddress: (pkpId: string, ownerAddress: string) => Promise<any>;
            /**
             * Revoke permitted action of a given PKP id & ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             *
             * @return { object } transaction
             */
            revokePermittedAction: (pkpId: string, ipfsId: string) => Promise<any>;
        };
    };
    rateLimitNftContractUtils: {
        read: {
            /**
             * getCapacityByIndex: async (index: number): Promise<any> => {
             *
             *  This function takes a token index as a parameter and returns the capacity of the token
             *  with the given index. The capacity is an object that contains the number of requests
             *  per millisecond that the token allows, and an object with the expiration timestamp and
             *  formatted expiration date of the token.
             *
             *  @param {number} index - The index of the token.
             *  @returns {Promise<any>} - A promise that resolves to the capacity of the token.
             *
             *  Example:
             *
             *  const capacity = await getCapacityByIndex(1);
             *  this.log(capacity);
             *  // Output: {
             *  //   requestsPerMillisecond: 100,
             *  //   expiresAt: {
             *  //     timestamp: 1623472800,
             *  //     formatted: '2022-12-31',
             *  //   },
             *  // }
             *
             * }
             */
            getCapacityByIndex: (index: number) => Promise<any>;
            /**
             * getTokenURIByIndex: async (index: number): Promise<string> => {
             *
             *  This function takes a token index as a parameter and returns the URI of the token
             *  with the given index.
             *
             *  @param {number} index - The index of the token.
             *  @returns {Promise<string>} - A promise that resolves to the URI of the token.
             *
             *  Example:
             *
             *  const URI = await getTokenURIByIndex(1);
             *  this.log(URI);
             *  // Output: 'https://tokens.com/1'
             *
             * }
             */
            getTokenURIByIndex: (index: number) => Promise<string>;
            /**
             * getTokensByOwnerAddress: async (ownerAddress: string): Promise<any> => {
             *
             *  This function takes an owner address as a parameter and returns an array of tokens
             *  that are owned by the given address.
             *
             *  @param {string} ownerAddress - The address of the owner.
             *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
             *
             *  Example:
             *
             *  const tokens = await getTokensByOwnerAddress('0x1234...5678');
             *  this.log(tokens);
             *  // Output: [
             *  //   {
             *  //     tokenId: 1,
             *  //     URI: 'https://tokens.com/1',
             *  //     capacity: 100,
             *  //     isExpired: false,
             *  //   },
             *  //   {
             *  //     tokenId: 2,
             *  //     URI: 'https://tokens.com/2',
             *  //     capacity: 200,
             *  //     isExpired: true,
             *  //   },
             *  //   ...
             *  // ]
             *
             * }
             */
            getTokensByOwnerAddress: (ownerAddress: string) => Promise<any>;
            /**
             * getTokens: async (): Promise<any> => {
             *
             *  This function returns an array of all tokens that have been minted.
             *
             *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
             *
             *  Example:
             *
             *  const tokens = await getTokens();
             *  this.log(tokens);
             *  // Output: [
             *  //   {
             *  //     tokenId: 1,
             *  //     URI: 'https://tokens.com/1',
             *  //     capacity: 100,
             *  //     isExpired: false,
             *  //   },
             *  //   {
             *  //     tokenId: 2,
             *  //     URI: 'https://tokens.com/2',
             *  //     capacity: 200,
             *  //     isExpired: true,
             *  //   },
             *  //   ...
             *  // ]
             *
             * }
             */
            getTokens: () => Promise<any>;
        };
        write: {
            mint: ({ mintCost, timestamp, }: {
                mintCost: {
                    value: any;
                };
                timestamp: number;
            }) => Promise<{
                tx: ethers.ContractTransaction;
                tokenId: any;
            }>;
            /**
             * Transfer RLI token from one address to another
             *
             * @property { string } fromAddress
             * @property { string } toAddress
             * @property  { stsring } RLITokenAddress
             *
             * @return { <Promise<void>> } void
             */
            transfer: ({ fromAddress, toAddress, RLITokenAddress, }: {
                fromAddress: string;
                toAddress: string;
                RLITokenAddress: string;
            }) => Promise<any>;
        };
    };
    routerContractUtils: {
        read: {};
        write: {};
    };
    pkpHelperContractUtil: {
        read: {};
        write: {
            /**
             *
             * @param param0
             * @returns
             */
            mintNextAndAddAuthMethods: ({ keyType, permittedAuthMethodTypes, permittedAuthMethodIds, permittedAuthMethodPubkeys, permittedAuthMethodScopes, addPkpEthAddressAsPermittedAddress, sendPkpToItself, }: {
                keyType: string;
                permittedAuthMethodTypes: string[];
                permittedAuthMethodIds: string[];
                permittedAuthMethodPubkeys: string[];
                permittedAuthMethodScopes: string[][];
                addPkpEthAddressAsPermittedAddress: boolean;
                sendPkpToItself: boolean;
            }) => Promise<any>;
        };
    };
}
