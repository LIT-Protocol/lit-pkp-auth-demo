"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signAndSaveAuthMessage = exports.checkAndSignSolAuthMessage = exports.connectSolProvider = void 0;
const constants_1 = require("@lit-protocol/constants");
const misc_1 = require("@lit-protocol/misc");
const misc_browser_1 = require("@lit-protocol/misc-browser");
// import { toString as uint8arrayToString } from 'uint8arrays';
const uint8arrays_1 = require("@lit-protocol/uint8arrays");
/**
 *
 * Get the Solana provider from the browser web3 extension
 *
 * @returns { object || never }
 */
const getProvider = () => {
    let resultOrError;
    // -- validate
    // The Backpack wallet does not inject a solana object into the window, so we need to check for the backpack object as well.
    if ('solana' in window || 'backpack' in window) {
        // only check for the solana object on the window, as keplr does not have the same client interface injected into the window.
        // @ts-ignore
        resultOrError = (0, constants_1.ERight)(window?.solana ?? window?.backpack);
    }
    else {
        // -- finally
        const message = 'No web3 wallet was found that works with Solana.  Install a Solana wallet or choose another chain';
        resultOrError = (0, constants_1.ELeft)({
            message,
            errorKind: constants_1.LIT_ERROR.NO_WALLET_EXCEPTION.kind,
            errorCode: constants_1.LIT_ERROR.NO_WALLET_EXCEPTION.name,
        });
    }
    return resultOrError;
};
/**
 *
 * Get Solana provider
 *
 * @returns { Promise<IProvider | undefined }
 */
const connectSolProvider = async () => {
    const providerOrError = getProvider();
    if (providerOrError.type === 'ERROR') {
        (0, misc_1.throwError)(providerOrError.result);
        return;
    }
    let provider = providerOrError.result;
    // No need to reconnect if already connected, some wallets such as Backpack throws an error when doing so.
    if (!provider.isConnected) {
        await provider.connect();
    }
    const account = provider.publicKey.toBase58();
    return { provider, account };
};
exports.connectSolProvider = connectSolProvider;
/**
 *
 * Check and sign solana auth message
 *
 * @returns { AuthSig }
 */
const checkAndSignSolAuthMessage = async () => {
    const res = await (0, exports.connectSolProvider)();
    if (!res) {
        (0, misc_1.log)('Failed to connect sol provider');
    }
    const provider = res?.provider;
    const account = res?.account;
    const key = constants_1.LOCAL_STORAGE_KEYS.AUTH_SOL_SIGNATURE;
    let authSigOrError = (0, misc_browser_1.getStorageItem)(key);
    // let authSig = localStorage.getItem("lit-auth-sol-signature");
    let authSig;
    // -- case: if unable to get auth from local storage
    if (authSigOrError.type === "ERROR" /* EITHER_TYPE.ERROR */) {
        (0, misc_1.log)('signing auth message because sig is not in local storage');
        await (0, exports.signAndSaveAuthMessage)({ provider });
        authSigOrError.type = "SUCCESS" /* EITHER_TYPE.SUCCESS */;
        // @ts-ignore
        authSigOrError.result = (0, misc_browser_1.getStorageItem)(key);
    }
    //   @ts-ignore
    window.test = authSigOrError;
    try {
        // when it's not in local storage, it's a string
        // @ts-ignore
        authSig = JSON.parse(authSigOrError.result.result);
    }
    catch (e) {
        // when it's in local storage, it's an object
        // @ts-ignore
        authSig = JSON.parse(authSigOrError.result);
    }
    // -- if the wallet address isn't the same as the address from local storage
    if (account !== authSig.address) {
        (0, misc_1.log)('signing auth message because account is not the same as the address in the auth sig');
        await (0, exports.signAndSaveAuthMessage)({ provider });
        authSigOrError.type = "SUCCESS" /* EITHER_TYPE.SUCCESS */;
        // @ts-ignore
        authSigOrError.result = (0, misc_browser_1.getStorageItem)(key);
        // @ts-ignore
        authSig = JSON.parse(authSigOrError.result);
    }
    (0, misc_1.log)('authSig', authSig);
    return authSig;
};
exports.checkAndSignSolAuthMessage = checkAndSignSolAuthMessage;
/**
 *
 * Sign and save auth signature locally (not saved to the nodes)
 *
 * @property { any } provider
 * @return { Promise<AuthSig | undefined> }
 *
 */
const signAndSaveAuthMessage = async ({ provider, }) => {
    const now = new Date().toISOString();
    const body = constants_1.AUTH_SIGNATURE_BODY.replace('{{timestamp}}', now);
    //   turn body into Uint8Array
    const data = (0, uint8arrays_1.uint8arrayFromString)(body, 'utf8');
    //   const data = naclUtil.encode(body);
    let payload;
    let derivedVia = 'solana.signMessage';
    // Backpack wallet expects and returns a different payload from signMessage()
    if (provider?.isBackpack) {
        const result = await provider.signMessage(data);
        payload = { signature: result };
        derivedVia = 'backpack.signMessage';
    }
    else {
        payload = await provider.signMessage(data, 'utf8');
    }
    const hexSig = (0, uint8arrays_1.uint8arrayToString)(payload.signature, 'base16');
    const authSig = {
        sig: hexSig,
        derivedVia,
        signedMessage: body,
        address: provider.publicKey.toBase58(),
    };
    localStorage.setItem(constants_1.LOCAL_STORAGE_KEYS.AUTH_SOL_SIGNATURE, JSON.stringify(authSig));
    return authSig;
};
exports.signAndSaveAuthMessage = signAndSaveAuthMessage;
//# sourceMappingURL=sol.js.map