"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signMessageAsync = exports.signMessage = exports.signAndSaveAuthMessage = exports.checkAndSignEVMAuthMessage = exports.disconnectWeb3 = exports.connectWeb3 = exports.decodeCallResult = exports.encodeCallData = exports.getRPCUrls = exports.getMustResign = exports.isSignedMessageExpired = exports.getChainId = exports.chainHexIdToChainName = void 0;
const constants_1 = require("@lit-protocol/constants");
const ethers_1 = require("ethers");
// import WalletConnectProvider from '@walletconnect/ethereum-provider';
const strings_1 = require("@ethersproject/strings");
const bytes_1 = require("@ethersproject/bytes");
const wallet_1 = require("@ethersproject/wallet");
const ethereum_provider_1 = require("@walletconnect/ethereum-provider");
const modal_1 = require("../connect-modal/modal");
const providers_1 = require("@ethersproject/providers");
const siwe_1 = require("siwe");
const utils_1 = require("ethers/lib/utils");
// @ts-ignore: If importing 'nacl' directly, the built files will use .default instead
const naclUtil = require("tweetnacl-util");
// @ts-ignore: If importing 'nacl' directly, the built files will use .default instead
const nacl = require("tweetnacl");
const buffer_1 = require("buffer");
const misc_1 = require("@lit-protocol/misc");
const misc_browser_1 = require("@lit-protocol/misc-browser");
if (typeof global.Buffer === 'undefined') {
    global.Buffer = buffer_1.Buffer;
}
var WALLET_ERROR;
(function (WALLET_ERROR) {
    WALLET_ERROR[WALLET_ERROR["REQUESTED_CHAIN_HAS_NOT_BEEN_ADDED"] = 4902] = "REQUESTED_CHAIN_HAS_NOT_BEEN_ADDED";
    WALLET_ERROR[WALLET_ERROR["NO_SUCH_METHOD"] = -32601] = "NO_SUCH_METHOD";
})(WALLET_ERROR || (WALLET_ERROR = {}));
/** ---------- Local Helpers ---------- */
/**
 *
 * Convert chain hex id to chain name
 *
 * @param { string } chainHexId
 * @returns { void | string }
 */
const chainHexIdToChainName = (chainHexId) => {
    // -- setup
    const keys = Object.keys(constants_1.LIT_CHAINS);
    const entries = Object.entries(constants_1.LIT_CHAINS);
    const hexIds = Object.values(constants_1.LIT_CHAINS).map((chain) => '0x' + chain.chainId.toString(16));
    // -- validate:: must begin with 0x
    if (!chainHexId.startsWith('0x')) {
        (0, misc_1.throwError)({
            message: `${chainHexId} should begin with "0x"`,
            errorKind: constants_1.LIT_ERROR.WRONG_PARAM_FORMAT.kind,
            errorCode: constants_1.LIT_ERROR.WRONG_PARAM_FORMAT.name,
        });
    }
    // -- validate:: hex id must be listed in constants
    if (!hexIds.includes(chainHexId)) {
        (0, misc_1.throwError)({
            message: `${chainHexId} cannot be found in LIT_CHAINS`,
            errorKind: constants_1.LIT_ERROR.UNSUPPORTED_CHAIN_EXCEPTION.kind,
            errorCode: constants_1.LIT_ERROR.UNSUPPORTED_CHAIN_EXCEPTION.name,
        });
    }
    // -- search
    const chainName = entries.find((data) => '0x' + data[1].chainId.toString(16) === chainHexId) || null;
    // -- success case
    if (chainName) {
        return chainName[0];
    }
    // -- fail case
    (0, misc_1.throwError)({
        message: `Failed to convert ${chainHexId}`,
        errorKind: constants_1.LIT_ERROR.UNKNOWN_ERROR.kind,
        errorCode: constants_1.LIT_ERROR.UNKNOWN_ERROR.name,
    });
};
exports.chainHexIdToChainName = chainHexIdToChainName;
/**
 * Get chain id of the current network
 * @param { string } chain
 * @param { Web3Provider } web3
 * @returns { Promise<IEither> }
 */
const getChainId = async (chain, web3) => {
    let resultOrError;
    try {
        const resp = await web3.getNetwork();
        resultOrError = (0, constants_1.ERight)(resp.chainId);
    }
    catch (e) {
        // couldn't get chainId.  throw the incorrect network error
        (0, misc_1.log)('getNetwork threw an exception', e);
        resultOrError = (0, constants_1.ELeft)({
            message: `Incorrect network selected.  Please switch to the ${chain} network in your wallet and try again.`,
            errorKind: constants_1.LIT_ERROR.WRONG_NETWORK_EXCEPTION.kind,
            errorCode: constants_1.LIT_ERROR.WRONG_NETWORK_EXCEPTION.name,
        });
    }
    return resultOrError;
};
exports.getChainId = getChainId;
/**
 * Check if the Expiration Time in the signedMessage string is expired.
 * @param { string } signedMessage - The signed message containing the Expiration Time.
 * @returns true if expired, false otherwise.
 */
function isSignedMessageExpired(signedMessage) {
    // Extract the Expiration Time from the signed message.
    const dateStr = signedMessage
        .split('\n')[9]
        ?.replace('Expiration Time: ', '');
    const expirationTime = new Date(dateStr);
    const currentTime = new Date();
    // Compare the Expiration Time with the current time.
    return currentTime > expirationTime;
}
exports.isSignedMessageExpired = isSignedMessageExpired;
/**
 *
 * Check if the message must resign
 *
 * @param { AuthSig } authSig
 * @param { any } resources
 *
 * @returns { boolean }
 */
const getMustResign = (authSig, resources) => {
    let mustResign;
    // if it's not expired, then we don't need to resign
    if (!isSignedMessageExpired(authSig.signedMessage)) {
        return false;
    }
    try {
        const parsedSiwe = new siwe_1.SiweMessage(authSig.signedMessage);
        (0, misc_1.log)('parsedSiwe.resources', parsedSiwe.resources);
        if (JSON.stringify(parsedSiwe.resources) !== JSON.stringify(resources)) {
            (0, misc_1.log)('signing auth message because resources differ from the resources in the auth sig');
            mustResign = true;
        }
        if (parsedSiwe.address !== (0, utils_1.getAddress)(parsedSiwe.address)) {
            (0, misc_1.log)('signing auth message because parsedSig.address is not equal to the same address but checksummed.  This usually means the user had a non-checksummed address saved and so they need to re-sign.');
            mustResign = true;
        }
    }
    catch (e) {
        (0, misc_1.log)('error parsing siwe sig.  making the user sign again: ', e);
        mustResign = true;
    }
    return mustResign;
};
exports.getMustResign = getMustResign;
/**
 *
 * Get RPC Urls in the correct format
 * need to make it look like this:
   ---
   rpc: {
        1: "https://mainnet.mycustomnode.com",
        3: "https://ropsten.mycustomnode.com",
        100: "https://dai.poa.network",
        // ...
    },
   ---
 *
 * @returns
 */
const getRPCUrls = () => {
    const rpcUrls = {};
    const keys = Object.keys(constants_1.LIT_CHAINS);
    for (let i = 0; i < keys.length; i++) {
        const chainName = keys[i];
        const chainId = constants_1.LIT_CHAINS[chainName].chainId;
        const rpcUrl = constants_1.LIT_CHAINS[chainName].rpcUrls[0];
        rpcUrls[chainId.toString()] = rpcUrl;
    }
    return rpcUrls;
};
exports.getRPCUrls = getRPCUrls;
/** ---------- Exports ---------- */
/**
 * @deprecated
 * (ABI) Encode call data
 *
 * @param { IABIEncode }
 * @returns { string }
 */
const encodeCallData = ({ abi, functionName, functionParams, }) => {
    throw new Error('encodeCallData has been removed.');
};
exports.encodeCallData = encodeCallData;
/**
 * @deprecated
 * (ABI) Decode call data
 * TODO: fix "any"
 *
 * @param { IABIDecode }
 * @returns { string }
 */
const decodeCallResult = ({ abi, functionName, data, }) => {
    const _interface = new ethers_1.ethers.utils.Interface(abi);
    const decoded = _interface.decodeFunctionResult(functionName, data);
    return decoded;
};
exports.decodeCallResult = decodeCallResult;
/**
 * @browserOnly
 * Connect to web 3
 *
 * @param { ConnectWeb3 }
 *
 * @return { Promise<ConnectWeb3Result> } web3, account
 */
const connectWeb3 = async ({ chainId = 1, walletConnectProjectId, }) => {
    // -- check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('connectWeb3 is not supported in nodejs.');
        return { web3: null, account: null };
    }
    const rpcUrls = (0, exports.getRPCUrls)();
    let providerOptions = {};
    if (walletConnectProjectId) {
        const wcProvider = await ethereum_provider_1.EthereumProvider.init({
            projectId: walletConnectProjectId,
            chains: [chainId],
            showQrModal: true,
            optionalMethods: ['eth_sign'],
            rpcMap: rpcUrls,
        });
        providerOptions = {
            walletconnect: {
                provider: wcProvider,
            },
        };
        if ((0, misc_1.isBrowser)()) {
            // @ts-ignore
            globalThis.litWCProvider = wcProvider;
        }
    }
    (0, misc_1.log)('getting provider via lit connect modal');
    const dialog = new modal_1.default({ providerOptions });
    const provider = await dialog.getWalletProvider();
    (0, misc_1.log)('got provider');
    // @ts-ignore
    const web3 = new providers_1.Web3Provider(provider);
    // trigger metamask popup
    try {
        (0, misc_1.log)('@deprecated soon to be removed. - trying to enable provider.  this will trigger the metamask popup.');
        // @ts-ignore
        await provider.enable();
    }
    catch (e) {
        (0, misc_1.log)("error enabling provider but swallowed it because it's not important.  most wallets use a different function now to enable the wallet so you can ignore this error, because those other methods will be tried.", e);
    }
    (0, misc_1.log)('listing accounts');
    const accounts = await web3.listAccounts();
    (0, misc_1.log)('accounts', accounts);
    const account = accounts[0].toLowerCase();
    return { web3, account };
};
exports.connectWeb3 = connectWeb3;
/**
 * @browserOnly
 * Delete any saved AuthSigs from local storage. Takes no params and returns
 * nothing. This will also clear out the WalletConnect cache in local storage.
 * We often run this function as a result of the user pressing a "Logout" button.
 *
 * @return { void }
 */
const disconnectWeb3 = () => {
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('disconnectWeb3 is not supported in nodejs.');
        return;
    }
    // @ts-ignore
    if ((0, misc_1.isBrowser)() && globalThis.litWCProvider) {
        try {
            // @ts-ignore
            globalThis.litWCProvider.disconnect();
        }
        catch (err) {
            (0, misc_1.log)('Attempted to disconnect global WalletConnectProvider for lit-connect-modal', err);
        }
    }
    const storage = constants_1.LOCAL_STORAGE_KEYS;
    localStorage.removeItem(storage.AUTH_SIGNATURE);
    localStorage.removeItem(storage.AUTH_SOL_SIGNATURE);
    localStorage.removeItem(storage.AUTH_COSMOS_SIGNATURE);
    localStorage.removeItem(storage.WEB3_PROVIDER);
    localStorage.removeItem(storage.WALLET_SIGNATURE);
};
exports.disconnectWeb3 = disconnectWeb3;
/**
 * @browserOnly
 * Check and sign EVM auth message
 *
 * @param { CheckAndSignAuthParams }
 * @returns
 */
const checkAndSignEVMAuthMessage = async ({ chain, resources, switchChain, expiration, uri, walletConnectProjectId, nonce, }) => {
    // -- check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('checkAndSignEVMAuthMessage is not supported in nodejs.  You can create a SIWE on your own using the SIWE package.');
        return {
            sig: '',
            derivedVia: '',
            signedMessage: '',
            address: '',
        };
    }
    // --- scoped methods ---
    const _throwIncorrectNetworkError = (error) => {
        if (error.code === WALLET_ERROR.NO_SUCH_METHOD) {
            (0, misc_1.throwError)({
                message: `Incorrect network selected.  Please switch to the ${chain} network in your wallet and try again.`,
                errorKind: constants_1.LIT_ERROR.WRONG_NETWORK_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.WRONG_NETWORK_EXCEPTION.name,
            });
        }
        else {
            throw error;
        }
    };
    // -- 1. prepare
    const selectedChain = constants_1.LIT_CHAINS[chain];
    const expirationString = expiration ?? getDefaultExpiration();
    const { web3, account } = await (0, exports.connectWeb3)({
        chainId: selectedChain.chainId,
        walletConnectProjectId,
    });
    (0, misc_1.log)(`got web3 and account: ${account}`);
    // -- 2. prepare all required variables
    const currentChainIdOrError = await (0, exports.getChainId)(chain, web3);
    const selectedChainId = selectedChain.chainId;
    const selectedChainIdHex = (0, misc_1.numberToHex)(selectedChainId);
    const authSigOrError = (0, misc_browser_1.getStorageItem)(constants_1.LOCAL_STORAGE_KEYS.AUTH_SIGNATURE);
    (0, misc_1.log)('currentChainIdOrError:', currentChainIdOrError);
    (0, misc_1.log)('selectedChainId:', selectedChainId);
    (0, misc_1.log)('selectedChainIdHex:', selectedChainIdHex);
    (0, misc_1.log)('authSigOrError:', authSigOrError);
    // -- 3. check all variables before executing business logic
    if (currentChainIdOrError.type === "ERROR" /* EITHER_TYPE.ERROR */) {
        return (0, misc_1.throwError)(currentChainIdOrError.result);
    }
    (0, misc_1.log)('chainId from web3', currentChainIdOrError);
    (0, misc_1.log)(`checkAndSignAuthMessage with chainId ${currentChainIdOrError} and chain set to ${chain} and selectedChain is `, selectedChain);
    // -- 4. case: (current chain id is NOT equal to selected chain) AND is set to switch chain
    if (currentChainIdOrError.result !== selectedChainId && switchChain) {
        // -- validate the provider type
        // if (web3.provider instanceof walletProvider) {
        //   return throwError({
        //     message: `Incorrect network selected.  Please switch to the ${chain} network in your wallet and try again.`,
        //     error: LIT_ERROR.WRONG_NETWORK_EXCEPTION,
        //   });
        // }
        const provider = web3.provider;
        // -- (case) if able to switch chain id
        try {
            (0, misc_1.log)('trying to switch to chainId', selectedChainIdHex);
            await provider.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: selectedChainIdHex }],
            });
            // -- (case) if unable to switch chain
        }
        catch (switchError) {
            (0, misc_1.log)('error switching to chainId', switchError);
            // -- (error case)
            if (switchError.code === WALLET_ERROR.REQUESTED_CHAIN_HAS_NOT_BEEN_ADDED) {
                try {
                    const data = [
                        {
                            chainId: selectedChainIdHex,
                            chainName: selectedChain.name,
                            nativeCurrency: {
                                name: selectedChain.name,
                                symbol: selectedChain.symbol,
                                decimals: selectedChain.decimals,
                            },
                            rpcUrls: selectedChain.rpcUrls,
                            blockExplorerUrls: selectedChain.blockExplorerUrls,
                        },
                    ];
                    await provider.request({
                        method: 'wallet_addEthereumChain',
                        params: data,
                    });
                }
                catch (addError) {
                    _throwIncorrectNetworkError(addError);
                }
            }
            else {
                _throwIncorrectNetworkError(switchError);
            }
        }
        // we may have switched the chain to the selected chain.  set the chainId accordingly
        currentChainIdOrError.result = selectedChain.chainId;
    }
    // -- 5. case: Lit auth signature is NOT in the local storage
    (0, misc_1.log)('checking if sig is in local storage');
    if (authSigOrError.type === "ERROR" /* EITHER_TYPE.ERROR */) {
        (0, misc_1.log)('signing auth message because sig is not in local storage');
        try {
            // @ts-ignore
            authSigOrError.result = await _signAndGetAuth({
                web3,
                account,
                chainId: selectedChain.chainId,
                resources,
                expiration: expirationString,
                uri,
                nonce,
            });
        }
        catch (e) {
            (0, misc_1.log)(e);
            return (0, misc_1.throwError)({
                message: e.message,
                errorKind: constants_1.LIT_ERROR.UNKNOWN_ERROR.kind,
                errorCode: constants_1.LIT_ERROR.UNKNOWN_ERROR.name,
            });
        }
        authSigOrError.type = "SUCCESS" /* EITHER_TYPE.SUCCESS */;
        (0, misc_1.log)('5. authSigOrError:', authSigOrError);
    }
    // -- 6. case: Lit auth signature IS in the local storage
    // @ts-ignore
    let authSig = authSigOrError.result;
    if (typeof authSig === 'string') {
        authSig = JSON.parse(authSig);
    }
    (0, misc_1.log)('6. authSig:', authSig);
    // -- 7. case: when we are NOT on the right wallet address
    if (account.toLowerCase() !== authSig.address.toLowerCase()) {
        (0, misc_1.log)('signing auth message because account is not the same as the address in the auth sig');
        authSig = await _signAndGetAuth({
            web3,
            account,
            chainId: selectedChain.chainId,
            resources,
            expiration: expirationString,
            uri,
            nonce,
        });
        (0, misc_1.log)('7. authSig:', authSig);
        // -- 8. case: we are on the right wallet, but need to check the resources of the sig and re-sign if they don't match
    }
    else {
        let mustResign = (0, exports.getMustResign)(authSig, resources);
        if (mustResign) {
            authSig = await _signAndGetAuth({
                web3,
                account,
                chainId: selectedChain.chainId,
                resources,
                expiration: expirationString,
                uri,
                nonce,
            });
        }
        (0, misc_1.log)('8. mustResign:', mustResign);
    }
    // -- 9. finally, if the authSig is expired, re-sign
    // if it's not expired, then we don't need to resign
    if (isSignedMessageExpired(authSig.signedMessage)) {
        (0, misc_1.log)('9. authSig expired!, resigning..');
        authSig = await _signAndGetAuth({
            web3,
            account,
            chainId: selectedChain.chainId,
            resources,
            expiration: expirationString,
            uri,
            nonce,
        });
    }
    return authSig;
};
exports.checkAndSignEVMAuthMessage = checkAndSignEVMAuthMessage;
const getDefaultExpiration = () => {
    return new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString();
};
const _signAndGetAuth = async ({ web3, account, chainId, resources, expiration, uri, nonce, }) => {
    await (0, exports.signAndSaveAuthMessage)({
        web3,
        account,
        chainId,
        resources,
        expiration,
        uri,
        nonce,
    });
    let authSigOrError = (0, misc_browser_1.getStorageItem)(constants_1.LOCAL_STORAGE_KEYS.AUTH_SIGNATURE);
    if (authSigOrError.type === 'ERROR') {
        (0, misc_1.throwError)({
            message: 'Failed to get authSig from local storage',
            errorKind: constants_1.LIT_ERROR.LOCAL_STORAGE_ITEM_NOT_FOUND_EXCEPTION.kind,
            errorCode: constants_1.LIT_ERROR.LOCAL_STORAGE_ITEM_NOT_FOUND_EXCEPTION.name,
        });
    }
    let authSig = typeof authSigOrError.result === 'string'
        ? JSON.parse(authSigOrError.result)
        : authSigOrError.result;
    return authSig;
};
/**
 * @browserOnly
 * Sign the auth message with the user's wallet, and store it in localStorage.
 * Called by checkAndSignAuthMessage if the user does not have a signature stored.
 *
 * @param { signAndSaveAuthParams }
 * @returns { AuthSig }
 */
const signAndSaveAuthMessage = async ({ web3, account, chainId, resources, expiration, uri, nonce, }) => {
    // check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('checkAndSignEVMAuthMessage is not supported in nodejs.');
        return {
            sig: '',
            derivedVia: '',
            signedMessage: '',
            address: '',
        };
    }
    // -- 1. prepare 'sign-in with ethereum' message
    const preparedMessage = {
        domain: globalThis.location.host,
        address: (0, utils_1.getAddress)(account),
        version: '1',
        chainId,
        expirationTime: expiration,
        nonce,
    };
    if (resources && resources.length > 0) {
        preparedMessage.resources = resources;
    }
    if (uri) {
        preparedMessage.uri = uri;
    }
    else {
        preparedMessage.uri = globalThis.location.href;
    }
    const message = new siwe_1.SiweMessage(preparedMessage);
    const body = message.prepareMessage();
    const formattedAccount = (0, utils_1.getAddress)(account);
    // -- 2. sign the message
    let signedResult = await (0, exports.signMessage)({
        body,
        web3,
        account: formattedAccount,
    });
    // -- 3. prepare auth message
    let authSig = {
        sig: signedResult.signature,
        derivedVia: 'web3.eth.personal.sign',
        signedMessage: body,
        address: signedResult.address,
    };
    // -- 4. store auth and a keypair in localstorage for communication with sgx
    if ((0, misc_1.isBrowser)()) {
        localStorage.setItem(constants_1.LOCAL_STORAGE_KEYS.AUTH_SIGNATURE, JSON.stringify(authSig));
    }
    const commsKeyPair = nacl.box.keyPair();
    if ((0, misc_1.isBrowser)()) {
        localStorage.setItem(constants_1.LOCAL_STORAGE_KEYS.KEY_PAIR, JSON.stringify({
            publicKey: naclUtil.encodeBase64(commsKeyPair.publicKey),
            secretKey: naclUtil.encodeBase64(commsKeyPair.secretKey),
        }));
    }
    (0, misc_1.log)(`generated and saved ${constants_1.LOCAL_STORAGE_KEYS.KEY_PAIR}`);
    return authSig;
};
exports.signAndSaveAuthMessage = signAndSaveAuthMessage;
/**
 * @browserOnly
 * Sign Messags
 *
 * @param { SignMessageParams }
 *
 * @returns { Promise<SignedMessage> }
 */
const signMessage = async ({ body, web3, account, }) => {
    // check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('signMessage is not supported in nodejs.');
        return {
            signature: '',
            address: '',
        };
    }
    // -- validate
    if (!web3 || !account) {
        (0, misc_1.log)(`web3: ${web3} OR ${account} not found. Connecting web3..`);
        let res = await (0, exports.connectWeb3)({ chainId: 1 });
        web3 = res.web3;
        account = res.account;
    }
    (0, misc_1.log)('pausing...');
    await new Promise((resolve) => setTimeout(resolve, 500));
    (0, misc_1.log)('signing with ', account);
    const signature = await (0, exports.signMessageAsync)(web3.getSigner(), account, body);
    const address = (0, wallet_1.verifyMessage)(body, signature).toLowerCase();
    (0, misc_1.log)('Signature: ', signature);
    (0, misc_1.log)('recovered address: ', address);
    if (address.toLowerCase() !== account.toLowerCase()) {
        const msg = `ruh roh, the user signed with a different address (${address}) then they\'re using with web3 (${account}).  this will lead to confusion.`;
        (0, misc_1.log)(msg);
        alert('something seems to be wrong with your wallets message signing.  maybe restart your browser or your wallet.  your recovered sig address does not match your web3 account address');
        throw new Error(msg);
    }
    return { signature, address };
};
exports.signMessage = signMessage;
/**
 * @browserOnly
 * wrapper around signMessage that tries personal_sign first.  this is to fix a
 * bug with walletconnect where just using signMessage was failing
 *
 * @param { any | JsonRpcProvider} signer
 * @param { string } address
 * @param { string } message
 *
 * @returns { Promise<any | JsonRpcSigner> }
 */
const signMessageAsync = async (signer, address, message) => {
    // check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('signMessageAsync is not supported in nodejs.');
        return null;
    }
    const messageBytes = (0, strings_1.toUtf8Bytes)(message);
    if (signer instanceof providers_1.JsonRpcSigner) {
        try {
            (0, misc_1.log)('Signing with personal_sign');
            const signature = await signer.provider.send('personal_sign', [
                (0, bytes_1.hexlify)(messageBytes),
                address.toLowerCase(),
            ]);
            return signature;
        }
        catch (e) {
            (0, misc_1.log)('Signing with personal_sign failed, trying signMessage as a fallback');
            if (e.message.includes('personal_sign')) {
                return await signer.signMessage(messageBytes);
            }
            throw e;
        }
    }
    else {
        (0, misc_1.log)('signing with signMessage');
        return await signer.signMessage(messageBytes);
    }
};
exports.signMessageAsync = signMessageAsync;
/**
 *
 * Get the number of decimal places in a token
 *
 * @property { string } contractAddress The token contract address
 * @property { string } chain The chain on which the token is deployed
 *
 * @returns { number } The number of decimal places in the token
 */
// export const decimalPlaces = async ({
//     contractAddress,
//     chain,
// }: {
//     contractAddress: string;
//     chain: Chain;
// }): Promise<number> => {
//     const rpcUrl = LIT_CHAINS[chain].rpcUrls[0] as string;
//     const web3 = new JsonRpcProvider(rpcUrl);
//     const contract = new Contract(
//         contractAddress,
//         (ABI_ERC20 as any).abi,
//         web3
//     );
//     return await contract['decimals']();
// };
//# sourceMappingURL=eth.js.map