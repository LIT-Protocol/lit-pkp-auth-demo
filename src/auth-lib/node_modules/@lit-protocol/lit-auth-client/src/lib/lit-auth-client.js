"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LitAuthClient = void 0;
const constants_1 = require("@lit-protocol/constants");
const lit_node_client_1 = require("@lit-protocol/lit-node-client");
const relay_1 = require("./relay");
const GoogleProvider_1 = require("./providers/GoogleProvider");
const DiscordProvider_1 = require("./providers/DiscordProvider");
const EthWalletProvider_1 = require("./providers/EthWalletProvider");
const WebAuthnProvider_1 = require("./providers/WebAuthnProvider");
const StytchOtpProvider_1 = require("./providers/StytchOtpProvider");
const AppleProvider_1 = require("./providers/AppleProvider");
const StytchAuthFactorOtp_1 = require("./providers/StytchAuthFactorOtp");
const misc_1 = require("@lit-protocol/misc");
const ethers_1 = require("ethers");
/**
 * Class that handles authentication through Lit login
 */
class LitAuthClient {
    /**
     * Create a LitAuthClient instance
     *
     * @param {LitAuthClientOptions} options
     * @param {string} [options.rpcUrl] - Endpoint to interact with a blockchain network
     * @param {LitRelayConfig} [options.litRelayConfig] - Options for Lit's relay server
     * @param {IRelay} [options.customRelay] - Custom relay server to subsidize minting of PKPs
     * @param {LitNodeClient} [options.litNodeClient] - Client to connect to Lit nodes
     */
    constructor(options) {
        this.providers = new Map();
        (0, misc_1.bootstrapLogManager)('auth-client');
        this.debug = options?.debug ?? false;
        // Check if custom relay object is provided
        if (options?.customRelay) {
            this.relay = options?.customRelay;
        }
        else {
            // Check if configuration options for Lit Relay are provided
            if (options?.litRelayConfig?.relayApiKey) {
                this.relay = new relay_1.LitRelay(options.litRelayConfig);
            }
            else {
                throw new Error('An API key is required to use the default Lit Relay server. Please provide either an API key or a custom relay server.');
            }
        }
        // Check if Lit node client is provided
        if (options?.litNodeClient) {
            this.litNodeClient = options?.litNodeClient;
        }
        else {
            this.litNodeClient = new lit_node_client_1.LitNodeClient({
                litNetwork: 'cayenne',
                debug: options.debug ?? false,
            });
        }
        // -- choose the correct relayer based on litNodeClient
        // and if litRelayConfig.relayUrl is not set
        if (!options?.litRelayConfig?.relayUrl) {
            if (!options?.litRelayConfig?.relayApiKey) {
                throw new Error('2 An API key is required to use the default Lit Relay server. Please provide either an API key or a custom relay server.');
            }
            const supportedNetworks = ['cayenne', 'habanero', 'manzano'];
            if (!supportedNetworks.includes(this.litNodeClient.config.litNetwork)) {
                throw new Error(`Unsupported litNetwork: ${this.litNodeClient.config.litNetwork}. Supported networks are: ${supportedNetworks.join(', ')}`);
            }
            let url;
            switch (this.litNodeClient.config.litNetwork) {
                case 'cayenne':
                    url = constants_1.RELAY_URL_CAYENNE;
                    break;
                case 'habanero':
                    url = constants_1.RELAY_URL_HABANERO;
                    break;
                case 'manzano':
                    url = constants_1.RELAY_URL_MANZANO;
                    break;
            }
            if (this.litNodeClient.config.litNetwork)
                this.relay = new relay_1.LitRelay({
                    relayUrl: url,
                    relayApiKey: options?.litRelayConfig?.relayApiKey,
                });
        }
        // Set RPC URL
        this.rpcUrl = options?.rpcUrl || 'https://chain-rpc.litprotocol.com/http';
        (0, misc_1.log)('rpc url: ', this.rpcUrl);
        (0, misc_1.log)('relay config: ', options.litRelayConfig);
        (0, misc_1.log)('relay instance: ', this.relay);
    }
    /**
     * Initialize a provider
     *
     * @param {ProviderType} type - Type of provider to initialize
     * @param {ProviderOptions} options - Options for the provider
     *
     * @returns {T} - Provider
     */
    initProvider(type, options) {
        const baseParams = {
            rpcUrl: this.rpcUrl,
            relay: this.relay,
            litNodeClient: this.litNodeClient,
        };
        let provider;
        (0, misc_1.log)('resolving provider of type: ', type);
        switch (type) {
            case 'google':
                provider = new GoogleProvider_1.default({
                    ...baseParams,
                    ...options,
                });
                break;
            case 'apple':
                provider = new AppleProvider_1.default({
                    ...baseParams,
                    ...options,
                });
                break;
            case 'discord':
                provider = new DiscordProvider_1.default({
                    ...baseParams,
                    ...options,
                });
                break;
            case 'ethwallet':
                provider = new EthWalletProvider_1.default({
                    ...baseParams,
                    ...options,
                });
                break;
            case 'webauthn':
                provider = new WebAuthnProvider_1.default({
                    ...baseParams,
                    ...options,
                });
                break;
            case 'stytchOtp':
                provider = new StytchOtpProvider_1.StytchOtpProvider({
                    ...baseParams,
                }, options);
                break;
            case 'stytchEmailFactorOtp':
                provider = new StytchAuthFactorOtp_1.default({ ...baseParams }, options, 'email');
                break;
            case 'stytchSmsFactorOtp':
                provider = new StytchAuthFactorOtp_1.default({ ...baseParams }, options, 'sms');
                break;
            case 'stytchWhatsAppFactorOtp':
                provider = new StytchAuthFactorOtp_1.default({ ...baseParams }, options, 'whatsApp');
                break;
            case 'stytchTotpFactor':
                provider = new StytchAuthFactorOtp_1.default({ ...baseParams }, options, 'totp');
                break;
            default:
                throw new Error("Invalid provider type provided. Only 'google', 'discord', 'ethereum', and 'webauthn', 'Stytch', and 'StytchFactor' are supported at the moment.");
        }
        this.providers.set(type, provider);
        return provider;
    }
    /**
     * Returns an initialized provider by type
     *
     * @param {ProviderType} type - Type of provider to get
     *
     * @returns {BaseProvider | undefined} - Provider if found, undefined otherwise
     */
    getProvider(type) {
        return this.providers.get(type);
    }
    /**
     * Retrieves the authentication ID based on the provided authentication method.
     *
     * @param {AuthMethod} authMethod - The authentication method
     * @returns {Promise<string>} - The authentication ID
     */
    static async getAuthIdByAuthMethod(authMethod) {
        let authId;
        switch (authMethod.authMethodType) {
            case constants_1.AuthMethodType.EthWallet:
                authId = await EthWalletProvider_1.default.authMethodId(authMethod);
                break;
            case constants_1.AuthMethodType.Discord:
                authId = await DiscordProvider_1.default.authMethodId(authMethod);
                break;
            case constants_1.AuthMethodType.WebAuthn:
                authId = await WebAuthnProvider_1.default.authMethodId(authMethod);
                break;
            case constants_1.AuthMethodType.GoogleJwt:
                authId = await GoogleProvider_1.default.authMethodId(authMethod);
                break;
            case constants_1.AuthMethodType.StytchOtp:
                authId = await StytchOtpProvider_1.StytchOtpProvider.authMethodId(authMethod);
                break;
            case constants_1.AuthMethodType.StytchEmailFactorOtp:
            case constants_1.AuthMethodType.StytchSmsFactorOtp:
            case constants_1.AuthMethodType.StytchTotpFactorOtp:
            case constants_1.AuthMethodType.StytchWhatsAppFactorOtp:
                authId = await StytchAuthFactorOtp_1.default.authMethodId(authMethod);
                break;
            default:
                (0, misc_1.log)(`unsupported AuthMethodType: ${authMethod.authMethodType}`);
                throw new Error(`Unsupported auth method type: ${authMethod.authMethodType}`);
        }
        return authId;
    }
    /**
     * Mints a new pkp with all AuthMethods provided. Allows for permissions and flags to be set seperately.
     * If no permissions are provided then each auth method will be assigned `1` for sign anything
     * If no flags are provided then `sendPkpToitself` will be false, and `addPkpEthAddressAsPermittedAddress` will be true
     * It is then up to the implementor to transfer the pkp nft to the pkp address.
     * **note** When adding permissions, each permission should be added in the same order the auth methods are ordered
     * @throws {Error} - Throws an error if no AuthMethods are given
     * @param {AuthMethod[]} - AuthMethods authentication methods to be added to the pkp
     * @param {{ pkpPermissionScopes?: number[][]; sendPkpToitself?: boolean; addPkpEthAddressAsPermittedAddress?: boolean;}}
     * @returns {Promise<{pkpTokenId?: string; pkpEthAddress?: string; pkpPublicKey?: string}>} pkp information
     */
    async mintPKPWithAuthMethods(authMethods, options) {
        if (authMethods.length < 1) {
            throw new Error('Must provide atleast one auth method');
        }
        if (!options.pkpPermissionScopes ||
            options.pkpPermissionScopes.length < 1) {
            options.pkpPermissionScopes = [];
            for (let i = 0; i < authMethods.length; i++) {
                options.pkpPermissionScopes.push([
                    ethers_1.ethers.BigNumber.from('1').toNumber(),
                ]);
            }
        }
        const reqBody = {
            keyType: 2,
            permittedAuthMethodTypes: authMethods.map((value) => {
                return value.authMethodType;
            }),
            permittedAuthMethodScopes: options.pkpPermissionScopes,
            addPkpEthAddressAsPermittedAddress: options.addPkpEthAddressAsPermittedAddress ?? true,
            sendPkpToItself: options.sendPkpToitself ?? false,
        };
        const permittedAuthMethodIds = [];
        const permittedAuthMethodPubkeys = [];
        for (const authMethod of authMethods) {
            const id = await LitAuthClient.getAuthIdByAuthMethod(authMethod);
            permittedAuthMethodIds.push(id);
            if (authMethod.authMethodType === constants_1.AuthMethodType.WebAuthn) {
                permittedAuthMethodPubkeys.push(WebAuthnProvider_1.default.getPublicKeyFromRegistration(JSON.parse(authMethod.accessToken)));
            }
            else {
                // only webauthn has a `authMethodPubkey`
                permittedAuthMethodPubkeys.push('0x');
            }
        }
        reqBody.permittedAuthMethodIds = permittedAuthMethodIds;
        reqBody.permittedAuthMethodPubkeys = permittedAuthMethodPubkeys;
        const mintRes = await this.relay.mintPKP(JSON.stringify(reqBody));
        if (!mintRes || !mintRes.requestId) {
            throw new Error(`Missing mint response or request ID from mint response ${mintRes.error}`);
        }
        const pollerResult = await this.relay.pollRequestUntilTerminalState(mintRes.requestId);
        return {
            pkpTokenId: pollerResult.pkpTokenId,
            pkpPublicKey: pollerResult.pkpPublicKey,
            pkpEthAddress: pollerResult.pkpEthAddress,
        };
    }
}
exports.LitAuthClient = LitAuthClient;
//# sourceMappingURL=lit-auth-client.js.map