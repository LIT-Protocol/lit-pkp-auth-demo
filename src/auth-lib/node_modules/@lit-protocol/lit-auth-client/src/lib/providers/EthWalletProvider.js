"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@lit-protocol/constants");
const siwe_1 = require("siwe");
const ethers_1 = require("ethers");
const BaseProvider_1 = require("./BaseProvider");
const lit_node_client_1 = require("@lit-protocol/lit-node-client");
const misc_1 = require("@lit-protocol/misc");
class EthWalletProvider extends BaseProvider_1.BaseProvider {
    constructor(options) {
        super(options);
        try {
            this.domain = options.domain || window.location.hostname;
            this.origin = options.origin || window.location.origin;
        }
        catch (e) {
            (0, misc_1.log)('⚠️ Error getting "domain" and "origin" from window object, defaulting to "localhost" and "http://localhost"');
            this.domain = options.domain || 'localhost';
            this.origin = options.origin || 'http://localhost';
        }
    }
    /**
     * Generate a wallet signature to use as an auth method
     *
     * @param {EthWalletAuthenticateOptions} options
     * @param {string} [options.address] - Address to sign with
     * @param {function} [options.signMessage] - Function to sign message with
     * @param {string} [options.chain] - Name of chain to use for signature
     * @param {number} [options.expiration] - When the auth signature expires
     *
     * @returns {Promise<AuthMethod>} - Auth method object containing the auth signature
     */
    async authenticate(options) {
        const address = options?.address;
        const signMessage = options?.signMessage;
        const chain = options?.chain || 'ethereum';
        let authSig;
        if (address && signMessage) {
            // Get chain ID or default to Ethereum mainnet
            const selectedChain = constants_1.LIT_CHAINS[chain];
            const chainId = selectedChain?.chainId ? selectedChain.chainId : 1;
            // Get expiration or default to 24 hours
            const expiration = options?.expiration ||
                new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString();
            // Prepare Sign in with Ethereum message
            const preparedMessage = {
                domain: this.domain,
                uri: this.origin,
                address: ethers_1.ethers.utils.getAddress(address),
                version: '1',
                chainId,
                expirationTime: expiration,
                nonce: this.litNodeClient.latestBlockhash,
            };
            const message = new siwe_1.SiweMessage(preparedMessage);
            const toSign = message.prepareMessage();
            // Use provided function to sign message
            const signature = await signMessage(toSign);
            authSig = {
                sig: signature,
                derivedVia: 'web3.eth.personal.sign',
                signedMessage: toSign,
                address: address,
            };
        }
        else {
            if (!this.litNodeClient.latestBlockhash) {
                (0, misc_1.throwError)({
                    message: 'Eth Blockhash is undefined. Try connecting to the Lit network again.',
                    errorKind: constants_1.LIT_ERROR.INVALID_ETH_BLOCKHASH.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ETH_BLOCKHASH.name,
                });
            }
            authSig = await (0, lit_node_client_1.checkAndSignAuthMessage)({
                chain,
                nonce: this.litNodeClient.latestBlockhash,
            });
        }
        const authMethod = {
            authMethodType: constants_1.AuthMethodType.EthWallet,
            accessToken: JSON.stringify(authSig),
        };
        return authMethod;
    }
    /**
     * Get auth method id that can be used to look up and interact with
     * PKPs associated with the given auth method
     *
     * @param {AuthMethod} authMethod - Auth method object
     *
     * @returns {Promise<string>} - Auth method id
     */
    async getAuthMethodId(authMethod) {
        return EthWalletProvider.authMethodId(authMethod);
    }
    static async authMethodId(authMethod) {
        let address;
        try {
            address = JSON.parse(authMethod.accessToken).address;
        }
        catch (err) {
            throw new Error(`Error when parsing auth method to generate auth method ID for Eth wallet: ${err}`);
        }
        return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${address}:lit`));
    }
}
exports.default = EthWalletProvider;
//# sourceMappingURL=EthWalletProvider.js.map