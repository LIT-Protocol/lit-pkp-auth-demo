import { IRelay, LitAuthClientOptions, ProviderOptions, AuthMethod } from '@lit-protocol/types';
import { ProviderType } from '@lit-protocol/constants';
import { LitNodeClient } from '@lit-protocol/lit-node-client';
import { BaseProvider } from './providers/BaseProvider';
/**
 * Class that handles authentication through Lit login
 */
export declare class LitAuthClient {
    /**
     * The redirect URI that Lit's auth server should send the user back to
     */
    rpcUrl: string;
    /**
     * Relay server to subsidize minting of PKPs
     */
    relay: IRelay;
    /**
     * Client to connect to Lit nodes
     */
    litNodeClient: LitNodeClient;
    /**
     * Map of providers
     */
    private providers;
    /**
     * Configures logging
     */
    private debug;
    /**
     * Create a LitAuthClient instance
     *
     * @param {LitAuthClientOptions} options
     * @param {string} [options.rpcUrl] - Endpoint to interact with a blockchain network
     * @param {LitRelayConfig} [options.litRelayConfig] - Options for Lit's relay server
     * @param {IRelay} [options.customRelay] - Custom relay server to subsidize minting of PKPs
     * @param {LitNodeClient} [options.litNodeClient] - Client to connect to Lit nodes
     */
    constructor(options?: LitAuthClientOptions);
    /**
     * Initialize a provider
     *
     * @param {ProviderType} type - Type of provider to initialize
     * @param {ProviderOptions} options - Options for the provider
     *
     * @returns {T} - Provider
     */
    initProvider<T extends BaseProvider>(type: ProviderType, options?: ProviderOptions): T;
    /**
     * Returns an initialized provider by type
     *
     * @param {ProviderType} type - Type of provider to get
     *
     * @returns {BaseProvider | undefined} - Provider if found, undefined otherwise
     */
    getProvider(type: ProviderType): BaseProvider | undefined;
    /**
     * Retrieves the authentication ID based on the provided authentication method.
     *
     * @param {AuthMethod} authMethod - The authentication method
     * @returns {Promise<string>} - The authentication ID
     */
    static getAuthIdByAuthMethod(authMethod: AuthMethod): Promise<string>;
    /**
     * Mints a new pkp with all AuthMethods provided. Allows for permissions and flags to be set seperately.
     * If no permissions are provided then each auth method will be assigned `1` for sign anything
     * If no flags are provided then `sendPkpToitself` will be false, and `addPkpEthAddressAsPermittedAddress` will be true
     * It is then up to the implementor to transfer the pkp nft to the pkp address.
     * **note** When adding permissions, each permission should be added in the same order the auth methods are ordered
     * @throws {Error} - Throws an error if no AuthMethods are given
     * @param {AuthMethod[]} - AuthMethods authentication methods to be added to the pkp
     * @param {{ pkpPermissionScopes?: number[][]; sendPkpToitself?: boolean; addPkpEthAddressAsPermittedAddress?: boolean;}}
     * @returns {Promise<{pkpTokenId?: string; pkpEthAddress?: string; pkpPublicKey?: string}>} pkp information
     */
    mintPKPWithAuthMethods(authMethods: AuthMethod[], options: {
        pkpPermissionScopes?: number[][];
        sendPkpToitself?: boolean;
        addPkpEthAddressAsPermittedAddress?: boolean;
    }): Promise<{
        pkpTokenId?: string;
        pkpEthAddress?: string;
        pkpPublicKey?: string;
    }>;
}
