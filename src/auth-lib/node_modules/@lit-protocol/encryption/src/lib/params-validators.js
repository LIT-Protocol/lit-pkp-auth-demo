"use strict";
/**
 * Param Validators is an abstraction of validating params of a function, each validator
 * returns a boolean value indicating whether the validation is passed or not.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.paramsValidators = exports.safeParams = void 0;
const constants_1 = require("@lit-protocol/constants");
const misc_1 = require("@lit-protocol/misc");
const utils_1 = require("ethers/lib/utils");
const utils_2 = require("./utils");
const safeParams = ({ functionName, params, }) => {
    if (!exports.paramsValidators[functionName]) {
        (0, misc_1.log)(`This function ${functionName} is skipping params safe guarding.`);
        return (0, constants_1.ERight)(undefined);
    }
    const paramValidators = exports.paramsValidators[functionName](params);
    for (const validator of paramValidators) {
        const validationResponse = validator.validate();
        if (validationResponse.type === "ERROR" /* EITHER_TYPE.ERROR */) {
            return validationResponse;
        }
    }
    return (0, constants_1.ERight)(undefined);
};
exports.safeParams = safeParams;
exports.paramsValidators = {
    executeJs: (params) => [
        new AuthMaterialValidator('executeJs', params),
        new ExecuteJsValidator('executeJs', params),
        new AuthMethodValidator('executeJs', params.authMethods),
    ],
    encrypt: (params) => [
        new AccessControlConditionsValidator('encrypt', params),
        new AuthMaterialValidator('encrypt', params, true),
    ],
    encryptFile: (params) => [
        new AccessControlConditionsValidator('encryptFile', params),
        new AuthMaterialValidator('encryptFile', params),
        new FileValidator('encryptFile', params.file),
    ],
    encryptString: (params) => [
        new AccessControlConditionsValidator('encryptString', params),
        new AuthMaterialValidator('encryptString', params, true),
        new StringValidator('encryptString', params.dataToEncrypt, 'dataToEncrypt'),
    ],
    encryptZip: (params) => [
        new AccessControlConditionsValidator('encryptZip', params),
        new AuthMaterialValidator('encryptZip', params),
    ],
    zipAndEncryptString: (params) => [
        new StringValidator('zipAndEncryptString', params.dataToEncrypt),
    ],
    decrypt: (params) => [
        new AccessControlConditionsValidator('decrypt', params),
        new AuthMaterialValidator('decrypt', params, true),
        new StringValidator('decrypt', params.ciphertext, 'ciphertext'),
    ],
    decryptZipFileWithMetadata: (params) => [
        new AuthMaterialValidator('decryptZipFileWithMetadata', params),
        new FileValidator('decryptZipFileWithMetadata', params.file),
    ],
    decryptToZip: (params) => [
        new FileValidator('decryptToZip', params.encryptedZipBlob),
    ],
    encryptToIpfs: (params) => [
        new AccessControlConditionsValidator('encryptToIpfs', params),
        new AuthMaterialValidator('encryptToIpfs', params, true),
        new IpfsValidator('encryptToIpfs', params),
    ],
    decryptFromIpfs: (params) => [
        new AuthMaterialValidator('decryptFromIpfs', params),
    ],
    encryptFileAndZipWithMetadata: (params) => [
        new AuthMaterialValidator('encryptFileAndZipWithMetadata', params, true),
        new AccessControlConditionsValidator('encryptFileAndZipWithMetadata', params),
        new FileValidator('encryptFileAndZipWithMetadata', params.file),
        new StringValidator('encryptFileAndZipWithMetadata', params.readme, 'readme'),
    ],
    getSignedToken: (params) => [
        new AccessControlConditionsValidator('decrypt', params),
        new AuthMaterialValidator('decrypt', params, true),
    ],
};
class IpfsValidator {
    constructor(fnName, params) {
        this.fnName = fnName;
        this.params = params;
    }
    validate() {
        const validators = [
            new FileValidator(this.fnName, this.params.file),
            new StringValidator(this.fnName, this.params.string),
        ];
        for (const validator of validators) {
            const validationResponse = validator.validate();
            if (validationResponse.type === "ERROR" /* EITHER_TYPE.ERROR */) {
                return validationResponse;
            }
        }
        const { file, string, infuraId, infuraSecretKey } = this.params;
        if (string === undefined && file === undefined)
            return (0, constants_1.ELeft)({
                message: `Either string or file must be provided`,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        if (!infuraId || !infuraSecretKey)
            return (0, constants_1.ELeft)({
                message: 'Please provide your Infura Project Id and Infura API Key Secret to add the encrypted metadata on IPFS',
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        if (string !== undefined && file !== undefined)
            return (0, constants_1.ELeft)({
                message: 'Provide only either a string or file to encrypt',
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        return (0, constants_1.ERight)(undefined);
    }
}
class StringValidator {
    constructor(fnName, str, paramName = 'string', checkIsHex = false) {
        this.fnName = fnName;
        this.paramName = paramName;
        this.checkIsHex = checkIsHex;
        this.str = str;
    }
    validate() {
        if (!this.str) {
            return (0, constants_1.ELeft)({
                message: 'string is undefined',
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        }
        if (!(0, misc_1.checkType)({
            value: this.str,
            allowedTypes: ['String'],
            paramName: this.paramName,
            functionName: this.fnName,
        }))
            return (0, constants_1.ELeft)({
                message: `${this.paramName} is not a string`,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        if (this.checkIsHex && !(0, utils_1.isHexString)(this.str)) {
            return (0, constants_1.ELeft)({
                message: `${this.paramName} is not a valid hex string`,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        }
        return (0, constants_1.ERight)(undefined);
    }
}
class AuthMethodValidator {
    constructor(fnName, authMethods) {
        this.fnName = fnName;
        this.authMethods = authMethods;
    }
    validate() {
        const { fnName, authMethods } = this;
        if (authMethods &&
            authMethods.length > 0 &&
            !(0, misc_1.checkType)({
                value: authMethods,
                allowedTypes: ['Array'],
                paramName: 'authMethods',
                functionName: this.fnName,
            }))
            return (0, constants_1.ELeft)({
                message: `authMethods is not an array`,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        return (0, constants_1.ERight)(undefined);
    }
}
class ExecuteJsValidator {
    constructor(fnName, params) {
        this.fnName = fnName;
        this.params = params;
    }
    validate() {
        const { code, ipfsId } = this.params;
        // -- validate: either 'code' or 'ipfsId' must exists
        if (!code && !ipfsId) {
            return (0, constants_1.ELeft)({
                message: 'You must pass either code or ipfsId',
                errorKind: constants_1.LIT_ERROR.PARAMS_MISSING_ERROR.kind,
                errorCode: constants_1.LIT_ERROR.PARAMS_MISSING_ERROR.name,
            });
        }
        // -- validate: 'code' and 'ipfsId' can't exists at the same time
        if (code && ipfsId) {
            return (0, constants_1.ELeft)({
                message: "You cannot have both 'code' and 'ipfs' at the same time",
                errorKind: constants_1.LIT_ERROR.PARAMS_MISSING_ERROR.kind,
                errorCode: constants_1.LIT_ERROR.PARAMS_MISSING_ERROR.name,
            });
        }
        return (0, constants_1.ERight)(undefined);
    }
}
class FileValidator {
    constructor(fnName, file) {
        this.fnName = fnName;
        this.file = file;
    }
    validate() {
        if (!this.file) {
            return (0, constants_1.ELeft)({
                message: 'You must pass file param',
                errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
            });
        }
        if (!(0, misc_1.checkType)({
            value: this.file,
            allowedTypes: ['Blob', 'File', 'Uint8Array'],
            paramName: 'file',
            functionName: this.fnName,
        }))
            return (0, constants_1.ELeft)({
                message: 'File param is not a valid Blob or File object',
                errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
            });
        return (0, constants_1.ERight)(undefined);
    }
}
class AuthMaterialValidator {
    constructor(fnName, params, checkIfAuthSigRequiresChainParam = false) {
        this.fnName = fnName;
        this.authMaterial = params;
        this.checkIfAuthSigRequiresChainParam = checkIfAuthSigRequiresChainParam;
    }
    validate() {
        const { authSig, sessionSigs } = this.authMaterial;
        if (authSig && !(0, misc_1.is)(authSig, 'Object', 'authSig', this.fnName))
            return (0, constants_1.ELeft)({
                message: 'authSig is not an object',
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        if (this.checkIfAuthSigRequiresChainParam) {
            if (!this.authMaterial.chain)
                return (0, constants_1.ELeft)({
                    message: 'You must pass chain param',
                    errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
                });
            if (authSig &&
                !(0, misc_1.checkIfAuthSigRequiresChainParam)(authSig, this.authMaterial.chain, this.fnName))
                return (0, constants_1.ELeft)({
                    message: 'authSig is not valid',
                    errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                    errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
                });
        }
        if (sessionSigs && !(0, misc_1.is)(sessionSigs, 'Object', 'sessionSigs', this.fnName))
            return (0, constants_1.ELeft)({
                message: 'sessionSigs is not an object',
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        if (!sessionSigs && !authSig)
            return (0, constants_1.ELeft)({
                message: 'You must pass either authSig or sessionSigs',
                errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
            });
        // -- validate: if sessionSig and authSig exists
        if (sessionSigs && authSig)
            return (0, constants_1.ELeft)({
                message: 'You cannot have both authSig and sessionSigs',
                errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
            });
        return (0, constants_1.ERight)(undefined);
    }
}
class AccessControlConditionsValidator {
    constructor(fnName, params) {
        this.fnName = fnName;
        this.conditions = params;
    }
    validate() {
        const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, } = this.conditions;
        if (accessControlConditions &&
            !(0, misc_1.is)(accessControlConditions, 'Array', 'accessControlConditions', this.fnName))
            return (0, constants_1.ELeft)({
                message: 'accessControlConditions is not an array',
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        if (evmContractConditions &&
            !(0, misc_1.is)(evmContractConditions, 'Array', 'evmContractConditions', this.fnName))
            return (0, constants_1.ELeft)({
                message: 'evmContractConditions is not an array',
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        if (solRpcConditions &&
            !(0, misc_1.is)(solRpcConditions, 'Array', 'solRpcConditions', this.fnName))
            return (0, constants_1.ELeft)({
                message: 'solRpcConditions is not an array',
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        if (unifiedAccessControlConditions &&
            !(0, misc_1.is)(unifiedAccessControlConditions, 'Array', 'unifiedAccessControlConditions', this.fnName))
            return (0, constants_1.ELeft)({
                message: 'unifiedAccessControlConditions is not an array',
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        if (!accessControlConditions &&
            !evmContractConditions &&
            !solRpcConditions &&
            !unifiedAccessControlConditions)
            return (0, constants_1.ELeft)({
                message: 'You must pass either accessControlConditions, evmContractConditions, solRpcConditions or unifiedAccessControlConditions',
                errorKind: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION.name,
            });
        if (accessControlConditions &&
            !(0, utils_2.isValidBooleanExpression)(accessControlConditions))
            return (0, constants_1.ELeft)({
                message: 'Invalid boolean Access Control Conditions',
                errorKind: constants_1.LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.name,
            });
        if (evmContractConditions &&
            !(0, utils_2.isValidBooleanExpression)(evmContractConditions))
            return (0, constants_1.ELeft)({
                message: 'Invalid boolean EVM Access Control Conditions',
                errorKind: constants_1.LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.name,
            });
        if (solRpcConditions && !(0, utils_2.isValidBooleanExpression)(solRpcConditions))
            return (0, constants_1.ELeft)({
                message: 'Invalid boolean Solana Access Control Conditions',
                errorKind: constants_1.LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.name,
            });
        if (unifiedAccessControlConditions &&
            !(0, utils_2.isValidBooleanExpression)(unifiedAccessControlConditions))
            return (0, constants_1.ELeft)({
                message: 'Invalid boolean Unified Access Control Conditions',
                errorKind: constants_1.LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_BOOLEAN_EXCEPTION.name,
            });
        return (0, constants_1.ERight)(undefined);
    }
}
//# sourceMappingURL=params-validators.js.map