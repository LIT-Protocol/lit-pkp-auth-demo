import { ILitError } from '@lit-protocol/constants';
import { Chain, AuthSig, NodeClientErrorV0, NodeClientErrorV1, MintCallback, RelayClaimProcessor, RejectedNodePromises, RetryTolerance } from '@lit-protocol/types';
import { LogLevel } from '@lit-protocol/logger';
import { JSONSchemaType } from 'ajv';
/**
 *
 * Print error message based on Error interface
 *
 * @param { Error } e
 * @returns { void }
 */
export declare const printError: (e: Error) => void;
/**
 *
 * Find the element that occurs the most in an array
 *
 * @param { Array<any> } arr
 * @returns { any } the element that appeared the most
 */
export declare const mostCommonString: (arr: Array<any>) => any;
export declare const throwError: (e: NodeClientErrorV0 | NodeClientErrorV1) => never;
/**
 *
 * Standardized way to throw error in Lit Protocol projects
 *
 * @deprecated use throwErrorV1
 * @param { ILitError }
 * @property { string } message
 * @property { string } name
 * @property { string } errorCode
 */
export declare const throwErrorV0: ({ message, name, errorCode, error, }: ILitError) => never;
/**
 *
 * Standardized way to throw error in Lit Protocol projects
 *
 */
export declare const throwErrorV1: ({ errorKind, details, status, message, errorCode, requestId, }: NodeClientErrorV1) => never;
export declare const throwGenericError: (e: any) => never;
export declare const isNodeClientErrorV1: (nodeError: NodeClientErrorV0 | NodeClientErrorV1) => nodeError is NodeClientErrorV1;
export declare const isNodeClientErrorV0: (nodeError: NodeClientErrorV0 | NodeClientErrorV1) => nodeError is NodeClientErrorV0;
declare global {
    var litConfig: any;
    var wasmExport: any;
    var wasmECDSA: any;
    var logger: any;
    var logManager: any;
}
export declare const throwRemovedFunctionError: (functionName: string) => void;
export declare const bootstrapLogManager: (id: string, level?: LogLevel) => void;
export declare const getLoggerbyId: (id: string) => any;
/**
 *
 * console.log but prepend [Lit-JS-SDK] before the message
 *
 * @param { any } args
 *
 * @returns { void }
 */
export declare const log: (...args: any) => void;
export declare const logWithRequestId: (id: string, ...args: any) => void;
export declare const logErrorWithRequestId: (id: string, ...args: any) => void;
export declare const logError: (...args: any) => void;
/**
 *
 * Get the type of a variable, could be an object instance type.
 * eg Uint8Array instance should return 'Uint8Array` as string
 * or simply a `string` or `int` type
 *
 * @param { any } value
 * @returns { string } type
 */
export declare const getVarType: (value: any) => string;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @property { any } value
 * @property { Array<String> } allowedTypes
 * @property { string } paramName
 * @property { string } functionName
 * @property { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 *
 */
export declare const checkType: ({ value, allowedTypes, paramName, functionName, throwOnError, }: {
    value: any;
    allowedTypes: Array<string> | any;
    paramName: string;
    functionName: string;
    throwOnError?: boolean | undefined;
}) => boolean;
/**
 * Check if the given value complies with the given schema
 * If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { JSONSchemaType<any> } schema
 * @param { string } paramName
 * @param { string } functionName
 * @param { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 */
export declare const checkSchema: (value: any, schema: JSONSchemaType<any>, paramName: string, functionName: string, throwOnError?: boolean) => boolean;
/**
 *
 * @param { AuthSig } authSig
 * @param { string } chain
 * @param { string } functionName
 *
 * @returns { boolean }
 */
export declare const checkIfAuthSigRequiresChainParam: (authSig: AuthSig, chain: string, functionName: string) => boolean;
/**
 * TODO: Fix "any"
 * Sort object
 *
 * @param { any } obj
 * @returns { any }
 */
export declare const sortedObject: (obj: any) => any;
/**
 *
 * Convert number to hex
 * @param { number } v
 * @return { string } hex value prexied with 0x
 */
export declare const numberToHex: (v: number) => string;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { string } type
 * @param { string } paramName
 * @param { string } functionName
 * @returns { Boolean } true/false
 */
export declare const is: (value: any, type: string, paramName: string, functionName: string, throwOnError?: boolean) => boolean;
/**
 * Convert types before sending to Lit Actions as jsParams, some JS types don't serialize well, so we will convert them before sending to the nodes
 *
 * @param { object } params.jsParams The jsParams you are sending
 * @returns { object } The jsParams object, but with any incompatible types automatically converted
 */
export declare const convertLitActionsParams: (jsParams: object) => object;
export declare const isNode: () => boolean;
export declare const isBrowser: () => boolean;
/**
 *
 * Get the number of decimal places in a token
 *
 * @property { string } contractAddress The token contract address
 * @property { string } chain The chain on which the token is deployed
 *
 * @returns { number } The number of decimal places in the token
 */
export declare const decimalPlaces: ({ contractAddress, chain, }: {
    contractAddress: string;
    chain: Chain;
}) => Promise<number>;
/**
 *
 * Generate a random path (for testing)
 *
 * @returns { string } The random path
 */
export declare const genRandomPath: () => string;
export declare const defaultMintClaimCallback: MintCallback<RelayClaimProcessor>;
export declare const hexPrefixed: (str: string) => string;
/**
 * getEnv - Determine the debug status based on environment variables or URL query parameters.
 *
 * @function
 * @export
 * @param {Object} [options={}] - Configuration options for determining debug status.
 * @param {string} [options.nodeEnvVar='DEBUG'] - The Node.js environment variable to check.
 * @param {string} [options.urlQueryParam='dev'] - The URL query parameter to check in a browser environment.
 * @param {string} [options.urlQueryValue='debug=true'] - The expected value of the URL query parameter to enable debugging.
 * @param {boolean} [options.defaultValue=false] - The default boolean value to return if no debug conditions are met.
 * @returns {boolean} - True if debug conditions are met, otherwise returns the provided defaultValue.
 *
 * @example
 * // Usage in Node.js environment
 * process.env.DEBUG = 'true';
 * console.log(getEnv()); // Outputs: true
 *
 * @example
 * // Usage in Browser environment with URL: http://example.com?dev=debug=true
 * console.log(getEnv()); // Outputs: true
 */
export declare function getEnv({ nodeEnvVar, urlQueryParam, urlQueryValue, defaultValue, }?: {
    nodeEnvVar?: string | undefined;
    urlQueryParam?: string | undefined;
    urlQueryValue?: string | undefined;
    defaultValue?: boolean | undefined;
}): boolean;
export declare function sendRequest(url: string, req: RequestInit, requestId: string): Promise<Response>;
/**
 * Allows for invoking a callback and re exucting while re generating a new request identifier
 * @param execCallback
 * @param errorCallback
 * @param opts
 * @returns {T}
 */
export declare function executeWithRetry<T>(execCallback: (requestId: string) => Promise<T>, errorCallback?: (error: any, requestId: string, isFinal: boolean) => void, opts?: RetryTolerance): Promise<(T & {
    requestId: string;
}) | (RejectedNodePromises & {
    requestId: string;
})>;
