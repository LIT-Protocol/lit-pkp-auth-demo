"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeWithRetry = exports.sendRequest = exports.getEnv = exports.hexPrefixed = exports.defaultMintClaimCallback = exports.genRandomPath = exports.decimalPlaces = exports.isBrowser = exports.isNode = exports.convertLitActionsParams = exports.is = exports.numberToHex = exports.sortedObject = exports.checkIfAuthSigRequiresChainParam = exports.checkSchema = exports.checkType = exports.getVarType = exports.logError = exports.logErrorWithRequestId = exports.logWithRequestId = exports.log = exports.getLoggerbyId = exports.bootstrapLogManager = exports.throwRemovedFunctionError = exports.isNodeClientErrorV0 = exports.isNodeClientErrorV1 = exports.throwGenericError = exports.throwErrorV1 = exports.throwErrorV0 = exports.throwError = exports.mostCommonString = exports.printError = void 0;
const constants_1 = require("@lit-protocol/constants");
const providers_1 = require("@ethersproject/providers");
const contracts_1 = require("@ethersproject/contracts");
const logger_1 = require("@lit-protocol/logger");
const ajv_1 = require("ajv");
const logBuffer = [];
const ajv = new ajv_1.default();
/**
 *
 * Print error message based on Error interface
 *
 * @param { Error } e
 * @returns { void }
 */
const printError = (e) => {
    console.log('Error Stack', e.stack);
    console.log('Error Name', e.name);
    console.log('Error Message', e.message);
};
exports.printError = printError;
/**
 *
 * Find the element that occurs the most in an array
 *
 * @param { Array<any> } arr
 * @returns { any } the element that appeared the most
 */
const mostCommonString = (arr) => {
    return arr
        .sort((a, b) => arr.filter((v) => v === a).length -
        arr.filter((v) => v === b).length)
        .pop();
};
exports.mostCommonString = mostCommonString;
const throwError = (e) => {
    if ((0, exports.isNodeClientErrorV1)(e)) {
        return (0, exports.throwErrorV1)(e);
    }
    else if ((0, exports.isNodeClientErrorV0)(e)) {
        return (0, exports.throwErrorV0)(e);
    }
    return (0, exports.throwGenericError)(e);
};
exports.throwError = throwError;
/**
 *
 * Standardized way to throw error in Lit Protocol projects
 *
 * @deprecated use throwErrorV1
 * @param { ILitError }
 * @property { string } message
 * @property { string } name
 * @property { string } errorCode
 */
const throwErrorV0 = ({ message, name, errorCode, error, }) => {
    const errConstructorFunc = function (message, name, errorCode) {
        this.message = message;
        this.name = name;
        // Map old error codes to new ones if possible.
        this.errorCode = oldErrorToNewErrorMap[errorCode] ?? errorCode;
    };
    throw new errConstructorFunc(message, (name = error?.name ?? name), (errorCode = error?.code ?? errorCode));
};
exports.throwErrorV0 = throwErrorV0;
// Map for old error codes to new ones
const oldErrorToNewErrorMap = {
    not_authorized: 'NodeNotAuthorized',
    storage_error: 'NodeStorageError',
};
/**
 *
 * Standardized way to throw error in Lit Protocol projects
 *
 */
const throwErrorV1 = ({ errorKind, details, status, message, errorCode, requestId, }) => {
    const errConstructorFunc = function (errorKind, status, details, message, errorCode, requestId) {
        this.message = message;
        this.errorCode = errorCode;
        this.errorKind = errorKind;
        this.status = status;
        this.details = details;
        this.requestId = requestId;
    };
    throw new errConstructorFunc(errorKind, status, details, message, errorCode, requestId);
};
exports.throwErrorV1 = throwErrorV1;
const throwGenericError = (e) => {
    const errConstructorFunc = function (message) {
        this.message = message;
        this.errorKind = constants_1.LIT_ERROR.UNKNOWN_ERROR.name;
        this.errorCode = constants_1.LIT_ERROR.UNKNOWN_ERROR.code;
    };
    throw new errConstructorFunc(e.message ?? 'Generic Error');
};
exports.throwGenericError = throwGenericError;
const isNodeClientErrorV1 = (nodeError) => {
    return (nodeError.hasOwnProperty('errorCode') &&
        nodeError.hasOwnProperty('errorKind'));
};
exports.isNodeClientErrorV1 = isNodeClientErrorV1;
const isNodeClientErrorV0 = (nodeError) => {
    return nodeError.hasOwnProperty('errorCode');
};
exports.isNodeClientErrorV0 = isNodeClientErrorV0;
const throwRemovedFunctionError = (functionName) => {
    (0, exports.throwError)({
        message: `This function "${functionName}" has been removed. Please use the old SDK.`,
        errorKind: constants_1.LIT_ERROR.REMOVED_FUNCTION_ERROR.kind,
        errorCode: constants_1.LIT_ERROR.REMOVED_FUNCTION_ERROR.name,
    });
};
exports.throwRemovedFunctionError = throwRemovedFunctionError;
const bootstrapLogManager = (id, level = logger_1.LogLevel.DEBUG) => {
    if (!globalThis.logManager) {
        globalThis.logManager = logger_1.LogManager.Instance;
        globalThis.logManager.withConfig({
            condenseLogs: true,
        });
        globalThis.logManager.setLevel(level);
    }
    globalThis.logger = globalThis.logManager.get(id);
};
exports.bootstrapLogManager = bootstrapLogManager;
const getLoggerbyId = (id) => {
    return globalThis.logManager.get(id);
};
exports.getLoggerbyId = getLoggerbyId;
/**
 *
 * console.log but prepend [Lit-JS-SDK] before the message
 *
 * @param { any } args
 *
 * @returns { void }
 */
const log = (...args) => {
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!globalThis?.litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    if (globalThis?.litConfig?.debug !== true) {
        return;
    }
    // config is loaded, and debug is true
    // if there are there are logs in buffer, print them first and empty the buffer.
    while (logBuffer.length > 0) {
        const log = logBuffer.shift() ?? '';
        globalThis?.logger && globalThis?.logger.debug(...log);
    }
    globalThis?.logger && globalThis?.logger.debug(...args);
};
exports.log = log;
const logWithRequestId = (id, ...args) => {
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!globalThis?.litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    if (globalThis?.litConfig?.debug !== true) {
        return;
    }
    // config is loaded, and debug is true
    // if there are there are logs in buffer, print them first and empty the buffer.
    while (logBuffer.length > 0) {
        const log = logBuffer.shift() ?? '';
        globalThis?.logger &&
            globalThis.logManager.get(globalThis.logger.category, id).debug(...log);
    }
    globalThis?.logger &&
        globalThis.logManager.get(globalThis.logger.category, id).debug(...args);
};
exports.logWithRequestId = logWithRequestId;
const logErrorWithRequestId = (id, ...args) => {
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!globalThis?.litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    if (globalThis?.litConfig?.debug !== true) {
        return;
    }
    // config is loaded, and debug is true
    // if there are there are logs in buffer, print them first and empty the buffer.
    while (logBuffer.length > 0) {
        const log = logBuffer.shift() ?? '';
        globalThis?.logger &&
            globalThis.logManager.get(globalThis.logger.category, id).error(...log);
    }
    globalThis?.logger &&
        globalThis.logManager.get(globalThis.logger.category, id).error(...args);
};
exports.logErrorWithRequestId = logErrorWithRequestId;
const logError = (...args) => {
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!globalThis?.litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    if (globalThis?.litConfig?.debug !== true) {
        return;
    }
    // config is loaded, and debug is true
    // if there are there are logs in buffer, print them first and empty the buffer.
    while (logBuffer.length > 0) {
        const log = logBuffer.shift() ?? '';
        globalThis?.logger &&
            globalThis.logManager.get(globalThis.logger.category).error(...log);
    }
    globalThis?.logger &&
        globalThis.logManager.get(globalThis.logger.category).error(...args);
};
exports.logError = logError;
/**
 *
 * Get the type of a variable, could be an object instance type.
 * eg Uint8Array instance should return 'Uint8Array` as string
 * or simply a `string` or `int` type
 *
 * @param { any } value
 * @returns { string } type
 */
const getVarType = (value) => {
    return Object.prototype.toString.call(value).slice(8, -1);
};
exports.getVarType = getVarType;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @property { any } value
 * @property { Array<String> } allowedTypes
 * @property { string } paramName
 * @property { string } functionName
 * @property { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 *
 */
const checkType = ({ value, allowedTypes, paramName, functionName, throwOnError = true, }) => {
    // -- validate
    if (!allowedTypes.includes((0, exports.getVarType)(value))) {
        const message = `Expecting ${allowedTypes.join(' or ')} type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${(0, exports.getVarType)(value)}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
        if (throwOnError) {
            (0, exports.throwError)({
                message,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        }
        return false;
    }
    // -- else
    return true;
};
exports.checkType = checkType;
/**
 * Check if the given value complies with the given schema
 * If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { JSONSchemaType<any> } schema
 * @param { string } paramName
 * @param { string } functionName
 * @param { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 */
const checkSchema = (value, schema, paramName, functionName, throwOnError = true) => {
    let validate = schema.$id ? ajv.getSchema(schema.$id) : undefined;
    if (!validate) {
        validate = ajv.compile(schema);
    }
    const validates = validate(value);
    const message = `FAILED schema validation for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(). Value: ${value instanceof Object ? JSON.stringify(value) : value}. Errors: ${JSON.stringify(validate.errors)}`;
    if (!validates) {
        if (throwOnError) {
            (0, exports.throwError)({
                message,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        }
        return false;
    }
    return true;
};
exports.checkSchema = checkSchema;
/**
 *
 * @param { AuthSig } authSig
 * @param { string } chain
 * @param { string } functionName
 *
 * @returns { boolean }
 */
const checkIfAuthSigRequiresChainParam = (authSig, chain, functionName) => {
    (0, exports.log)('checkIfAuthSigRequiresChainParam');
    for (const key of constants_1.LIT_AUTH_SIG_CHAIN_KEYS) {
        if (key in authSig) {
            return true;
        }
    }
    // if we're here, then we need the chain param
    if (!(0, exports.checkType)({
        value: chain,
        allowedTypes: ['String'],
        paramName: 'chain',
        functionName,
    })) {
        return false;
    }
    return true;
};
exports.checkIfAuthSigRequiresChainParam = checkIfAuthSigRequiresChainParam;
/**
 * TODO: Fix "any"
 * Sort object
 *
 * @param { any } obj
 * @returns { any }
 */
const sortedObject = (obj) => {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(exports.sortedObject);
    }
    const sortedKeys = Object.keys(obj).sort();
    const result = {};
    // NOTE: Use forEach instead of reduce for performance with large objects eg Wasm code
    sortedKeys.forEach((key) => {
        result[key] = (0, exports.sortedObject)(obj[key]);
    });
    return result;
};
exports.sortedObject = sortedObject;
/**
 *
 * Convert number to hex
 * @param { number } v
 * @return { string } hex value prexied with 0x
 */
const numberToHex = (v) => {
    return '0x' + v.toString(16);
};
exports.numberToHex = numberToHex;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { string } type
 * @param { string } paramName
 * @param { string } functionName
 * @returns { Boolean } true/false
 */
const is = (value, type, paramName, functionName, throwOnError = true) => {
    if ((0, exports.getVarType)(value) !== type) {
        let message = `Expecting "${type}" type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${(0, exports.getVarType)(value)}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
        if (throwOnError) {
            (0, exports.throwError)({
                message,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        }
        return false;
    }
    return true;
};
exports.is = is;
/**
 * Convert types before sending to Lit Actions as jsParams, some JS types don't serialize well, so we will convert them before sending to the nodes
 *
 * @param { object } params.jsParams The jsParams you are sending
 * @returns { object } The jsParams object, but with any incompatible types automatically converted
 */
const convertLitActionsParams = (jsParams) => {
    // -- property
    const convertedParams = {};
    // -- execute
    for (const [key, value] of Object.entries(jsParams)) {
        const _key = key;
        const _value = value;
        // -- get value type
        const varType = (0, exports.getVarType)(_value);
        // -- case: Unit8Array
        if (varType === 'Uint8Array') {
            convertedParams[_key] = Array.from(_value);
            // -- case: Object, recurse over any objects
        }
        else if (varType === 'Object') {
            convertedParams[_key] = (0, exports.convertLitActionsParams)(_value);
        }
        // -- default
        else {
            convertedParams[_key] = _value;
        }
    }
    return convertedParams;
};
exports.convertLitActionsParams = convertLitActionsParams;
const isNode = () => {
    var isNode = false;
    // @ts-ignore
    if (typeof process === 'object') {
        // @ts-ignore
        if (typeof process.versions === 'object') {
            // @ts-ignore
            if (typeof process.versions.node !== 'undefined') {
                isNode = true;
            }
        }
    }
    return isNode;
};
exports.isNode = isNode;
const isBrowser = () => {
    return (0, exports.isNode)() === false;
};
exports.isBrowser = isBrowser;
/**
 *
 * Get the number of decimal places in a token
 *
 * @property { string } contractAddress The token contract address
 * @property { string } chain The chain on which the token is deployed
 *
 * @returns { number } The number of decimal places in the token
 */
const decimalPlaces = async ({ contractAddress, chain, }) => {
    const rpcUrl = constants_1.LIT_CHAINS[chain].rpcUrls[0];
    const web3 = new providers_1.JsonRpcProvider(rpcUrl);
    const contract = new contracts_1.Contract(contractAddress, constants_1.ABI_ERC20.abi, web3);
    return await contract['decimals']();
};
exports.decimalPlaces = decimalPlaces;
/**
 *
 * Generate a random path (for testing)
 *
 * @returns { string } The random path
 */
const genRandomPath = () => {
    return ('/' +
        Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15));
};
exports.genRandomPath = genRandomPath;
const defaultMintClaimCallback = async (params, network = 'cayenne') => {
    try {
        let relayUrl = '';
        switch (network) {
            case constants_1.LitNetwork.Cayenne:
                relayUrl = constants_1.RELAY_URL_CAYENNE + '/auth/claim';
                break;
            case constants_1.LitNetwork.Habanero:
                relayUrl = constants_1.RELAY_URL_HABANERO + 'auth/claim';
                break;
            case constants_1.LitNetwork.Manzano:
                relayUrl = constants_1.RELAY_URL_MANZANO + 'auth/claim';
        }
        const url = params.relayUrl ? params.relayUrl : relayUrl;
        const response = await fetch(url, {
            method: 'POST',
            body: JSON.stringify(params),
            headers: {
                'api-key': params.relayApiKey
                    ? params.relayApiKey
                    : '67e55044-10b1-426f-9247-bb680e5fe0c8_relayer',
                'Content-Type': 'application/json',
            },
        });
        if (response.status < 200 || response.status >= 400) {
            let errResp = (await response.json()) ?? '';
            let errStmt = `An error occured requesting "/auth/claim" endpoint ${JSON.stringify(errResp)}`;
            console.warn(errStmt);
            throw new Error(errStmt);
        }
        let body = await response.json();
        return body.requestId;
    }
    catch (e) {
        console.error(e.message);
        throw e;
    }
};
exports.defaultMintClaimCallback = defaultMintClaimCallback;
const hexPrefixed = (str) => {
    if (str.startsWith('0x')) {
        return str;
    }
    return '0x' + str;
};
exports.hexPrefixed = hexPrefixed;
/**
 * getEnv - Determine the debug status based on environment variables or URL query parameters.
 *
 * @function
 * @export
 * @param {Object} [options={}] - Configuration options for determining debug status.
 * @param {string} [options.nodeEnvVar='DEBUG'] - The Node.js environment variable to check.
 * @param {string} [options.urlQueryParam='dev'] - The URL query parameter to check in a browser environment.
 * @param {string} [options.urlQueryValue='debug=true'] - The expected value of the URL query parameter to enable debugging.
 * @param {boolean} [options.defaultValue=false] - The default boolean value to return if no debug conditions are met.
 * @returns {boolean} - True if debug conditions are met, otherwise returns the provided defaultValue.
 *
 * @example
 * // Usage in Node.js environment
 * process.env.DEBUG = 'true';
 * console.log(getEnv()); // Outputs: true
 *
 * @example
 * // Usage in Browser environment with URL: http://example.com?dev=debug=true
 * console.log(getEnv()); // Outputs: true
 */
function getEnv({ nodeEnvVar = 'DEBUG', urlQueryParam = 'dev', urlQueryValue = 'debug=true', defaultValue = false, } = {}) {
    // Node.js environment
    if ((0, exports.isNode)()) {
        return process.env[nodeEnvVar] === 'true';
    }
    // Browser environment
    else if ((0, exports.isBrowser)()) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(urlQueryParam) === urlQueryValue;
    }
    // Default
    return defaultValue;
}
exports.getEnv = getEnv;
function sendRequest(url, req, requestId) {
    return fetch(url, req)
        .then(async (response) => {
        const isJson = response.headers
            .get('content-type')
            ?.includes('application/json');
        const data = isJson ? await response.json() : null;
        if (!response.ok) {
            // get error message from body or default to response status
            const error = data || response.status;
            return Promise.reject(error);
        }
        return data;
    })
        .catch((error) => {
        (0, exports.logErrorWithRequestId)(requestId, `Something went wrong, internal id for request: lit_${requestId}. Please provide this identifier with any support requests. ${error?.message || error?.details
            ? `Error is ${error.message} - ${error.details}`
            : ''}`);
        return Promise.reject(error);
    });
}
exports.sendRequest = sendRequest;
/**
 * Allows for invoking a callback and re exucting while re generating a new request identifier
 * @param execCallback
 * @param errorCallback
 * @param opts
 * @returns {T}
 */
async function executeWithRetry(execCallback, errorCallback, opts) {
    let timer;
    let counter = 0;
    let isTimeout = false;
    if (!opts) {
        opts = {};
    }
    opts.timeout = opts.timeout ?? 31000; // We wait for 31 seconds as the timeout period on the nodes is 30 seconds.
    opts.interval = opts.interval ?? 100;
    opts.maxRetryCount = opts.maxRetryCount ?? 3;
    let requestId = '';
    while (!isTimeout) {
        requestId = Math.random().toString(16).slice(2);
        try {
            timer = setTimeout(() => {
                isTimeout = true;
            }, opts.timeout);
            const response = await execCallback(requestId);
            clearTimeout(timer);
            response.requestId = requestId;
            // this will work for now as errors should all follow the
            // RejectedNodePromise type definition which contains an `error` property
            if ('error' in response) {
                counter += 1;
                errorCallback &&
                    errorCallback(response, requestId, counter >= opts.maxRetryCount ? true : false);
            }
            else {
                clearTimeout(timer);
                return response;
            }
            if (counter >= opts.maxRetryCount) {
                return response;
            }
        }
        catch (err) {
            errorCallback &&
                errorCallback(`Error is ${err.message}-${err.details}`, requestId, counter >= opts.maxRetryCount ? true : false);
            counter += 1;
        }
        await new Promise((resolve) => setTimeout(resolve, opts?.interval));
    }
    // If we get here we broke out of the loop on event of a timeout being hit.
    return {
        success: false,
        error: {
            errorKind: 'Timeout',
            status: 500,
            details: [`timeout limit reached timeout limit: ${opts.timeout}ms`],
        },
        requestId,
    };
}
exports.executeWithRetry = executeWithRetry;
//# sourceMappingURL=misc.js.map