function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var TEST_API_URL = 'https://test.stytch.com';
var LIVE_API_URL = 'https://api.stytch.com';
var CLIENTSIDE_SERVICES_IFRAME_URL = 'https://js.stytch.com/clientside-services/index.html';
var STYTCH_WEB_BACKEND_URL = "https://web.stytch.com";
var STYTCH_DFP_BACKEND_URL = "https://telemetry.stytch.com";
var STYTCH_DFP_CDN_URL = "https://elements.stytch.com";
var STYTCH_SESSION_COOKIE = 'stytch_session';
var STYTCH_SESSION_JWT_COOKIE = 'stytch_session_jwt';
var POWERED_BY_STYTCH_IMG_URL = 'https://public-assets.stytch.com/et_powered_by_stytch_logo.png';
var GOOGLE_ONE_TAP_HOST = 'https://accounts.google.com/gsi';
var GOOGLE_ONE_TAP_SCRIPT_URL = "".concat(GOOGLE_ONE_TAP_HOST, "/client");
var STYTCH_CSRF_TOKEN_NAME = 'stytch_csrf_private_token';
var DEFAULT_SESSION_DURATION_MINUTES = 30;
var DEFAULT_OTP_EXPIRATION_MINUTES = 5;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `oauth`, `otp`, `crypto` and `passwords`.
 */
var Products;
(function (Products) {
  Products["emailMagicLinks"] = "emailMagicLinks";
  Products["oauth"] = "oauth";
  Products["otp"] = "otp";
  Products["crypto"] = "crypto";
  Products["passwords"] = "passwords";
  Products["passkeys"] = "passkeys";
})(Products || (Products = {}));
/**
 * The OAuth providers we support in our OAuth product.
 * Currently we support `Amazon`, `Apple`, `Bitbucket`, `Discord`, `Facebook`, `Figma`, `Google`, `GitLab`,
 * `LinkedIn`, `Microsoft`, `Salesforce`, `Slack`, `Snapchat`, `TikTok`, `Twitch`, `Twitter`, and `Yahoo`.
 */
var OAuthProviders;
(function (OAuthProviders) {
  OAuthProviders["Google"] = "google";
  OAuthProviders["Microsoft"] = "microsoft";
  OAuthProviders["Apple"] = "apple";
  OAuthProviders["Github"] = "github";
  OAuthProviders["GitLab"] = "gitlab";
  OAuthProviders["Facebook"] = "facebook";
  OAuthProviders["Discord"] = "discord";
  OAuthProviders["Salesforce"] = "salesforce";
  OAuthProviders["Slack"] = "slack";
  OAuthProviders["Amazon"] = "amazon";
  OAuthProviders["Bitbucket"] = "bitbucket";
  OAuthProviders["LinkedIn"] = "linkedin";
  OAuthProviders["Coinbase"] = "coinbase";
  OAuthProviders["Twitch"] = "twitch";
  OAuthProviders["Twitter"] = "twitter";
  OAuthProviders["TikTok"] = "tiktok";
  OAuthProviders["Snapchat"] = "snapchat";
  OAuthProviders["Figma"] = "figma";
  OAuthProviders["Yahoo"] = "yahoo";
})(OAuthProviders || (OAuthProviders = {}));
/**
 * The Crypto Wallets we support in our crypto product.
 * Currently we support all ethereum and solana wallets.
 * We additionally detect and show popular wallets as distinct options.
 * The list of poular wallets include `Binance`, `Coinbase`, `Metamask`, `Phantom`, and `Vessel`
 */
var Wallets;
(function (Wallets) {
  Wallets["Vessel"] = "Vessel";
  Wallets["Phantom"] = "Phantom";
  Wallets["Metamask"] = "Metamask";
  Wallets["Coinbase"] = "Coinbase";
  Wallets["Binance"] = "Binance";
  Wallets["GenericEthereumWallet"] = "Other Ethereum Wallet";
  Wallets["GenericSolanaWallet"] = "Other Solana Wallet";
})(Wallets || (Wallets = {}));
/**
 * For Google One Tap, we support two different position options:
 * `embedded` will display Google One Tap within the existing JavaScript SDK login form
 * `floating` will display the One Tap prompt in the top right corner.
 */
var OneTapPositions;
(function (OneTapPositions) {
  OneTapPositions["embedded"] = "embedded";
  OneTapPositions["floating"] = "floating";
})(OneTapPositions || (OneTapPositions = {}));
/**
 * The methods array allows you to specify the authentication methods that you would like to expose
 * to your users. The order of the products that you include here will also be the order in which
 * they appear in the login form, with the first product specified appearing at the top of the login
 * form. We currently support passcodes on `email`, `sms` and `whatsapp`
 */
var OTPMethods;
(function (OTPMethods) {
  OTPMethods["SMS"] = "sms";
  OTPMethods["WhatsApp"] = "whatsapp";
  OTPMethods["Email"] = "email";
})(OTPMethods || (OTPMethods = {}));
var StytchEventType;
(function (StytchEventType) {
  StytchEventType["MagicLinkLoginOrCreateEvent"] = "MAGIC_LINK_LOGIN_OR_CREATE";
  StytchEventType["OTPsLoginOrCreateEvent"] = "OTP_LOGIN_OR_CREATE";
  StytchEventType["OTPsAuthenticate"] = "OTP_AUTHENTICATE";
  StytchEventType["CryptoWalletAuthenticateStart"] = "CRYPTO_WALLET_AUTHENTICATE_START";
  StytchEventType["CryptoWalletAuthenticate"] = "CRYPTO_WALLET_AUTHENTICATE";
  StytchEventType["PasswordCreate"] = "PASSWORD_CREATE";
  StytchEventType["PasswordAuthenticate"] = "PASSWORD_AUTHENTICATE";
  StytchEventType["PasswordResetByEmailStart"] = "PASSWORD_RESET_BY_EMAIL_START";
  StytchEventType["PasswordResetByEmail"] = "PASSWORD_RESET_BY_EMAIL";
  StytchEventType["PasskeyRegister"] = "PASSKEY_REGISTER";
  StytchEventType["PasskeyAuthenticate"] = "PASSKEY_AUTHENTICATE";
  StytchEventType["PasskeySkip"] = "PASSKEY_SKIP";
  StytchEventType["PasskeyDone"] = "PASSKEY_DONE";
  // More Events will go here ...
  // B2B Events
  StytchEventType["B2BMagicLinkEmailLoginOrSignup"] = "B2B_MAGIC_LINK_EMAIL_LOGIN_OR_SIGNUP";
  StytchEventType["B2BMagicLinkAuthenticate"] = "B2B_MAGIC_LINK_AUTHENTICATE";
  StytchEventType["B2BMagicLinkEmailDiscoverySend"] = "B2B_MAGIC_LINK_EMAIL_DISCOVERY_SEND";
  StytchEventType["B2BMagicLinkDiscoveryAuthenticate"] = "B2B_MAGIC_LINK_DISCOVERY_AUTHENTICATE";
  StytchEventType["B2BSSOStart"] = "B2B_SSO_START";
  StytchEventType["B2BSSOAuthenticate"] = "B2B_SSO_AUTHENTICATE";
  StytchEventType["B2BOAuthAuthenticate"] = "B2B_OAUTH_AUTHENTICATE";
  StytchEventType["B2BOAuthDiscoveryAuthenticate"] = "B2B_OAUTH_DISCOVERY_AUTHENTICATE";
  StytchEventType["B2BDiscoveryOrganizationsCreate"] = "B2B_DISCOVERY_ORGANIZATIONS_CREATE";
  StytchEventType["B2BDiscoveryIntermediateSessionExchange"] = "B2B_DISCOVERY_INTERMEDIATE_SESSION_EXCHANGE";
  StytchEventType["B2BPasswordAuthenticate"] = "B2B_PASSWORD_AUTHENTICATE";
  StytchEventType["B2BPasswordResetByEmailStart"] = "B2B_PASSWORD_RESET_BY_EMAIL_START";
  StytchEventType["B2BPasswordResetByEmail"] = "B2B_PASSWORD_RESET_BY_EMAIL";
  StytchEventType["B2BPasswordResetBySession"] = "B2B_PASSWORD_RESET_BY_SESSION";
})(StytchEventType || (StytchEventType = {}));

/**
 * An Error class thrown when the SDK is unable to reach the Stytch servers,
 * or when the Stytch servers return a value the SDK cannot understand.
 * Usually - it means that you're offline!
 */
var SDKAPIUnreachableError = /*#__PURE__*/function (_Error) {
  _inherits(SDKAPIUnreachableError, _Error);
  var _super = _createSuper(SDKAPIUnreachableError);
  function SDKAPIUnreachableError(message, details) {
    var _this;
    _classCallCheck(this, SDKAPIUnreachableError);
    _this = _super.call(this, message + '\n' + details);
    _this.message = message + '\n' + details;
    _this.name = 'SDKAPIUnreachableError';
    _this.details = details;
    Object.setPrototypeOf(_assertThisInitialized(_this), SDKAPIUnreachableError.prototype);
    return _this;
  }
  return _createClass(SDKAPIUnreachableError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input fails client-side validation -
 * for example if a field that was expected to be a number is instead a string.
 */
var StytchSDKUsageError = /*#__PURE__*/function (_Error2) {
  _inherits(StytchSDKUsageError, _Error2);
  var _super2 = _createSuper(StytchSDKUsageError);
  function StytchSDKUsageError(methodName, message) {
    var _this2;
    _classCallCheck(this, StytchSDKUsageError);
    _this2 = _super2.call(this);
    _this2.name = 'StytchSDKUsageError';
    _this2.message = "Invalid call to ".concat(methodName, "\n") + message;
    return _this2;
  }
  return _createClass(StytchSDKUsageError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input does not adhere to the Stytch API schema -
 * for example if a field that was expected to be a number is instead a string.
 */
var StytchSDKSchemaError = /*#__PURE__*/function (_Error3) {
  _inherits(StytchSDKSchemaError, _Error3);
  var _super3 = _createSuper(StytchSDKSchemaError);
  function StytchSDKSchemaError(schemaError) {
    var _this3;
    _classCallCheck(this, StytchSDKSchemaError);
    var _a;
    _this3 = _super3.call(this);
    _this3.name = 'StytchSDKSchemaError';
    var messages = (_a = schemaError.body) === null || _a === void 0 ? void 0 : _a.map(function (err) {
      return "".concat(err.dataPath, ": ").concat(err.message);
    }).join('\n');
    _this3.message = "[400] Request does not match expected schema\n".concat(messages);
    return _this3;
  }
  return _createClass(StytchSDKSchemaError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class wrapping a well-formed JSON error from the Stytch API.
 * The Stytch error should match one listed at {@link https://stytch.com/docs/api/errors}
 */
var StytchSDKAPIError = /*#__PURE__*/function (_Error4) {
  _inherits(StytchSDKAPIError, _Error4);
  var _super4 = _createSuper(StytchSDKAPIError);
  function StytchSDKAPIError(details) {
    var _this4;
    _classCallCheck(this, StytchSDKAPIError);
    _this4 = _super4.call(this);
    _this4.name = 'StytchSDKAPIError';
    var status_code = details.status_code,
      error_type = details.error_type,
      error_message = details.error_message,
      error_url = details.error_url,
      request_id = details.request_id;
    _this4.error_type = error_type;
    _this4.error_message = error_message;
    _this4.error_url = error_url;
    _this4.request_id = request_id;
    _this4.status_code = status_code;
    _this4.message = "[".concat(status_code, "] ").concat(error_type, "\n") + "".concat(error_message, "\n") + "See ".concat(error_url, " for more information.\n") + (
    // Web-Backend doesn't have request IDs yet, so if a request fails there it won't have one.
    // We should figure out how returning tracing info should work
    request_id ? "request_id: ".concat(request_id, "\n") : '');
    return _this4;
  }
  return _createClass(StytchSDKAPIError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * If the SDK throws an error with an error type included in this array, the local session and
 * user state will be cleared locally.
 */
var UNRECOVERABLE_ERROR_TYPES = ['unauthorized_credentials', 'user_unauthenticated', 'invalid_secret_authentication', 'session_not_found'];

/**
 * Biometric error types used in the React Native SDK.
 */
var BiometricsErrors;
(function (BiometricsErrors) {
  BiometricsErrors["BiometricsSensorError"] = "biometrics_sensor_error";
  BiometricsErrors["DeviceCredentialsNotAllowed"] = "device_credentials_not_allowed";
  BiometricsErrors["DeviceHardwareError"] = "device_hardware_error";
  BiometricsErrors["InternalError"] = "internal_error";
  BiometricsErrors["KeyInvalidated"] = "key_invalidated";
  BiometricsErrors["KeystoreUnavailable"] = "keystore_unavailable";
  BiometricsErrors["NoBiometricsEnrolled"] = "no_biometrics_enrolled";
  BiometricsErrors["NoBiometricsRegistration"] = "no_biometrics_registration";
  BiometricsErrors["SessionExpired"] = "session_expired";
  BiometricsErrors["UserCancellation"] = "user_cancellation";
  BiometricsErrors["UserLockedOut"] = "user_locked_out";
  BiometricsErrors["BiometricsNotAvailable"] = "biometrics_not_available";
})(BiometricsErrors || (BiometricsErrors = {}));

/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `sso`, `passwords`, and `oauth`.
 */
var B2BProducts;
(function (B2BProducts) {
  B2BProducts["emailMagicLinks"] = "emailMagicLinks";
  B2BProducts["sso"] = "sso";
  B2BProducts["passwords"] = "passwords";
  B2BProducts["oauth"] = "oauth";
})(B2BProducts || (B2BProducts = {}));
var AuthFlowType;
(function (AuthFlowType) {
  AuthFlowType["Discovery"] = "Discovery";
  AuthFlowType["Organization"] = "Organization";
  AuthFlowType["PasswordReset"] = "PasswordReset";
})(AuthFlowType || (AuthFlowType = {}));
/**
 * The OAuth providers we support in our B2B OAuth product.
 * Currently we support `google`, and `microsoft`.
 */
var B2BOAuthProviders;
(function (B2BOAuthProviders) {
  B2BOAuthProviders["Google"] = "google";
  B2BOAuthProviders["Microsoft"] = "microsoft";
})(B2BOAuthProviders || (B2BOAuthProviders = {}));
var RetriableErrorType;
(function (RetriableErrorType) {
  RetriableErrorType["RequiredCatcha"] = "Catcha Required";
})(RetriableErrorType || (RetriableErrorType = {}));
var RetriableError = /*#__PURE__*/function (_Error5) {
  _inherits(RetriableError, _Error5);
  var _super5 = _createSuper(RetriableError);
  function RetriableError(type) {
    var _this5;
    _classCallCheck(this, RetriableError);
    _this5 = _super5.call(this, type);
    _this5.type = type;
    return _this5;
  }
  return _createClass(RetriableError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
function retriableFetchSDK(_ref) {
  var method = _ref.method,
    errorMessage = _ref.errorMessage,
    finalURL = _ref.finalURL,
    basicAuthHeader = _ref.basicAuthHeader,
    xSDKClientHeader = _ref.xSDKClientHeader,
    xSDKParentHostHeader = _ref.xSDKParentHostHeader,
    body = _ref.body,
    retryCallback = _ref.retryCallback;
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var req;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          req = {
            method: method,
            errorMessage: errorMessage,
            finalURL: finalURL,
            basicAuthHeader: basicAuthHeader,
            xSDKClientHeader: xSDKClientHeader,
            xSDKParentHostHeader: xSDKParentHostHeader,
            body: body
          };
          _context.prev = 1;
          _context.next = 4;
          return baseFetchSDK(req);
        case 4:
          return _context.abrupt("return", _context.sent);
        case 7:
          _context.prev = 7;
          _context.t0 = _context["catch"](1);
          if (!(_context.t0 instanceof RetriableError)) {
            _context.next = 16;
            break;
          }
          _context.next = 12;
          return retryCallback(_context.t0, req);
        case 12:
          req = _context.sent;
          _context.next = 15;
          return baseFetchSDK(req);
        case 15:
          return _context.abrupt("return", _context.sent);
        case 16:
          throw _context.t0;
        case 17:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 7]]);
  }));
}
function baseFetchSDK(_ref2) {
  var method = _ref2.method,
    errorMessage = _ref2.errorMessage,
    finalURL = _ref2.finalURL,
    basicAuthHeader = _ref2.basicAuthHeader,
    xSDKClientHeader = _ref2.xSDKClientHeader,
    xSDKParentHostHeader = _ref2.xSDKParentHostHeader,
    body = _ref2.body;
  var _a;
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var headers, fetchOpts, resp, _respData, respError, respData;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          headers = {
            Authorization: basicAuthHeader,
            'Content-Type': 'application/json',
            'X-SDK-Client': xSDKClientHeader
          };
          if (xSDKParentHostHeader) {
            headers['X-SDK-Parent-Host'] = xSDKParentHostHeader;
          }
          fetchOpts = {
            method: method,
            headers: headers,
            body: body && JSON.stringify(body)
          };
          _context2.prev = 3;
          _context2.next = 6;
          return fetch(finalURL, fetchOpts);
        case 6:
          resp = _context2.sent;
          _context2.next = 14;
          break;
        case 9:
          _context2.prev = 9;
          _context2.t0 = _context2["catch"](3);
          if (!(_context2.t0.message === 'Failed to fetch')) {
            _context2.next = 13;
            break;
          }
          throw new SDKAPIUnreachableError(errorMessage, 'Unable to contact the Stytch servers. Are you online?');
        case 13:
          throw _context2.t0;
        case 14:
          if (!(resp.status <= 299)) {
            _context2.next = 25;
            break;
          }
          _context2.prev = 15;
          _context2.next = 18;
          return resp.json();
        case 18:
          _respData = _context2.sent;
          return _context2.abrupt("return", _respData.data);
        case 22:
          _context2.prev = 22;
          _context2.t1 = _context2["catch"](15);
          throw new SDKAPIUnreachableError(errorMessage, 'Invalid JSON response from the Stytch servers.');
        case 25:
          if (!(resp.status !== 200 && ((_a = resp.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')))) {
            _context2.next = 38;
            break;
          }
          _context2.prev = 26;
          _context2.next = 29;
          return resp.json();
        case 29:
          respError = _context2.sent;
          _context2.next = 35;
          break;
        case 32:
          _context2.prev = 32;
          _context2.t2 = _context2["catch"](26);
          throw new SDKAPIUnreachableError(errorMessage, 'Invalid or no response from server');
        case 35:
          if (!('body' in respError || 'params' in respError || 'query' in respError)) {
            _context2.next = 37;
            break;
          }
          throw new StytchSDKSchemaError(respError);
        case 37:
          throw new StytchSDKAPIError(respError);
        case 38:
          _context2.prev = 38;
          _context2.next = 41;
          return resp.text();
        case 41:
          respData = _context2.sent;
          _context2.next = 47;
          break;
        case 44:
          _context2.prev = 44;
          _context2.t3 = _context2["catch"](38);
          throw new SDKAPIUnreachableError(errorMessage, 'Invalid response from the Stytch servers.');
        case 47:
          if (!respData.includes('Captcha required')) {
            _context2.next = 49;
            break;
          }
          throw new RetriableError(RetriableErrorType.RequiredCatcha);
        case 49:
          throw new SDKAPIUnreachableError(errorMessage, 'Invalid response from the Stytch servers.');
        case 50:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[3, 9], [15, 22], [26, 32], [38, 44]]);
  }));
}

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$1(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields
  if (!validate$1(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
var ModulePromiseCache = {};
function loadESModule(url, moduleFromGlobalScope) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          if (!(ModulePromiseCache[url] !== undefined)) {
            _context3.next = 2;
            break;
          }
          return _context3.abrupt("return", ModulePromiseCache[url]);
        case 2:
          ModulePromiseCache[url] = loadESModuleFromNetwork(url, moduleFromGlobalScope);
          return _context3.abrupt("return", ModulePromiseCache[url]);
        case 4:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
}
function loadESModuleFromNetwork(url, moduleFromGlobalScope) {
  return new Promise(function (resolve, reject) {
    var maybeScript = findScript(url);
    if (maybeScript && maybeScript.dataset.loaded === 'true') {
      try {
        resolve(moduleFromGlobalScope());
      } catch (err) {
        return reject(new Error("".concat(url, " already loaded, but module was not found in global scope: ").concat(err)));
      }
    }
    var script = createScript(url);
    script.addEventListener('load', function () {
      script.dataset.loaded = 'true';
      try {
        resolve(moduleFromGlobalScope());
      } catch (err) {
        reject(new Error("".concat(url, " was loaded, but module was not found in global scope: ").concat(err)));
      }
    });
    script.addEventListener('error', function (err) {
      reject(new Error("".concat(url, " could not be loaded: ").concat(err)));
    });
  });
}
var findScriptsInDom = function findScriptsInDom(url) {
  return document.querySelectorAll("script[src=\"".concat(url, "\"]"));
};
function findScript(url) {
  var scripts = findScriptsInDom(url);
  if (scripts[0]) {
    return scripts[0];
  }
}
function createScript(url) {
  var script = document.createElement('script');
  script.setAttribute('src', url);
  script.setAttribute('async', 'true');
  script.setAttribute('defer', 'true');
  document.head.appendChild(script);
  return script;
}

/**
 * A set of tokens to stylize the console.log output
 * First token is the raw text. %c is a placeholder for string formatting
 * Second token starts our stylizing - adding custom color and background
 * Third token resets stylizing to baseline before showing the rest of the content.
 */
var STYTCH_BADGE = process.env.NODE_ENV === 'production' ? ['[Stytch]'] : ['%c[Stytch]%c', 'background: #19303d; color: #13E5C0; padding: 2px;border-radius: 4px', ''];
// Turn this to true to enable debug logs
// TODO: Make this an env var
var DEBUG = false;
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * An ultralightweight wrapper around console.log.
 * In the future, the logger might be passed in from the customer,
 * or the level might be configurable.
 */
var logger = {
  debug: function debug() {
    return DEBUG;
  },
  log: function log() {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_console = console).log.apply(_console, STYTCH_BADGE.concat(args));
  },
  warn: function warn() {
    var _console2;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return (_console2 = console).warn.apply(_console2, STYTCH_BADGE.concat(args));
  },
  error: function error() {
    var _console3;
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return (_console3 = console).error.apply(_console3, STYTCH_BADGE.concat(args));
  }
};
/* eslint-enable @typescript-eslint/no-explicit-any */
/* eslint-enable no-console */

var trailer = "\nYou can find your public token at https://stytch.com/dashboard/api-keys.";
var checkPublicToken = function checkPublicToken(publicToken) {
  if (typeof publicToken !== 'string') {
    logger.warn("Public token is malformed. Expected a string, got ".concat(_typeof(publicToken), ".").concat(trailer));
  } else if (publicToken === '') {
    logger.warn("Public token is malformed. Expected \"public-token-...\", got an empty string.".concat(trailer));
  } else if (!publicToken.startsWith('public-token-')) {
    logger.warn("Public token is malformed. Expected \"public-token-...\", got ".concat(publicToken, ".").concat(trailer));
  }
};
var checkNotSSR = function checkNotSSR(clientName) {
  var codeSample = clientName === 'StytchUIClient' ? "import { createStytchUIClient } from '@stytch/nextjs/ui';\n    \nconst stytch = createStytchUIClient('public-token-...');\n" : "import { createStytchHeadlessClient } from '@stytch/nextjs/ui';\n    \nconst stytch = createStytchHeadlessClient('public-token-...');\n";
  if (typeof window === 'undefined') {
    throw new Error("The ".concat(clientName, " is not compatible with server-side environments.\nIf using nextjs, use the create").concat(clientName, " method instead.\n```\n").concat(codeSample, "\n```\n"));
  }
};
var checkB2BNotSSR = function checkB2BNotSSR(clientName) {
  var codeSample = "import { createStytchB2BHeadlessClient } from '@stytch/nextjs/b2b';\n    \n  const stytch = createStytchB2BHeadlessClient('public-token-...');\n  ";
  if (typeof window === 'undefined') {
    throw new Error("The ".concat(clientName, " is not compatible with server-side environments.\nIf using nextjs, use the create").concat(clientName, " method instead.\n```\n").concat(codeSample, "\n```\n"));
  }
};
var isTestPublicToken = function isTestPublicToken(token) {
  return token.includes('public-token-test');
};
var createDeepEqual = function createDeepEqual() {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref3$KEYS_TO_EXCLUDE = _ref3.KEYS_TO_EXCLUDE,
    KEYS_TO_EXCLUDE = _ref3$KEYS_TO_EXCLUDE === void 0 ? [] : _ref3$KEYS_TO_EXCLUDE;
  // If comparing functions, this may need some work. Not sure the
  // best path for this: compare instance (what it currently does),
  // stringify and compare, etc.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var deepEqual = function deepEqual(a, b) {
    // Ensures type is the same
    if (_typeof(a) !== _typeof(b)) return false;
    // arrays, null, and objects all have type 'object'
    if (a === null || b === null) return a === b;
    if (_typeof(a) === 'object') {
      if (Object.keys(a).length !== Object.keys(b).length || Object.keys(a).some(function (k) {
        return !(k in b);
      })) return false;
      return Object.entries(a).filter(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 1),
          k = _ref5[0];
        return !KEYS_TO_EXCLUDE.includes(k);
      }).every(function (_ref6) {
        var _ref7 = _slicedToArray(_ref6, 2),
          k = _ref7[0],
          v = _ref7[1];
        return deepEqual(v, b[k]);
      });
    }
    // boolean, string, number, undefined
    return a === b;
  };
  return deepEqual;
};
/**
 * Normalizes an es5 promise with a .then(onSuccess, onFailure) signature to
 * the es6 .then().catch() signature
 */
var normalizePromiseLike = function normalizePromiseLike(prom) {
  return new Promise(function (resolve, reject) {
    prom.then(resolve, reject);
  });
};
var createEventId = function createEventId() {
  return "event-id-".concat(v4());
};
var createAppSessionId = function createAppSessionId() {
  return "app-session-id-".concat(v4());
};
var createPersistentId = function createPersistentId() {
  return "persistent-id-".concat(v4());
};
var validate = function validate(methodName) {
  var validator = {
    isObject: function isObject(fieldName, value) {
      var isObject = _typeof(value) === 'object' && !Array.isArray(value) && value !== null;
      if (!isObject) {
        throw new StytchSDKUsageError(methodName, fieldName + ' must be an object.');
      }
      return validator;
    },
    isOptionalObject: function isOptionalObject(fieldName, value) {
      if (typeof value === 'undefined') {
        return validator;
      }
      return validator.isObject(fieldName, value);
    },
    isString: function isString(fieldName, value) {
      if (typeof value !== 'string') {
        throw new StytchSDKUsageError(methodName, fieldName + ' must be a string.');
      }
      return validator;
    },
    isOptionalString: function isOptionalString(fieldName, value) {
      if (typeof value === 'undefined') {
        return validator;
      }
      return validator.isString(fieldName, value);
    },
    isStringArray: function isStringArray(fieldName, value) {
      if (!Array.isArray(value)) {
        throw new StytchSDKUsageError(methodName, fieldName + ' must be an array of strings.');
      }
      var _iterator = _createForOfIteratorHelper(value),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var str = _step.value;
          if (typeof str !== 'string') {
            throw new StytchSDKUsageError(methodName, fieldName + ' must be an array of strings.');
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return validator;
    },
    isOptionalStringArray: function isOptionalStringArray(fieldName, value) {
      if (typeof value === 'undefined') {
        return validator;
      }
      return validator.isStringArray(fieldName, value);
    },
    isNumber: function isNumber(fieldName, value) {
      if (typeof value !== 'number') {
        throw new StytchSDKUsageError(methodName, fieldName + ' must be a number.');
      }
      return validator;
    },
    isOptionalNumber: function isOptionalNumber(fieldName, value) {
      if (typeof value === 'undefined') {
        return validator;
      }
      return validator.isNumber(fieldName, value);
    },
    isBoolean: function isBoolean(fieldName, value) {
      if (typeof value !== 'boolean') {
        throw new StytchSDKUsageError(methodName, fieldName + ' must be a boolean.');
      }
      return validator;
    },
    isOptionalBoolean: function isOptionalBoolean(fieldName, value) {
      if (typeof value === 'undefined') {
        return validator;
      }
      return validator.isBoolean(fieldName, value);
    }
  };
  return validator;
};
var isPhoneMethod = function isPhoneMethod(selectionMethod) {
  return selectionMethod === OTPMethods.SMS || selectionMethod === OTPMethods.WhatsApp;
};
var isEmailMethod = function isEmailMethod(selectionMethod) {
  return selectionMethod === OTPMethods.Email;
};
var removeResponseCommon = function removeResponseCommon(_a) {
  var rest = __rest(_a, ["request_id", "status_code"]);
  return rest;
};
var omitUser = function omitUser(resp) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  var rest = __rest(resp, ["__user"]);
  return rest;
};
var loadTelemetryJS = function loadTelemetryJS() {
  loadESModule("".concat(STYTCH_DFP_CDN_URL, "/telemetry.js"), function () {
    return window;
  });
};
var DFPProtectedAuthProvider = /*#__PURE__*/_createClass(function DFPProtectedAuthProvider(publicToken, dfpBackendURL, bootstrapPromise) {
  var _this6 = this;
  var executeRecaptcha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {
    return Promise.resolve(undefined);
  };
  _classCallCheck(this, DFPProtectedAuthProvider);
  this.bootstrapPromise = bootstrapPromise;
  this.isEnabled = function () {
    return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", this.state.then(function (state) {
              return state.enabled;
            }));
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
  };
  this.getTelemetryID = function () {
    return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var _yield$this$state, publicToken, enabled, dfpBackendURL;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.state;
          case 2:
            _yield$this$state = _context5.sent;
            publicToken = _yield$this$state.publicToken;
            enabled = _yield$this$state.enabled;
            dfpBackendURL = _yield$this$state.dfpBackendURL;
            if (enabled) {
              _context5.next = 8;
              break;
            }
            return _context5.abrupt("return", undefined);
          case 8:
            _context5.next = 10;
            return window.GetTelemetryID(publicToken, "".concat(dfpBackendURL, "/submit"));
          case 10:
            return _context5.abrupt("return", _context5.sent);
          case 11:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
  };
  this.getDFPTelemetryIDAndCaptcha = function () {
    return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var _yield$this$state2, enabled, executeRecaptcha, mode, dfp_telemetry_id, captcha_token;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.state;
          case 2:
            _yield$this$state2 = _context6.sent;
            enabled = _yield$this$state2.enabled;
            executeRecaptcha = _yield$this$state2.executeRecaptcha;
            mode = _yield$this$state2.mode;
            dfp_telemetry_id = undefined;
            captcha_token = undefined;
            if (enabled) {
              _context6.next = 12;
              break;
            }
            _context6.next = 11;
            return executeRecaptcha();
          case 11:
            captcha_token = _context6.sent;
          case 12:
            if (!(mode === 'DECISIONING')) {
              _context6.next = 18;
              break;
            }
            _context6.next = 15;
            return this.getTelemetryID();
          case 15:
            dfp_telemetry_id = _context6.sent;
            _context6.next = 25;
            break;
          case 18:
            if (!(mode === 'OBSERVATION')) {
              _context6.next = 25;
              break;
            }
            _context6.next = 21;
            return this.getTelemetryID();
          case 21:
            dfp_telemetry_id = _context6.sent;
            _context6.next = 24;
            return executeRecaptcha();
          case 24:
            captcha_token = _context6.sent;
          case 25:
            return _context6.abrupt("return", {
              dfp_telemetry_id: dfp_telemetry_id,
              captcha_token: captcha_token
            });
          case 26:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
  };
  this.retryWithCaptchaAndDFP = function (e, req) {
    return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var _yield$this$state3, enabled, executeRecaptcha;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return this.state;
          case 2:
            _yield$this$state3 = _context7.sent;
            enabled = _yield$this$state3.enabled;
            executeRecaptcha = _yield$this$state3.executeRecaptcha;
            if (!(e.type === RetriableErrorType.RequiredCatcha && enabled)) {
              _context7.next = 14;
              break;
            }
            if (!req.body) {
              _context7.next = 13;
              break;
            }
            _context7.next = 9;
            return this.getTelemetryID();
          case 9:
            req.body.dfp_telemetry_id = _context7.sent;
            _context7.next = 12;
            return executeRecaptcha();
          case 12:
            req.body.captcha_token = _context7.sent;
          case 13:
            return _context7.abrupt("return", req);
          case 14:
            throw new Error('Unable to query captcha and/or dfp telemetry ID');
          case 15:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
  };
  this.state = bootstrapPromise.then(function (bootstrapData) {
    return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            if (bootstrapData.runDFPProtectedAuth) {
              _context8.next = 2;
              break;
            }
            return _context8.abrupt("return", {
              publicToken: publicToken,
              dfpBackendURL: dfpBackendURL,
              enabled: false,
              loaded: false,
              executeRecaptcha: executeRecaptcha
            });
          case 2:
            _context8.next = 4;
            return loadTelemetryJS();
          case 4:
            return _context8.abrupt("return", {
              publicToken: publicToken,
              dfpBackendURL: dfpBackendURL,
              enabled: true,
              mode: bootstrapData.dfpProtectedAuthMode || 'OBSERVATION',
              loaded: true,
              executeRecaptcha: executeRecaptcha
            });
          case 5:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
  });
});
var DisabledDFPProtectedAuthProvider = function DisabledDFPProtectedAuthProvider() {
  return {
    isEnabled: function isEnabled() {
      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              return _context9.abrupt("return", false);
            case 1:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
    },
    getTelemetryID: function getTelemetryID() {
      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              return _context10.abrupt("return", undefined);
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
    },
    getDFPTelemetryIDAndCaptcha: function getDFPTelemetryIDAndCaptcha() {
      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", {
                dfp_telemetry_id: undefined,
                captcha_token: undefined
              });
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }));
    },
    retryWithCaptchaAndDFP: function retryWithCaptchaAndDFP() {
      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              throw new Error('DFP protected auth is disabled');
            case 1:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }));
    }
  };
};

/**
 * Some errors are thrown from inside an iframe, but we can't serialize them
 * to the parent in Webkit. This class handles casting them to plain objects,
 * and restoring them on the other side. ()
 * It preserves the error instance/class constructor by inspecting err.name
 * and calling `new` on the matching constructor.
 */
var ErrorMarshaller = /*#__PURE__*/function () {
  function ErrorMarshaller() {
    _classCallCheck(this, ErrorMarshaller);
  }
  _createClass(ErrorMarshaller, null, [{
    key: "marshall",
    value: function marshall(error) {
      return Object.assign(Object.assign({}, error), {
        // Some builtin errors don't have these as enumerable properties, need to specify manually
        name: error.name,
        message: error.message,
        stack: error.stack
      });
    }
  }, {
    key: "inflate",
    value: function inflate(ErrorClass, ErrorData) {
      // !!HACK!!
      // We make the assumption that if the error takes in a required property
      // (StytchSDKAPIError takes in an APIDetials obj...)
      // that we can just pass in the error body itself to satisfy the constructor...
      // And if the types don't work out, Object.assign(...) copies everything over anyway
      // This is a brittle and weak assumption.
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      var err = new ErrorClass(ErrorData);
      Object.assign(err, ErrorData);
      Object.setPrototypeOf(err, ErrorClass.prototype);
      return err;
    }
  }, {
    key: "unmarshall",
    value: function unmarshall(error) {
      if ('name' in error) {
        switch (error.name) {
          case 'SDKAPIUnreachableError':
            return ErrorMarshaller.inflate(SDKAPIUnreachableError, error);
          case 'StytchSDKSchemaError':
            return ErrorMarshaller.inflate(StytchSDKSchemaError, error);
          case 'StytchSDKAPIError':
            return ErrorMarshaller.inflate(StytchSDKAPIError, error);
          case 'TypeError':
            return ErrorMarshaller.inflate(TypeError, error);
          case 'SyntaxError':
            return ErrorMarshaller.inflate(SyntaxError, error);
          case 'ReferenceError':
            return ErrorMarshaller.inflate(ReferenceError, error);
          case 'RangeError':
            return ErrorMarshaller.inflate(RangeError, error);
          case 'EvalError':
            return ErrorMarshaller.inflate(EvalError, error);
          case 'URIError':
            return ErrorMarshaller.inflate(URIError, error);
        }
      }
      return ErrorMarshaller.inflate(Error, error);
    }
  }]);
  return ErrorMarshaller;
}();
var DEFAULT_MAX_BATCH_SIZE = 15;
var DEFAULT_INTERVAL_DURATION_MS = 800;
var EventLogger = /*#__PURE__*/function () {
  function EventLogger(args) {
    _classCallCheck(this, EventLogger);
    this.maxBatchSize = args.maxBatchSize;
    this.logEventURL = args.logEventURL;
    // TODO: If we create more than one of these, we'll want a mechanism to clean up the intervals
    setInterval(this.flush.bind(this), args.intervalDurationMs);
    this.batch = [];
  }
  _createClass(EventLogger, [{
    key: "logEvent",
    value: function logEvent(telemetry, event) {
      this.batch.push({
        telemetry: telemetry,
        event: event
      });
      if (this.batch.length >= this.maxBatchSize) {
        this.flush();
      }
    }
  }, {
    key: "flush",
    value: function flush() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
        var batchToSubmit;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              if (this.batch.length) {
                _context13.next = 2;
                break;
              }
              return _context13.abrupt("return");
            case 2:
              batchToSubmit = this.batch;
              this.batch = [];
              _context13.prev = 4;
              _context13.next = 7;
              return fetch(this.logEventURL, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(batchToSubmit)
              });
            case 7:
              _context13.next = 11;
              break;
            case 9:
              _context13.prev = 9;
              _context13.t0 = _context13["catch"](4);
            case 11:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this, [[4, 9]]);
      }));
    }
  }]);
  return EventLogger;
}();
var EmailSentType;
(function (EmailSentType) {
  EmailSentType["LoginOrCreateEML"] = "login_or_create_eml";
  EmailSentType["LoginOrCreateOTP"] = "login_or_create_otp";
  EmailSentType["ResetPassword"] = "reset_password";
})(EmailSentType || (EmailSentType = {}));
var HeadlessUserClient = /*#__PURE__*/_createClass(function HeadlessUserClient(_networkClient, _subscriptionService) {
  var _this7 = this;
  _classCallCheck(this, HeadlessUserClient);
  this._networkClient = _networkClient;
  this._subscriptionService = _subscriptionService;
  this.get = function () {
    return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            _context14.next = 2;
            return this._networkClient.fetchSDK({
              url: '/users/me',
              errorMessage: 'Failed to retrieve user info.',
              method: 'GET'
            });
          case 2:
            resp = _context14.sent;
            user = removeResponseCommon(resp);
            this._subscriptionService.updateUser(user);
            return _context14.abrupt("return", user);
          case 6:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this);
    }));
  };
  this.getSync = function () {
    return _this7._subscriptionService.getUser();
  };
  this.update = function (options) {
    return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            validate('stytch.user.update').isOptionalObject('untrusted_metadata', options.untrusted_metadata);
            _context15.next = 3;
            return this._networkClient.fetchSDK({
              url: '/users/me',
              body: options,
              errorMessage: 'Failed to update user.',
              method: 'PUT'
            });
          case 3:
            resp = _context15.sent;
            user = removeResponseCommon(resp.__user);
            this._subscriptionService.updateUser(user);
            return _context15.abrupt("return", omitUser(resp));
          case 7:
          case "end":
            return _context15.stop();
        }
      }, _callee15, this);
    }));
  };
  this.deleteEmail = function (emailId) {
    return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            _context16.next = 2;
            return this._networkClient.fetchSDK({
              url: "/users/emails/".concat(emailId),
              errorMessage: 'Failed to delete email.',
              method: 'DELETE'
            });
          case 2:
            resp = _context16.sent;
            user = removeResponseCommon(resp.__user);
            this._subscriptionService.updateUser(user);
            return _context16.abrupt("return", omitUser(resp));
          case 6:
          case "end":
            return _context16.stop();
        }
      }, _callee16, this);
    }));
  };
  this.deletePhoneNumber = function (phoneId) {
    return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            _context17.next = 2;
            return this._networkClient.fetchSDK({
              url: "/users/phone_numbers/".concat(phoneId),
              errorMessage: 'Failed to delete phone number.',
              method: 'DELETE'
            });
          case 2:
            resp = _context17.sent;
            user = removeResponseCommon(resp.__user);
            this._subscriptionService.updateUser(user);
            return _context17.abrupt("return", omitUser(resp));
          case 6:
          case "end":
            return _context17.stop();
        }
      }, _callee17, this);
    }));
  };
  this.deleteTOTP = function (totpId) {
    return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            _context18.next = 2;
            return this._networkClient.fetchSDK({
              url: "/users/totps/".concat(totpId),
              errorMessage: 'Failed to delete TOTP.',
              method: 'DELETE'
            });
          case 2:
            resp = _context18.sent;
            user = removeResponseCommon(resp.__user);
            this._subscriptionService.updateUser(user);
            return _context18.abrupt("return", omitUser(resp));
          case 6:
          case "end":
            return _context18.stop();
        }
      }, _callee18, this);
    }));
  };
  this.deleteOAuthRegistration = function (oauthUserRegistrationId) {
    return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            _context19.next = 2;
            return this._networkClient.fetchSDK({
              url: "/users/oauth/".concat(oauthUserRegistrationId),
              errorMessage: 'Failed to delete OAuth registration.',
              method: 'DELETE'
            });
          case 2:
            resp = _context19.sent;
            user = removeResponseCommon(resp.__user);
            this._subscriptionService.updateUser(user);
            return _context19.abrupt("return", omitUser(resp));
          case 6:
          case "end":
            return _context19.stop();
        }
      }, _callee19, this);
    }));
  };
  this.deleteWebauthnRegistration = function (webAuthnId) {
    return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee20$(_context20) {
        while (1) switch (_context20.prev = _context20.next) {
          case 0:
            _context20.next = 2;
            return this._networkClient.fetchSDK({
              url: "/users/webauthn_registrations/".concat(webAuthnId),
              errorMessage: 'Failed to delete WebAuthn registration.',
              method: 'DELETE'
            });
          case 2:
            resp = _context20.sent;
            user = removeResponseCommon(resp.__user);
            this._subscriptionService.updateUser(user);
            return _context20.abrupt("return", omitUser(resp));
          case 6:
          case "end":
            return _context20.stop();
        }
      }, _callee20, this);
    }));
  };
  this.deleteBiometricRegistration = function (biometricRegistrationId) {
    return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
      var resp, user;
      return _regeneratorRuntime().wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            _context21.next = 2;
            return this._networkClient.fetchSDK({
              url: "/users/biometric_registrations/".concat(biometricRegistrationId),
              errorMessage: 'Failed to delete Biometric registration.',
              method: 'DELETE'
            });
          case 2:
            resp = _context21.sent;
            user = removeResponseCommon(resp.__user);
            this._subscriptionService.updateUser(user);
            return _context21.abrupt("return", omitUser(resp));
          case 6:
          case "end":
            return _context21.stop();
        }
      }, _callee21, this);
    }));
  };
  this.onChange = function (callback) {
    var lastVal = _this7._subscriptionService.getUser();
    var listener = function listener(state) {
      var _a;
      if ((state === null || state === void 0 ? void 0 : state.user) !== lastVal) {
        lastVal = (_a = state === null || state === void 0 ? void 0 : state.user) !== null && _a !== void 0 ? _a : null;
        callback(lastVal);
      }
    };
    return _this7._subscriptionService.subscribeToState(listener);
  };
});
var HeadlessSessionClient = /*#__PURE__*/function () {
  function HeadlessSessionClient(_networkClient, _subscriptionService) {
    var _this8 = this;
    _classCallCheck(this, HeadlessSessionClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this.getSync = function () {
      return _this8._subscriptionService.getSession();
    };
    this.onChange = function (callback) {
      var lastVal = _this8._subscriptionService.getSession();
      var listener = function listener(state) {
        var _a;
        if ((state === null || state === void 0 ? void 0 : state.session) !== lastVal) {
          lastVal = (_a = state === null || state === void 0 ? void 0 : state.session) !== null && _a !== void 0 ? _a : null;
          callback(lastVal);
        }
      };
      return _this8._subscriptionService.subscribeToState(listener);
    };
    this.revoke = function (options) {
      return __awaiter(_this8, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.prev = 0;
              _context22.next = 3;
              return this._networkClient.fetchSDK({
                url: "/sessions/revoke",
                errorMessage: 'Error revoking session',
                method: 'POST'
              });
            case 3:
              resp = _context22.sent;
              this._subscriptionService.destroyState();
              return _context22.abrupt("return", resp);
            case 8:
              _context22.prev = 8;
              _context22.t0 = _context22["catch"](0);
              if (!!(options === null || options === void 0 ? void 0 : options.forceClear)) {
                this._subscriptionService.destroyState();
              } else if (UNRECOVERABLE_ERROR_TYPES.includes(_context22.t0.error_type)) {
                this._subscriptionService.destroyState();
              }
              throw _context22.t0;
            case 12:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this, [[0, 8]]);
      }));
    };
    this.authenticate = function (options) {
      return __awaiter(_this8, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
        var requestBody, resp;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _context23.prev = 0;
              requestBody = {
                session_duration_minutes: options === null || options === void 0 ? void 0 : options.session_duration_minutes
              };
              _context23.next = 4;
              return this._networkClient.fetchSDK({
                url: '/sessions/authenticate',
                body: requestBody,
                errorMessage: 'Error authenticating session',
                method: 'POST'
              });
            case 4:
              resp = _context23.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context23.abrupt("return", omitUser(resp));
            case 9:
              _context23.prev = 9;
              _context23.t0 = _context23["catch"](0);
              if (UNRECOVERABLE_ERROR_TYPES.includes(_context23.t0.error_type)) {
                this._subscriptionService.destroyState();
              }
              throw _context23.t0;
            case 13:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this, [[0, 9]]);
      }));
    };
  }
  _createClass(HeadlessSessionClient, [{
    key: "getTokens",
    value: function getTokens() {
      return this._subscriptionService.getTokens();
    }
  }, {
    key: "updateSession",
    value: function updateSession(tokens) {
      this._subscriptionService.updateTokens(tokens);
    }
  }]);
  return HeadlessSessionClient;
}();
var DefaultDynamicConfig$3 = Promise.resolve({
  pkceRequiredForEmailMagicLinks: false
});
var HeadlessMagicLinksClient = /*#__PURE__*/function () {
  function HeadlessMagicLinksClient(_networkClient, _subscriptionService, _pkceManager, _passwordResetPKCEManager) {
    var _this9 = this;
    var _config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DefaultDynamicConfig$3;
    var dfpProtectedAuth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : DisabledDFPProtectedAuthProvider();
    _classCallCheck(this, HeadlessMagicLinksClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._passwordResetPKCEManager = _passwordResetPKCEManager;
    this._config = _config;
    this.dfpProtectedAuth = dfpProtectedAuth;
    this.email = {
      loginOrCreate: function loginOrCreate(email) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return __awaiter(_this9, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
          var _yield$this$_config, pkceRequiredForEmailMagicLinks, code_challenge, _yield$this$dfpProtec, dfp_telemetry_id, captcha_token, requestBody;
          return _regeneratorRuntime().wrap(function _callee24$(_context24) {
            while (1) switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this._config;
              case 2:
                _yield$this$_config = _context24.sent;
                pkceRequiredForEmailMagicLinks = _yield$this$_config.pkceRequiredForEmailMagicLinks;
                code_challenge = undefined;
                if (!pkceRequiredForEmailMagicLinks) {
                  _context24.next = 9;
                  break;
                }
                _context24.next = 8;
                return this.getCodeChallenge();
              case 8:
                code_challenge = _context24.sent;
              case 9:
                _context24.next = 11;
                return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
              case 11:
                _yield$this$dfpProtec = _context24.sent;
                dfp_telemetry_id = _yield$this$dfpProtec.dfp_telemetry_id;
                captcha_token = _yield$this$dfpProtec.captcha_token;
                requestBody = Object.assign(Object.assign({}, options), {
                  email: email,
                  code_challenge: code_challenge,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                });
                return _context24.abrupt("return", this._networkClient.retriableFetchSDK({
                  url: '/magic_links/email/login_or_create',
                  body: requestBody,
                  errorMessage: 'Failed to send magic link',
                  method: 'POST',
                  retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
                }));
              case 16:
              case "end":
                return _context24.stop();
            }
          }, _callee24, this);
        }));
      },
      send: function send(email) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return __awaiter(_this9, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
          var _yield$this$_config2, pkceRequiredForEmailMagicLinks, code_challenge, _yield$this$dfpProtec2, dfp_telemetry_id, captcha_token, requestBody, isLoggedIn, endpoint;
          return _regeneratorRuntime().wrap(function _callee25$(_context25) {
            while (1) switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this._config;
              case 2:
                _yield$this$_config2 = _context25.sent;
                pkceRequiredForEmailMagicLinks = _yield$this$_config2.pkceRequiredForEmailMagicLinks;
                code_challenge = undefined;
                if (!pkceRequiredForEmailMagicLinks) {
                  _context25.next = 9;
                  break;
                }
                _context25.next = 8;
                return this.getCodeChallenge();
              case 8:
                code_challenge = _context25.sent;
              case 9:
                _context25.next = 11;
                return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
              case 11:
                _yield$this$dfpProtec2 = _context25.sent;
                dfp_telemetry_id = _yield$this$dfpProtec2.dfp_telemetry_id;
                captcha_token = _yield$this$dfpProtec2.captcha_token;
                requestBody = Object.assign(Object.assign({}, options), {
                  email: email,
                  code_challenge: code_challenge,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                });
                isLoggedIn = !!this._subscriptionService.getSession();
                endpoint = isLoggedIn ? '/magic_links/email/send/secondary' : '/magic_links/email/send/primary';
                return _context25.abrupt("return", this._networkClient.retriableFetchSDK({
                  url: endpoint,
                  body: requestBody,
                  errorMessage: 'Failed to send magic link',
                  method: 'POST',
                  retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
                }));
              case 18:
              case "end":
                return _context25.stop();
            }
          }, _callee25, this);
        }));
      }
    };
    this.authenticate = function (token, options) {
      return __awaiter(_this9, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
        var passwordResetPKPair, resp;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              validate('stytch.magicLinks.authenticate').isString('Token', token).isNumber('session_duration_minutes', options.session_duration_minutes);
              // When a user resets their password with PKCE turned on, they create a pkPair in the 'passwords' namespace.
              // However, when the user gets the reset password email, they have the option to log in without a password.
              // This redirects them to the magic link authenticate flow, which automatically looks for the pkce code_verifier
              // in the 'magic_links' namespace, breaking the flow. Unfortunately we won't know for sure in the eml authenticate call
              // whether or not the user is coming from a password reset flow. To handle this, we have to try to authenticate with
              // both the 'passwords' and 'magic_links' code_verifiers.
              _context26.next = 3;
              return this._passwordResetPKCEManager.getPKPair();
            case 3:
              passwordResetPKPair = _context26.sent;
              resp = null;
              if (!(passwordResetPKPair === null || passwordResetPKPair === void 0 ? void 0 : passwordResetPKPair.code_verifier)) {
                _context26.next = 19;
                break;
              }
              _context26.prev = 6;
              _context26.next = 9;
              return this.handlePKCEForAuthenticate(this._passwordResetPKCEManager, Object.assign(Object.assign({}, options), {
                token: token
              }));
            case 9:
              resp = _context26.sent;
              _context26.next = 19;
              break;
            case 12:
              _context26.prev = 12;
              _context26.t0 = _context26["catch"](6);
              if (!_context26.t0.message.includes('pkce')) {
                _context26.next = 18;
                break;
              }
              // If pkce-related error, fall back to magic links code_verifier
              // eslint-disable-next-line no-console
              console.log('Authenticate with passwords pkce namespace failed. Falling back to authenticate with magic_links namespace.');
              _context26.next = 19;
              break;
            case 18:
              throw _context26.t0;
            case 19:
              if (resp) {
                _context26.next = 23;
                break;
              }
              _context26.next = 22;
              return this.handlePKCEForAuthenticate(this._pkceManager, Object.assign(Object.assign({}, options), {
                token: token
              }));
            case 22:
              resp = _context26.sent;
            case 23:
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context26.abrupt("return", omitUser(resp));
            case 25:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this, [[6, 12]]);
      }));
    };
  }
  _createClass(HeadlessMagicLinksClient, [{
    key: "getCodeChallenge",
    value: function getCodeChallenge() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
        var keyPair;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this._pkceManager.getPKPair();
            case 2:
              keyPair = _context27.sent;
              if (!keyPair) {
                _context27.next = 5;
                break;
              }
              return _context27.abrupt("return", keyPair.code_challenge);
            case 5:
              _context27.next = 7;
              return this._pkceManager.startPKCETransaction();
            case 7:
              keyPair = _context27.sent;
              return _context27.abrupt("return", keyPair.code_challenge);
            case 9:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
    }
  }, {
    key: "handlePKCEForAuthenticate",
    value: function handlePKCEForAuthenticate(pkceManager, data) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
        var pkPair, requestBody, resp;
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              _context28.next = 2;
              return pkceManager.getPKPair();
            case 2:
              pkPair = _context28.sent;
              requestBody = Object.assign({
                code_verifier: pkPair === null || pkPair === void 0 ? void 0 : pkPair.code_verifier
              }, data);
              _context28.next = 6;
              return this._networkClient.fetchSDK({
                url: '/magic_links/authenticate',
                body: requestBody,
                errorMessage: 'Failed to authenticate token.',
                method: 'POST'
              });
            case 6:
              resp = _context28.sent;
              pkceManager.clearPKPair();
              return _context28.abrupt("return", resp);
            case 9:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
    }
  }]);
  return HeadlessMagicLinksClient;
}();
var HeadlessOTPClient = /*#__PURE__*/_createClass(function HeadlessOTPClient(_networkClient, _subscriptionService) {
  var _this10 = this;
  var executeRecaptcha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
    return Promise.resolve(undefined);
  };
  var dfpProtectedAuth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DisabledDFPProtectedAuthProvider();
  _classCallCheck(this, HeadlessOTPClient);
  this._networkClient = _networkClient;
  this._subscriptionService = _subscriptionService;
  this.executeRecaptcha = executeRecaptcha;
  this.dfpProtectedAuth = dfpProtectedAuth;
  this.sms = {
    loginOrCreate: function loginOrCreate(phone_number, options) {
      return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
        var _yield$this$dfpProtec3, dfp_telemetry_id, captcha_token, requestBody;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 2:
              _yield$this$dfpProtec3 = _context29.sent;
              dfp_telemetry_id = _yield$this$dfpProtec3.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec3.captcha_token;
              requestBody = Object.assign(Object.assign({}, options), {
                phone_number: phone_number,
                captcha_token: captcha_token,
                dfp_telemetry_id: dfp_telemetry_id
              });
              return _context29.abrupt("return", this._networkClient.retriableFetchSDK({
                url: '/otps/sms/login_or_create',
                body: requestBody,
                errorMessage: 'Failed to send one time passcode',
                method: 'POST',
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              }));
            case 7:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));
    },
    send: function send(phone_number, options) {
      return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {
        var _yield$this$dfpProtec4, dfp_telemetry_id, captcha_token, requestBody, isLoggedIn, endpoint;
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              _context30.next = 2;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 2:
              _yield$this$dfpProtec4 = _context30.sent;
              dfp_telemetry_id = _yield$this$dfpProtec4.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec4.captcha_token;
              requestBody = Object.assign(Object.assign({}, options), {
                phone_number: phone_number,
                captcha_token: captcha_token,
                dfp_telemetry_id: dfp_telemetry_id
              });
              isLoggedIn = !!this._subscriptionService.getSession();
              endpoint = isLoggedIn ? '/otps/sms/send/secondary' : '/otps/sms/send/primary';
              return _context30.abrupt("return", this._networkClient.retriableFetchSDK({
                url: endpoint,
                body: requestBody,
                errorMessage: 'Failed to send one time passcode',
                method: 'POST',
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              }));
            case 9:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));
    }
  };
  this.whatsapp = {
    loginOrCreate: function loginOrCreate(phone_number, options) {
      return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {
        var _yield$this$dfpProtec5, dfp_telemetry_id, captcha_token, requestBody;
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              _context31.next = 2;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 2:
              _yield$this$dfpProtec5 = _context31.sent;
              dfp_telemetry_id = _yield$this$dfpProtec5.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec5.captcha_token;
              requestBody = Object.assign(Object.assign({}, options), {
                phone_number: phone_number,
                dfp_telemetry_id: dfp_telemetry_id,
                captcha_token: captcha_token
              });
              return _context31.abrupt("return", this._networkClient.retriableFetchSDK({
                url: '/otps/whatsapp/login_or_create',
                body: requestBody,
                errorMessage: 'Failed to send one time passcode',
                method: 'POST',
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              }));
            case 7:
            case "end":
              return _context31.stop();
          }
        }, _callee31, this);
      }));
    },
    send: function send(phone_number, options) {
      return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {
        var _yield$this$dfpProtec6, dfp_telemetry_id, captcha_token, requestBody, isLoggedIn, endpoint;
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              _context32.next = 2;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 2:
              _yield$this$dfpProtec6 = _context32.sent;
              dfp_telemetry_id = _yield$this$dfpProtec6.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec6.captcha_token;
              requestBody = Object.assign(Object.assign({}, options), {
                phone_number: phone_number,
                captcha_token: captcha_token,
                dfp_telemetry_id: dfp_telemetry_id
              });
              isLoggedIn = !!this._subscriptionService.getSession();
              endpoint = isLoggedIn ? '/otps/whatsapp/send/secondary' : '/otps/whatsapp/send/primary';
              return _context32.abrupt("return", this._networkClient.retriableFetchSDK({
                url: endpoint,
                body: requestBody,
                errorMessage: 'Failed to send one time passcode',
                method: 'POST',
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              }));
            case 9:
            case "end":
              return _context32.stop();
          }
        }, _callee32, this);
      }));
    }
  };
  this.email = {
    loginOrCreate: function loginOrCreate(email, options) {
      return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {
        var captcha_token, requestBody;
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              _context33.next = 2;
              return this.executeRecaptcha();
            case 2:
              captcha_token = _context33.sent;
              requestBody = Object.assign(Object.assign({}, options), {
                email: email,
                captcha_token: captcha_token
              });
              return _context33.abrupt("return", this._networkClient.fetchSDK({
                url: '/otps/email/login_or_create',
                body: requestBody,
                errorMessage: 'Failed to send one time passcode',
                method: 'POST'
              }));
            case 5:
            case "end":
              return _context33.stop();
          }
        }, _callee33, this);
      }));
    },
    send: function send(email, options) {
      return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {
        var captcha_token, requestBody, isLoggedIn, endpoint;
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              _context34.next = 2;
              return this.executeRecaptcha();
            case 2:
              captcha_token = _context34.sent;
              requestBody = Object.assign(Object.assign({}, options), {
                email: email,
                captcha_token: captcha_token
              });
              isLoggedIn = !!this._subscriptionService.getSession();
              endpoint = isLoggedIn ? '/otps/email/send/secondary' : '/otps/email/send/primary';
              return _context34.abrupt("return", this._networkClient.fetchSDK({
                url: endpoint,
                body: requestBody,
                errorMessage: 'Failed to send one time passcode',
                method: 'POST'
              }));
            case 7:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this);
      }));
    }
  };
  this.authenticate = function (code, method_id, options) {
    return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {
      var _yield$this$dfpProtec7, dfp_telemetry_id, captcha_token, requestBody, resp;
      return _regeneratorRuntime().wrap(function _callee35$(_context35) {
        while (1) switch (_context35.prev = _context35.next) {
          case 0:
            validate('stytch.otps.authenticate').isString('Code', code).isNumber('session_duration_minutes', options.session_duration_minutes);
            _context35.next = 3;
            return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
          case 3:
            _yield$this$dfpProtec7 = _context35.sent;
            dfp_telemetry_id = _yield$this$dfpProtec7.dfp_telemetry_id;
            captcha_token = _yield$this$dfpProtec7.captcha_token;
            requestBody = Object.assign({
              token: code,
              method_id: method_id,
              dfp_telemetry_id: dfp_telemetry_id,
              captcha_token: captcha_token
            }, options);
            _context35.next = 9;
            return this._networkClient.retriableFetchSDK({
              url: '/otps/authenticate',
              body: requestBody,
              errorMessage: 'Failed to authenticate token.',
              method: 'POST',
              retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
            });
          case 9:
            resp = _context35.sent;
            this._subscriptionService.updateStateAndTokens({
              state: {
                session: resp.session,
                user: resp.user
              },
              session_token: resp.session_token,
              session_jwt: resp.session_jwt,
              intermediate_session_token: null
            });
            return _context35.abrupt("return", omitUser(resp));
          case 12:
          case "end":
            return _context35.stop();
        }
      }, _callee35, this);
    }));
  };
});
var HeadlessOAuthClient = /*#__PURE__*/function () {
  function HeadlessOAuthClient(_networkClient, _subscriptionService, _pkceManager, _dynamicConfig, _config) {
    _classCallCheck(this, HeadlessOAuthClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._dynamicConfig = _dynamicConfig;
    this._config = _config;
    this.google = {
      start: this.startOAuthFlow(OAuthProviders.Google)
    };
    this.apple = {
      start: this.startOAuthFlow(OAuthProviders.Apple)
    };
    this.microsoft = {
      start: this.startOAuthFlow(OAuthProviders.Microsoft)
    };
    this.github = {
      start: this.startOAuthFlow(OAuthProviders.Github)
    };
    this.gitlab = {
      start: this.startOAuthFlow(OAuthProviders.GitLab)
    };
    this.facebook = {
      start: this.startOAuthFlow(OAuthProviders.Facebook)
    };
    this.discord = {
      start: this.startOAuthFlow(OAuthProviders.Discord)
    };
    this.salesforce = {
      start: this.startOAuthFlow(OAuthProviders.Salesforce)
    };
    this.slack = {
      start: this.startOAuthFlow(OAuthProviders.Slack)
    };
    this.amazon = {
      start: this.startOAuthFlow(OAuthProviders.Amazon)
    };
    this.bitbucket = {
      start: this.startOAuthFlow(OAuthProviders.Bitbucket)
    };
    this.linkedin = {
      start: this.startOAuthFlow(OAuthProviders.LinkedIn)
    };
    this.coinbase = {
      start: this.startOAuthFlow(OAuthProviders.Coinbase)
    };
    this.twitch = {
      start: this.startOAuthFlow(OAuthProviders.Twitch)
    };
    this.twitter = {
      start: this.startOAuthFlow(OAuthProviders.Twitter)
    };
    this.tiktok = {
      start: this.startOAuthFlow(OAuthProviders.TikTok)
    };
    this.snapchat = {
      start: this.startOAuthFlow(OAuthProviders.Snapchat)
    };
    this.figma = {
      start: this.startOAuthFlow(OAuthProviders.Figma)
    };
    this.yahoo = {
      start: this.startOAuthFlow(OAuthProviders.Yahoo)
    };
  }
  _createClass(HeadlessOAuthClient, [{
    key: "authenticate",
    value: function authenticate(token, options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {
        var keyPair, resp;
        return _regeneratorRuntime().wrap(function _callee36$(_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              validate('stytch.oauth.authenticate').isString('Token', token).isNumber('session_duration_minutes', options.session_duration_minutes);
              _context36.next = 3;
              return this._pkceManager.getPKPair();
            case 3:
              keyPair = _context36.sent;
              if (!keyPair) {
                logger.warn('No code verifier found in local storage for OAuth flow.\n' + 'Consider using stytch.oauth.$provider.start() to add PKCE to your OAuth flows for added security.\n' + 'See https://stytch.com/docs/oauth#guides_pkce for more information.');
              }
              _context36.next = 7;
              return this._networkClient.fetchSDK({
                url: '/oauth/authenticate',
                method: 'POST',
                body: Object.assign({
                  token: token,
                  code_verifier: keyPair === null || keyPair === void 0 ? void 0 : keyPair.code_verifier
                }, options),
                errorMessage: 'Failed to authenticate token'
              });
            case 7:
              resp = _context36.sent;
              this._pkceManager.clearPKPair();
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: removeResponseCommon(resp.__user)
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context36.abrupt("return", omitUser(resp));
            case 11:
            case "end":
              return _context36.stop();
          }
        }, _callee36, this);
      }));
    }
  }, {
    key: "getBaseApiUrl",
    value: function getBaseApiUrl() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {
        var _yield$this$_dynamicC, cnameDomain;
        return _regeneratorRuntime().wrap(function _callee37$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              _context37.next = 2;
              return this._dynamicConfig;
            case 2:
              _yield$this$_dynamicC = _context37.sent;
              cnameDomain = _yield$this$_dynamicC.cnameDomain;
              if (!cnameDomain) {
                _context37.next = 6;
                break;
              }
              return _context37.abrupt("return", "https://".concat(cnameDomain));
            case 6:
              if (!isTestPublicToken(this._config.publicToken)) {
                _context37.next = 8;
                break;
              }
              return _context37.abrupt("return", this._config.testAPIURL);
            case 8:
              return _context37.abrupt("return", this._config.liveAPIURL);
            case 9:
            case "end":
              return _context37.stop();
          }
        }, _callee37, this);
      }));
    }
  }, {
    key: "startOAuthFlow",
    value: function startOAuthFlow(providerType) {
      var _this11 = this;
      return function () {
        var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          login_redirect_url = _ref8.login_redirect_url,
          signup_redirect_url = _ref8.signup_redirect_url,
          custom_scopes = _ref8.custom_scopes,
          provider_params = _ref8.provider_params;
        return __awaiter(_this11, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {
          var _yield$this$_dynamicC2, cnameDomain, pkceRequiredForOAuth, baseURL, oauthUrl, keyPair, key;
          return _regeneratorRuntime().wrap(function _callee38$(_context38) {
            while (1) switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this._dynamicConfig;
              case 2:
                _yield$this$_dynamicC2 = _context38.sent;
                cnameDomain = _yield$this$_dynamicC2.cnameDomain;
                pkceRequiredForOAuth = _yield$this$_dynamicC2.pkceRequiredForOAuth;
                _context38.next = 7;
                return this.getBaseApiUrl();
              case 7:
                baseURL = _context38.sent;
                this._networkClient.logEvent({
                  name: 'start_oauth_flow',
                  details: {
                    provider_type: providerType,
                    custom_scopes: custom_scopes,
                    cname_domain: cnameDomain,
                    pkce: pkceRequiredForOAuth,
                    provider_params: provider_params
                  }
                });
                oauthUrl = new URL("".concat(baseURL, "/v1/public/oauth/").concat(providerType, "/start"));
                oauthUrl.searchParams.set('public_token', this._config.publicToken);
                if (!pkceRequiredForOAuth) {
                  _context38.next = 18;
                  break;
                }
                _context38.next = 14;
                return this._pkceManager.startPKCETransaction();
              case 14:
                keyPair = _context38.sent;
                oauthUrl.searchParams.set('code_challenge', keyPair.code_challenge);
                _context38.next = 19;
                break;
              case 18:
                this._pkceManager.clearPKPair();
              case 19:
                if (custom_scopes) {
                  validate('startOAuthFlow').isStringArray('custom_scopes', custom_scopes);
                  oauthUrl.searchParams.set('custom_scopes', custom_scopes.join(' '));
                }
                if (provider_params) {
                  validate('startOAuthFlow').isOptionalObject('provider_params', provider_params);
                  for (key in provider_params) {
                    oauthUrl.searchParams.set('provider_' + key, provider_params[key]);
                  }
                }
                login_redirect_url && oauthUrl.searchParams.set('login_redirect_url', login_redirect_url);
                signup_redirect_url && oauthUrl.searchParams.set('signup_redirect_url', signup_redirect_url);
                window.location.href = oauthUrl.toString();
              case 24:
              case "end":
                return _context38.stop();
            }
          }, _callee38, this);
        }));
      };
    }
  }]);
  return HeadlessOAuthClient;
}();
var HeadlessCryptoWalletClient = /*#__PURE__*/function () {
  function HeadlessCryptoWalletClient(_networkClient, _subscriptionService) {
    var executeRecaptcha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
      return Promise.resolve(undefined);
    };
    var dfpProtectedAuth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DisabledDFPProtectedAuthProvider();
    _classCallCheck(this, HeadlessCryptoWalletClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this.executeRecaptcha = executeRecaptcha;
    this.dfpProtectedAuth = dfpProtectedAuth;
  }
  _createClass(HeadlessCryptoWalletClient, [{
    key: "authenticateStart",
    value: function authenticateStart(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {
        var isLoggedIn, captcha_token, endpoint;
        return _regeneratorRuntime().wrap(function _callee39$(_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              validate('stytch.cryptoWallets.authenticateStart').isString('crypto_wallet_address', options.crypto_wallet_address).isString('crypto_wallet_type', options.crypto_wallet_type);
              isLoggedIn = !!this._subscriptionService.getSession();
              _context39.next = 4;
              return this.executeRecaptcha();
            case 4:
              captcha_token = _context39.sent;
              endpoint = isLoggedIn ? '/crypto_wallets/authenticate/start/secondary' : '/crypto_wallets/authenticate/start/primary';
              return _context39.abrupt("return", this._networkClient.fetchSDK({
                url: endpoint,
                method: 'POST',
                errorMessage: 'Failed to start wallet authentication.',
                body: {
                  crypto_wallet_address: options.crypto_wallet_address,
                  crypto_wallet_type: options.crypto_wallet_type,
                  captcha_token: captcha_token
                }
              }));
            case 7:
            case "end":
              return _context39.stop();
          }
        }, _callee39, this);
      }));
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
        var _yield$this$dfpProtec8, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              validate('stytch.cryptoWallets.authenticate').isString('signature', options.signature).isString('crypto_wallet_address', options.crypto_wallet_address).isString('crypto_wallet_type', options.crypto_wallet_type).isNumber('session_duration_minutes', options.session_duration_minutes);
              _context40.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec8 = _context40.sent;
              dfp_telemetry_id = _yield$this$dfpProtec8.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec8.captcha_token;
              _context40.next = 8;
              return this._networkClient.retriableFetchSDK({
                url: '/crypto_wallets/authenticate',
                method: 'POST',
                errorMessage: 'Failed to authenticate.',
                body: {
                  session_duration_minutes: options.session_duration_minutes,
                  crypto_wallet_address: options.crypto_wallet_address,
                  crypto_wallet_type: options.crypto_wallet_type,
                  signature: options.signature,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 8:
              resp = _context40.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: removeResponseCommon(resp.__user)
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context40.abrupt("return", omitUser(resp));
            case 11:
            case "end":
              return _context40.stop();
          }
        }, _callee40, this);
      }));
    }
  }]);
  return HeadlessCryptoWalletClient;
}();
var HeadlessTOTPClient = /*#__PURE__*/function () {
  function HeadlessTOTPClient(_networkClient, _subscriptionService, dfpProtectedAuth) {
    _classCallCheck(this, HeadlessTOTPClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this.dfpProtectedAuth = dfpProtectedAuth;
  }
  _createClass(HeadlessTOTPClient, [{
    key: "create",
    value: function create(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              validate('stytch.totps.create').isNumber('expiration_minutes', options.expiration_minutes);
              _context41.next = 3;
              return this._networkClient.fetchSDK({
                url: '/totps',
                method: 'POST',
                errorMessage: 'Failed to create TOTP',
                body: {
                  expiration_minutes: options.expiration_minutes
                }
              });
            case 3:
              resp = _context41.sent;
              this._subscriptionService.updateUser(resp.__user);
              return _context41.abrupt("return", omitUser(resp));
            case 6:
            case "end":
              return _context41.stop();
          }
        }, _callee41, this);
      }));
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
        var _yield$this$dfpProtec9, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee42$(_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              validate('stytch.totps.authenticate').isNumber('session_duration_minutes', options.session_duration_minutes).isString('totp_code', options.totp_code);
              _context42.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec9 = _context42.sent;
              dfp_telemetry_id = _yield$this$dfpProtec9.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec9.captcha_token;
              _context42.next = 8;
              return this._networkClient.retriableFetchSDK({
                url: '/totps/authenticate',
                method: 'POST',
                errorMessage: 'Failed to authenticate TOTP',
                body: {
                  session_duration_minutes: options.session_duration_minutes,
                  totp_code: options.totp_code,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 8:
              resp = _context42.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.__user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context42.abrupt("return", omitUser(resp));
            case 11:
            case "end":
              return _context42.stop();
          }
        }, _callee42, this);
      }));
    }
  }, {
    key: "recoveryCodes",
    value: function recoveryCodes() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {
        return _regeneratorRuntime().wrap(function _callee43$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              return _context43.abrupt("return", this._networkClient.fetchSDK({
                url: '/totps/recovery_codes',
                method: 'POST',
                errorMessage: 'Failed to retrieve recovery codes'
              }));
            case 1:
            case "end":
              return _context43.stop();
          }
        }, _callee43, this);
      }));
    }
  }, {
    key: "recover",
    value: function recover(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee44() {
        var _yield$this$dfpProtec10, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee44$(_context44) {
          while (1) switch (_context44.prev = _context44.next) {
            case 0:
              validate('stytch.totps.recover').isNumber('session_duration_minutes', options.session_duration_minutes).isString('recovery_code', options.recovery_code);
              _context44.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec10 = _context44.sent;
              dfp_telemetry_id = _yield$this$dfpProtec10.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec10.captcha_token;
              _context44.next = 8;
              return this._networkClient.retriableFetchSDK({
                url: '/totps/recover',
                method: 'POST',
                errorMessage: 'Failed to recover TOTP',
                body: {
                  session_duration_minutes: options.session_duration_minutes,
                  recovery_code: options.recovery_code,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 8:
              resp = _context44.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.__user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context44.abrupt("return", omitUser(resp));
            case 11:
            case "end":
              return _context44.stop();
          }
        }, _callee44, this);
      }));
    }
  }]);
  return HeadlessTOTPClient;
}(); // src/webauthn-json/base64url.ts
function base64urlToBuffer(baseurl64String) {
  var padding = "==".slice(0, (4 - baseurl64String.length % 4) % 4);
  var base64String = baseurl64String.replace(/-/g, "+").replace(/_/g, "/") + padding;
  var str = atob(base64String);
  var buffer = new ArrayBuffer(str.length);
  var byteView = new Uint8Array(buffer);
  for (var _i = 0; _i < str.length; _i++) {
    byteView[_i] = str.charCodeAt(_i);
  }
  return buffer;
}
function bufferToBase64url(buffer) {
  var byteView = new Uint8Array(buffer);
  var str = "";
  var _iterator2 = _createForOfIteratorHelper(byteView),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var charCode = _step2.value;
      str += String.fromCharCode(charCode);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var base64String = btoa(str);
  var base64urlString = base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return base64urlString;
}
// src/webauthn-json/convert.ts
var copyValue = "copy";
var convertValue = "convert";
function convert(conversionFn, schema2, input) {
  if (schema2 === copyValue) {
    return input;
  }
  if (schema2 === convertValue) {
    return conversionFn(input);
  }
  if (schema2 instanceof Array) {
    return input.map(function (v) {
      return convert(conversionFn, schema2[0], v);
    });
  }
  if (schema2 instanceof Object) {
    var output = {};
    for (var _i2 = 0, _Object$entries = Object.entries(schema2); _i2 < _Object$entries.length; _i2++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        schemaField = _Object$entries$_i[1];
      if (schemaField.derive) {
        var v = schemaField.derive(input);
        if (v !== void 0) {
          input[key] = v;
        }
      }
      if (!(key in input)) {
        if (schemaField.required) {
          throw new Error("Missing key: ".concat(key));
        }
        continue;
      }
      if (input[key] == null) {
        output[key] = null;
        continue;
      }
      output[key] = convert(conversionFn, schemaField.schema, input[key]);
    }
    return output;
  }
}
function derived(schema2, derive) {
  return {
    required: true,
    schema: schema2,
    derive: derive
  };
}
function required(schema2) {
  return {
    required: true,
    schema: schema2
  };
}
function optional(schema2) {
  return {
    required: false,
    schema: schema2
  };
}
// src/webauthn-json/basic/schema.ts
var publicKeyCredentialDescriptorSchema = {
  type: required(copyValue),
  id: required(convertValue),
  transports: optional(copyValue)
};
var simplifiedExtensionsSchema = {
  appid: optional(copyValue),
  appidExclude: optional(copyValue),
  credProps: optional(copyValue)
};
var simplifiedClientExtensionResultsSchema = {
  appid: optional(copyValue),
  appidExclude: optional(copyValue),
  credProps: optional(copyValue)
};
var credentialCreationOptions = {
  publicKey: required({
    rp: required(copyValue),
    user: required({
      id: required(convertValue),
      name: required(copyValue),
      displayName: required(copyValue)
    }),
    challenge: required(convertValue),
    pubKeyCredParams: required(copyValue),
    timeout: optional(copyValue),
    excludeCredentials: optional([publicKeyCredentialDescriptorSchema]),
    authenticatorSelection: optional(copyValue),
    attestation: optional(copyValue),
    extensions: optional(simplifiedExtensionsSchema)
  }),
  signal: optional(copyValue)
};
var publicKeyCredentialWithAttestation = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    attestationObject: required(convertValue),
    transports: derived(copyValue, function (response) {
      var _a;
      return ((_a = response.getTransports) == null ? void 0 : _a.call(response)) || [];
    })
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, function (pkc) {
    return pkc.getClientExtensionResults();
  })
};
var credentialRequestOptions = {
  mediation: optional(copyValue),
  publicKey: required({
    challenge: required(convertValue),
    timeout: optional(copyValue),
    rpId: optional(copyValue),
    allowCredentials: optional([publicKeyCredentialDescriptorSchema]),
    userVerification: optional(copyValue),
    extensions: optional(simplifiedExtensionsSchema)
  }),
  signal: optional(copyValue)
};
var publicKeyCredentialWithAssertion = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    authenticatorData: required(convertValue),
    signature: required(convertValue),
    userHandle: required(convertValue)
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, function (pkc) {
    return pkc.getClientExtensionResults();
  })
};
// src/webauthn-json/basic/api.ts
function createRequestFromJSON(requestJSON) {
  return convert(base64urlToBuffer, credentialCreationOptions, requestJSON);
}
function createResponseToJSON(credential) {
  return convert(bufferToBase64url, publicKeyCredentialWithAttestation, credential);
}
function create(requestJSON) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee45() {
    var credential;
    return _regeneratorRuntime().wrap(function _callee45$(_context45) {
      while (1) switch (_context45.prev = _context45.next) {
        case 0:
          _context45.next = 2;
          return navigator.credentials.create(createRequestFromJSON(requestJSON));
        case 2:
          credential = _context45.sent;
          return _context45.abrupt("return", createResponseToJSON(credential));
        case 4:
        case "end":
          return _context45.stop();
      }
    }, _callee45);
  }));
}
function getRequestFromJSON(requestJSON) {
  return convert(base64urlToBuffer, credentialRequestOptions, requestJSON);
}
function getResponseToJSON(credential) {
  return convert(bufferToBase64url, publicKeyCredentialWithAssertion, credential);
}
function get(requestJSON) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee46() {
    var credential;
    return _regeneratorRuntime().wrap(function _callee46$(_context46) {
      while (1) switch (_context46.prev = _context46.next) {
        case 0:
          _context46.next = 2;
          return navigator.credentials.get(getRequestFromJSON(requestJSON));
        case 2:
          credential = _context46.sent;
          return _context46.abrupt("return", getResponseToJSON(credential));
        case 4:
        case "end":
          return _context46.stop();
      }
    }, _callee46);
  }));
}
var HeadlessWebAuthnClient = /*#__PURE__*/function () {
  function HeadlessWebAuthnClient(_networkClient, _subscriptionService, dfpProtectedAuth) {
    _classCallCheck(this, HeadlessWebAuthnClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this.dfpProtectedAuth = dfpProtectedAuth;
    this.checkEligibleInputs = function () {
      // Check for an <input> with "webauthn" in its `autocomplete` attribute
      var eligibleInputs = document.querySelectorAll("input[autocomplete*='webauthn']");
      // WebAuthn autofill requires at least one valid input
      if (eligibleInputs.length < 1) {
        // eslint-disable-next-line no-console
        console.error('No <input> with `"webauthn"` in its `autocomplete` attribute was detected');
        return false;
      }
      return true;
    };
  }
  _createClass(HeadlessWebAuthnClient, [{
    key: "register",
    value: function register(options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee47() {
        var startResp, publicKeyCredentialCreationOptions, publicKey, credential, resp;
        return _regeneratorRuntime().wrap(function _callee47$(_context47) {
          while (1) switch (_context47.prev = _context47.next) {
            case 0:
              validate('stytch.webauthn.register').isOptionalString('domain', options === null || options === void 0 ? void 0 : options.domain).isOptionalString('authenticator_type', options === null || options === void 0 ? void 0 : options.authenticator_type).isOptionalBoolean('is_passkey', options === null || options === void 0 ? void 0 : options.is_passkey).isOptionalNumber('session_duration_minutes', options === null || options === void 0 ? void 0 : options.session_duration_minutes);
              _context47.next = 3;
              return this._networkClient.fetchSDK({
                url: '/webauthn/register/start',
                method: 'POST',
                errorMessage: 'Failed to start WebAuthn registration',
                body: {
                  domain: (_a = options === null || options === void 0 ? void 0 : options.domain) !== null && _a !== void 0 ? _a : window.location.hostname,
                  authenticator_type: (_b = options === null || options === void 0 ? void 0 : options.authenticator_type) !== null && _b !== void 0 ? _b : undefined,
                  return_passkey_credential_options: options === null || options === void 0 ? void 0 : options.is_passkey,
                  user_agent: navigator.userAgent
                }
              });
            case 3:
              startResp = _context47.sent;
              publicKeyCredentialCreationOptions = startResp.public_key_credential_creation_options;
              publicKey = JSON.parse(publicKeyCredentialCreationOptions);
              _context47.next = 8;
              return create({
                publicKey: publicKey
              });
            case 8:
              credential = _context47.sent;
              _context47.next = 11;
              return this._networkClient.fetchSDK({
                url: '/webauthn/register',
                method: 'POST',
                errorMessage: 'Failed to register WebAuthn device',
                body: {
                  public_key_credential: JSON.stringify(credential),
                  session_duration_minutes: options === null || options === void 0 ? void 0 : options.session_duration_minutes
                }
              });
            case 11:
              resp = _context47.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.__user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context47.abrupt("return", omitUser(resp));
            case 14:
            case "end":
              return _context47.stop();
          }
        }, _callee47, this);
      }));
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee48() {
        var _yield$this$dfpProtec11, dfp_telemetry_id, captcha_token, isLoggedIn, endpoint, startResp, publicKeyCredentialRequestOptions, abortController, credReqOptions, conditionalMediationCredReqOption, credential, authenticationData;
        return _regeneratorRuntime().wrap(function _callee48$(_context48) {
          while (1) switch (_context48.prev = _context48.next) {
            case 0:
              validate('stytch.webauthn.authenticate').isOptionalString('domain', options.domain).isNumber('session_duration_minutes', options.session_duration_minutes).isOptionalBoolean('is_passkey', options.is_passkey).isOptionalObject('signal', options.signal);
              _context48.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec11 = _context48.sent;
              dfp_telemetry_id = _yield$this$dfpProtec11.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec11.captcha_token;
              if (!options.conditional_mediation) {
                _context48.next = 14;
                break;
              }
              _context48.next = 9;
              return this.browserSupportsAutofill();
            case 9:
              if (_context48.sent) {
                _context48.next = 12;
                break;
              }
              // eslint-disable-next-line no-console
              console.error('Browser does not support WebAuthn autofill');
              return _context48.abrupt("return", null);
            case 12:
              if (this.checkEligibleInputs()) {
                _context48.next = 14;
                break;
              }
              return _context48.abrupt("return", null);
            case 14:
              isLoggedIn = !!this._subscriptionService.getSession();
              endpoint = isLoggedIn ? '/webauthn/authenticate/start/secondary' : '/webauthn/authenticate/start/primary';
              _context48.next = 18;
              return this._networkClient.fetchSDK({
                url: endpoint,
                method: 'POST',
                errorMessage: 'Failed to start WebAuthn authentication',
                body: {
                  domain: (_a = options.domain) !== null && _a !== void 0 ? _a : window.location.hostname,
                  return_passkey_credential_options: options === null || options === void 0 ? void 0 : options.is_passkey
                }
              });
            case 18:
              startResp = _context48.sent;
              publicKeyCredentialRequestOptions = startResp.public_key_credential_request_options;
              abortController = new AbortController();
              credReqOptions = {
                publicKey: JSON.parse(publicKeyCredentialRequestOptions),
                signal: (_b = options.signal) !== null && _b !== void 0 ? _b : abortController.signal
              };
              conditionalMediationCredReqOption = Object.assign(Object.assign({}, credReqOptions), {
                mediation: 'conditional'
              });
              _context48.next = 25;
              return get(options.conditional_mediation ? conditionalMediationCredReqOption : credReqOptions);
            case 25:
              credential = _context48.sent;
              _context48.next = 28;
              return this._networkClient.retriableFetchSDK({
                url: '/webauthn/authenticate',
                method: 'POST',
                errorMessage: 'Failed to authenticate WebAuthn device',
                body: {
                  public_key_credential: JSON.stringify(credential),
                  session_duration_minutes: options.session_duration_minutes,
                  dfp_telemetry_id: dfp_telemetry_id,
                  captcha_token: captcha_token
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 28:
              authenticationData = _context48.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: authenticationData.session,
                  user: authenticationData.__user
                },
                session_token: authenticationData.session_token,
                session_jwt: authenticationData.session_jwt,
                intermediate_session_token: null
              });
              return _context48.abrupt("return", omitUser(authenticationData));
            case 31:
            case "end":
              return _context48.stop();
          }
        }, _callee48, this);
      }));
    }
  }, {
    key: "update",
    value: function update(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee49() {
        var url;
        return _regeneratorRuntime().wrap(function _callee49$(_context49) {
          while (1) switch (_context49.prev = _context49.next) {
            case 0:
              url = '/webauthn/update/' + options.webauthn_registration_id;
              _context49.next = 3;
              return this._networkClient.fetchSDK({
                url: url,
                method: 'PUT',
                errorMessage: 'Failed to update WebAuthn Registration',
                body: {
                  name: options.name
                }
              });
            case 3:
              return _context49.abrupt("return", _context49.sent);
            case 4:
            case "end":
              return _context49.stop();
          }
        }, _callee49, this);
      }));
    }
  }, {
    key: "browserSupportsAutofill",
    value: function browserSupportsAutofill() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee50() {
        var globalPublicKeyCredential;
        return _regeneratorRuntime().wrap(function _callee50$(_context50) {
          while (1) switch (_context50.prev = _context50.next) {
            case 0:
              /**
               * TS' DOM lib has not had the chance to catch up with WebAuthn yet. This is a
               * temporary workaround to allow us to use the `isConditionalMediationAvailable`
               */
              globalPublicKeyCredential = window.PublicKeyCredential;
              if (!(globalPublicKeyCredential === undefined || globalPublicKeyCredential.isConditionalMediationAvailable === undefined)) {
                _context50.next = 3;
                break;
              }
              return _context50.abrupt("return", new Promise(function (resolve) {
                return resolve(false);
              }));
            case 3:
              return _context50.abrupt("return", globalPublicKeyCredential.isConditionalMediationAvailable());
            case 4:
            case "end":
              return _context50.stop();
          }
        }, _callee50);
      }));
    }
  }]);
  return HeadlessWebAuthnClient;
}();
var DefaultDynamicConfig$2 = Promise.resolve({
  pkceRequiredForPasswordResets: false
});
var HeadlessPasswordClient = /*#__PURE__*/function () {
  function HeadlessPasswordClient(_networkClient, _subscriptionService, _pkceManager) {
    var _config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultDynamicConfig$2;
    var dfpProtectedAuth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DisabledDFPProtectedAuthProvider();
    _classCallCheck(this, HeadlessPasswordClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._config = _config;
    this.dfpProtectedAuth = dfpProtectedAuth;
  }
  _createClass(HeadlessPasswordClient, [{
    key: "getCodeChallenge",
    value: function getCodeChallenge() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee51() {
        var _yield$this$_config3, pkceRequiredForPasswordResets, keyPair;
        return _regeneratorRuntime().wrap(function _callee51$(_context51) {
          while (1) switch (_context51.prev = _context51.next) {
            case 0:
              _context51.next = 2;
              return this._config;
            case 2:
              _yield$this$_config3 = _context51.sent;
              pkceRequiredForPasswordResets = _yield$this$_config3.pkceRequiredForPasswordResets;
              if (pkceRequiredForPasswordResets) {
                _context51.next = 6;
                break;
              }
              return _context51.abrupt("return", undefined);
            case 6:
              _context51.next = 8;
              return this._pkceManager.getPKPair();
            case 8:
              keyPair = _context51.sent;
              if (!keyPair) {
                _context51.next = 11;
                break;
              }
              return _context51.abrupt("return", keyPair.code_challenge);
            case 11:
              _context51.next = 13;
              return this._pkceManager.startPKCETransaction();
            case 13:
              keyPair = _context51.sent;
              return _context51.abrupt("return", keyPair.code_challenge);
            case 15:
            case "end":
              return _context51.stop();
          }
        }, _callee51, this);
      }));
    }
  }, {
    key: "create",
    value: function create(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee52() {
        var _yield$this$dfpProtec12, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee52$(_context52) {
          while (1) switch (_context52.prev = _context52.next) {
            case 0:
              validate('stytch.passwords.create').isString('password', options.password).isString('email', options.email).isNumber('session_duration_minutes', options.session_duration_minutes);
              _context52.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec12 = _context52.sent;
              dfp_telemetry_id = _yield$this$dfpProtec12.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec12.captcha_token;
              _context52.next = 8;
              return this._networkClient.retriableFetchSDK({
                url: '/passwords',
                method: 'POST',
                errorMessage: 'Failed to create password.',
                body: {
                  email: options.email,
                  password: options.password,
                  session_duration_minutes: options.session_duration_minutes,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 8:
              resp = _context52.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context52.abrupt("return", omitUser(resp));
            case 11:
            case "end":
              return _context52.stop();
          }
        }, _callee52, this);
      }));
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee53() {
        var _yield$this$dfpProtec13, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee53$(_context53) {
          while (1) switch (_context53.prev = _context53.next) {
            case 0:
              validate('stytch.passwords.authenticate').isString('password', options.password).isString('email', options.email).isNumber('session_duration_minutes', options.session_duration_minutes);
              _context53.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec13 = _context53.sent;
              dfp_telemetry_id = _yield$this$dfpProtec13.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec13.captcha_token;
              _context53.next = 8;
              return this._networkClient.retriableFetchSDK({
                url: '/passwords/authenticate',
                method: 'POST',
                errorMessage: 'Failed to authenticate password.',
                body: {
                  email: options.email,
                  password: options.password,
                  session_duration_minutes: options.session_duration_minutes,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 8:
              resp = _context53.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context53.abrupt("return", omitUser(resp));
            case 11:
            case "end":
              return _context53.stop();
          }
        }, _callee53, this);
      }));
    }
  }, {
    key: "resetByEmailStart",
    value: function resetByEmailStart(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee54() {
        var code_challenge, _yield$this$dfpProtec14, dfp_telemetry_id, captcha_token;
        return _regeneratorRuntime().wrap(function _callee54$(_context54) {
          while (1) switch (_context54.prev = _context54.next) {
            case 0:
              validate('stytch.passwords.resetByEmailStart').isString('email', options.email).isOptionalString('login_redirect_url', options.login_redirect_url).isOptionalString('reset_password_redirect_url', options.reset_password_redirect_url).isOptionalString('reset_password_template_id', options.reset_password_template_id).isOptionalNumber('reset_password_expiration_minutes', options.reset_password_expiration_minutes);
              _context54.next = 3;
              return this.getCodeChallenge();
            case 3:
              code_challenge = _context54.sent;
              _context54.next = 6;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 6:
              _yield$this$dfpProtec14 = _context54.sent;
              dfp_telemetry_id = _yield$this$dfpProtec14.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec14.captcha_token;
              return _context54.abrupt("return", this._networkClient.retriableFetchSDK({
                url: '/passwords/email/reset/start',
                method: 'POST',
                errorMessage: 'Failed to start password reset flow.',
                body: {
                  email: options.email,
                  login_redirect_url: options.login_redirect_url,
                  reset_password_redirect_url: options.reset_password_redirect_url,
                  reset_password_expiration_minutes: options.reset_password_expiration_minutes,
                  reset_password_template_id: options.reset_password_template_id,
                  code_challenge: code_challenge,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              }));
            case 10:
            case "end":
              return _context54.stop();
          }
        }, _callee54, this);
      }));
    }
  }, {
    key: "resetByEmail",
    value: function resetByEmail(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee55() {
        var _yield$this$dfpProtec15, dfp_telemetry_id, captcha_token, pkPair, code_verifier, resp;
        return _regeneratorRuntime().wrap(function _callee55$(_context55) {
          while (1) switch (_context55.prev = _context55.next) {
            case 0:
              validate('stytch.passwords.resetByEmail').isString('token', options.token).isString('password', options.password).isNumber('session_duration_minutes', options.session_duration_minutes);
              _context55.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec15 = _context55.sent;
              dfp_telemetry_id = _yield$this$dfpProtec15.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec15.captcha_token;
              _context55.next = 8;
              return this._pkceManager.getPKPair();
            case 8:
              pkPair = _context55.sent;
              code_verifier = pkPair === null || pkPair === void 0 ? void 0 : pkPair.code_verifier;
              _context55.next = 12;
              return this._networkClient.retriableFetchSDK({
                url: '/passwords/email/reset',
                method: 'POST',
                errorMessage: 'Failed to reset password.',
                body: {
                  token: options.token,
                  password: options.password,
                  session_duration_minutes: options.session_duration_minutes,
                  captcha_token: captcha_token,
                  code_verifier: code_verifier,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 12:
              resp = _context55.sent;
              this._pkceManager.clearPKPair();
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context55.abrupt("return", omitUser(resp));
            case 16:
            case "end":
              return _context55.stop();
          }
        }, _callee55, this);
      }));
    }
  }, {
    key: "resetByExistingPassword",
    value: function resetByExistingPassword(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee56() {
        var _yield$this$dfpProtec16, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee56$(_context56) {
          while (1) switch (_context56.prev = _context56.next) {
            case 0:
              validate('stytch.passwords.resetByExistingPassword').isString('email', options.email).isString('existing_password', options.existing_password).isString('new_password', options.new_password).isNumber('session_duration_minutes', options.session_duration_minutes);
              _context56.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec16 = _context56.sent;
              dfp_telemetry_id = _yield$this$dfpProtec16.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec16.captcha_token;
              _context56.next = 8;
              return this._networkClient.retriableFetchSDK({
                url: '/passwords/existing_password/reset',
                method: 'POST',
                errorMessage: 'Failed to reset password.',
                body: {
                  email: options.email,
                  existing_password: options.existing_password,
                  new_password: options.new_password,
                  session_duration_minutes: options.session_duration_minutes,
                  dfp_telemetry_id: dfp_telemetry_id,
                  captcha_token: captcha_token
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 8:
              resp = _context56.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context56.abrupt("return", omitUser(resp));
            case 11:
            case "end":
              return _context56.stop();
          }
        }, _callee56, this);
      }));
    }
  }, {
    key: "resetBySession",
    value: function resetBySession(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee57() {
        var _yield$this$dfpProtec17, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee57$(_context57) {
          while (1) switch (_context57.prev = _context57.next) {
            case 0:
              validate('stytch.passwords.resetBySession').isString('password', options.password);
              _context57.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec17 = _context57.sent;
              dfp_telemetry_id = _yield$this$dfpProtec17.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec17.captcha_token;
              _context57.next = 8;
              return this._networkClient.retriableFetchSDK({
                url: '/passwords/session/reset',
                method: 'POST',
                errorMessage: 'Failed to reset by session.',
                body: {
                  password: options.password,
                  session_duration_minutes: options.session_duration_minutes,
                  dfp_telemetry_id: dfp_telemetry_id,
                  captcha_token: captcha_token
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 8:
              resp = _context57.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.session,
                  user: resp.user
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context57.abrupt("return", resp);
            case 11:
            case "end":
              return _context57.stop();
          }
        }, _callee57, this);
      }));
    }
  }, {
    key: "strengthCheck",
    value: function strengthCheck(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee58() {
        return _regeneratorRuntime().wrap(function _callee58$(_context58) {
          while (1) switch (_context58.prev = _context58.next) {
            case 0:
              validate('stytch.passwords.strengthCheck').isOptionalString('email', options.email).isString('password', options.password);
              return _context58.abrupt("return", this._networkClient.fetchSDK({
                url: '/passwords/strength_check',
                method: 'POST',
                errorMessage: 'Failed to check password strength.',
                body: {
                  email: options.email,
                  password: options.password
                }
              }));
            case 2:
            case "end":
              return _context58.stop();
          }
        }, _callee58, this);
      }));
    }
  }]);
  return HeadlessPasswordClient;
}();
var DefaultDynamicConfig$1 = Promise.resolve({
  pkceRequiredForEmailMagicLinks: false
});
var HeadlessB2BMagicLinksClient = /*#__PURE__*/function () {
  function HeadlessB2BMagicLinksClient(_networkClient, _subscriptionService, _pkceManager, _passwordResetPKCEManager) {
    var _this12 = this;
    var _config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DefaultDynamicConfig$1;
    var dfpProtectedAuth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : DisabledDFPProtectedAuthProvider();
    _classCallCheck(this, HeadlessB2BMagicLinksClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._passwordResetPKCEManager = _passwordResetPKCEManager;
    this._config = _config;
    this.dfpProtectedAuth = dfpProtectedAuth;
    this.email = {
      invite: function invite(data) {
        return __awaiter(_this12, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee59() {
          return _regeneratorRuntime().wrap(function _callee59$(_context59) {
            while (1) switch (_context59.prev = _context59.next) {
              case 0:
                validate('stytch.magicLinks.email.loginOrSignup').isString('email_address', data.email_address).isOptionalString('invite_redirect_url', data.invite_redirect_url).isOptionalString('invite_template_id', data.invite_template_id).isOptionalString('name', data.name).isOptionalString('locale', data.locale).isOptionalStringArray('roles', data.roles);
                return _context59.abrupt("return", this._networkClient.fetchSDK({
                  url: '/b2b/magic_links/email/invite',
                  body: data,
                  errorMessage: 'Failed to send invite.',
                  method: 'POST'
                }));
              case 2:
              case "end":
                return _context59.stop();
            }
          }, _callee59, this);
        }));
      },
      loginOrSignup: function loginOrSignup(data) {
        return __awaiter(_this12, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee60() {
          var pkce_code_challenge, requestBody;
          return _regeneratorRuntime().wrap(function _callee60$(_context60) {
            while (1) switch (_context60.prev = _context60.next) {
              case 0:
                validate('stytch.magicLinks.email.loginOrSignup').isString('email_address', data.email_address).isString('organization_id', data.organization_id).isOptionalString('login_redirect_url', data.login_redirect_url).isOptionalString('login_template_id', data.login_template_id).isOptionalString('signup_redirect_url', data.signup_redirect_url).isOptionalString('signup_template_id', data.signup_template_id).isOptionalString('locale', data.locale);
                _context60.next = 3;
                return this.getCodeChallenge();
              case 3:
                pkce_code_challenge = _context60.sent;
                requestBody = Object.assign(Object.assign({}, data), {
                  pkce_code_challenge: pkce_code_challenge
                });
                return _context60.abrupt("return", this._networkClient.fetchSDK({
                  url: '/b2b/magic_links/email/login_or_signup',
                  body: requestBody,
                  errorMessage: 'Failed to send magic link',
                  method: 'POST'
                }));
              case 6:
              case "end":
                return _context60.stop();
            }
          }, _callee60, this);
        }));
      },
      discovery: {
        send: function send(data) {
          return __awaiter(_this12, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee61() {
            var pkce_code_challenge, requestBody;
            return _regeneratorRuntime().wrap(function _callee61$(_context61) {
              while (1) switch (_context61.prev = _context61.next) {
                case 0:
                  validate('stytch.magicLinks.email.discovery.send').isString('email_address', data.email_address).isOptionalString('discovery_redirect_url', data.discovery_redirect_url).isOptionalString('login_template_id', data.login_template_id).isOptionalString('locale', data.locale);
                  _context61.next = 3;
                  return this.getCodeChallenge();
                case 3:
                  pkce_code_challenge = _context61.sent;
                  requestBody = Object.assign(Object.assign({}, data), {
                    pkce_code_challenge: pkce_code_challenge
                  });
                  return _context61.abrupt("return", this._networkClient.fetchSDK({
                    url: '/b2b/magic_links/email/discovery/send',
                    body: requestBody,
                    errorMessage: 'Failed to send discovery magic link',
                    method: 'POST'
                  }));
                case 6:
                case "end":
                  return _context61.stop();
              }
            }, _callee61, this);
          }));
        }
      }
    };
    this.authenticate = function (data) {
      return __awaiter(_this12, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee62() {
        var passwordResetPKPair, resp;
        return _regeneratorRuntime().wrap(function _callee62$(_context62) {
          while (1) switch (_context62.prev = _context62.next) {
            case 0:
              validate('stytch.magicLinks.authenticate').isString('magic_links_token', data.magic_links_token).isNumber('session_duration_minutes', data.session_duration_minutes).isOptionalString('locale', data.locale);
              // When a user resets their password with PKCE turned on, they create a pkPair in the 'passwords' namespace.
              // However, when the user gets the reset password email, they have the option to log in without a password.
              // This redirects them to the magic link authenticate flow, which automatically looks for the pkce code_verifier
              // in the 'magic_links' namespace, breaking the flow. Unfortunately we won't know for sure in the eml authenticate call
              // whether or not the user is coming from a password reset flow. To handle this, we have to try to authenticate with
              // both the 'passwords' and 'magic_links' code_verifiers.
              _context62.next = 3;
              return this._passwordResetPKCEManager.getPKPair();
            case 3:
              passwordResetPKPair = _context62.sent;
              resp = null;
              if (!(passwordResetPKPair === null || passwordResetPKPair === void 0 ? void 0 : passwordResetPKPair.code_verifier)) {
                _context62.next = 19;
                break;
              }
              _context62.prev = 6;
              _context62.next = 9;
              return this.handlePKCEForAuthenticate(this._passwordResetPKCEManager, data);
            case 9:
              resp = _context62.sent;
              _context62.next = 19;
              break;
            case 12:
              _context62.prev = 12;
              _context62.t0 = _context62["catch"](6);
              if (!_context62.t0.message.includes('pkce')) {
                _context62.next = 18;
                break;
              }
              // If pkce-related error, fall back to magic links code_verifier
              // eslint-disable-next-line no-console
              console.log('Authenticate with passwords pkce namespace failed. Falling back to authenticate with magic_links namespace.');
              _context62.next = 19;
              break;
            case 18:
              throw _context62.t0;
            case 19:
              if (resp) {
                _context62.next = 23;
                break;
              }
              _context62.next = 22;
              return this.handlePKCEForAuthenticate(this._pkceManager, data);
            case 22:
              resp = _context62.sent;
            case 23:
              if (resp.member_session) {
                this._subscriptionService.updateStateAndTokens({
                  state: {
                    session: resp.member_session,
                    member: resp.member
                  },
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt,
                  intermediate_session_token: null
                });
              } else {
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
              }
              return _context62.abrupt("return", resp);
            case 25:
            case "end":
              return _context62.stop();
          }
        }, _callee62, this, [[6, 12]]);
      }));
    };
    this.discovery = {
      authenticate: function authenticate(data) {
        return __awaiter(_this12, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee63() {
          var pkPair, _yield$this$dfpProtec18, dfp_telemetry_id, captcha_token, requestBody, resp;
          return _regeneratorRuntime().wrap(function _callee63$(_context63) {
            while (1) switch (_context63.prev = _context63.next) {
              case 0:
                validate('stytch.magicLinks.discovery.authenticate').isString('discovery_magic_links_token', data.discovery_magic_links_token);
                _context63.next = 3;
                return this._pkceManager.getPKPair();
              case 3:
                pkPair = _context63.sent;
                _context63.next = 6;
                return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
              case 6:
                _yield$this$dfpProtec18 = _context63.sent;
                dfp_telemetry_id = _yield$this$dfpProtec18.dfp_telemetry_id;
                captcha_token = _yield$this$dfpProtec18.captcha_token;
                requestBody = Object.assign({
                  pkce_code_verifier: pkPair === null || pkPair === void 0 ? void 0 : pkPair.code_verifier,
                  dfp_telemetry_id: dfp_telemetry_id,
                  captcha_token: captcha_token
                }, data);
                _context63.next = 12;
                return this._networkClient.retriableFetchSDK({
                  url: '/b2b/magic_links/discovery/authenticate',
                  body: requestBody,
                  errorMessage: 'Failed to authenticate intermediate magic link token',
                  method: 'POST',
                  retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
                });
              case 12:
                resp = _context63.sent;
                this._pkceManager.clearPKPair();
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
                return _context63.abrupt("return", resp);
              case 16:
              case "end":
                return _context63.stop();
            }
          }, _callee63, this);
        }));
      }
    };
  }
  _createClass(HeadlessB2BMagicLinksClient, [{
    key: "getCodeChallenge",
    value: function getCodeChallenge() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee64() {
        var _yield$this$_config4, pkceRequiredForEmailMagicLinks, keyPair;
        return _regeneratorRuntime().wrap(function _callee64$(_context64) {
          while (1) switch (_context64.prev = _context64.next) {
            case 0:
              _context64.next = 2;
              return this._config;
            case 2:
              _yield$this$_config4 = _context64.sent;
              pkceRequiredForEmailMagicLinks = _yield$this$_config4.pkceRequiredForEmailMagicLinks;
              if (pkceRequiredForEmailMagicLinks) {
                _context64.next = 6;
                break;
              }
              return _context64.abrupt("return", undefined);
            case 6:
              _context64.next = 8;
              return this._pkceManager.getPKPair();
            case 8:
              keyPair = _context64.sent;
              if (!keyPair) {
                _context64.next = 11;
                break;
              }
              return _context64.abrupt("return", keyPair.code_challenge);
            case 11:
              _context64.next = 13;
              return this._pkceManager.startPKCETransaction();
            case 13:
              keyPair = _context64.sent;
              return _context64.abrupt("return", keyPair.code_challenge);
            case 15:
            case "end":
              return _context64.stop();
          }
        }, _callee64, this);
      }));
    }
  }, {
    key: "handlePKCEForAuthenticate",
    value: function handlePKCEForAuthenticate(pkceManager, data) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee65() {
        var pkPair, _yield$this$dfpProtec19, dfp_telemetry_id, captcha_token, requestBody, resp;
        return _regeneratorRuntime().wrap(function _callee65$(_context65) {
          while (1) switch (_context65.prev = _context65.next) {
            case 0:
              _context65.next = 2;
              return pkceManager.getPKPair();
            case 2:
              pkPair = _context65.sent;
              _context65.next = 5;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 5:
              _yield$this$dfpProtec19 = _context65.sent;
              dfp_telemetry_id = _yield$this$dfpProtec19.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec19.captcha_token;
              requestBody = Object.assign({
                pkce_code_verifier: pkPair === null || pkPair === void 0 ? void 0 : pkPair.code_verifier,
                dfp_telemetry_id: dfp_telemetry_id,
                captcha_token: captcha_token
              }, data);
              _context65.next = 11;
              return this._networkClient.retriableFetchSDK({
                url: '/b2b/magic_links/authenticate',
                body: requestBody,
                errorMessage: 'Failed to authenticate token',
                method: 'POST',
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 11:
              resp = _context65.sent;
              pkceManager.clearPKPair();
              return _context65.abrupt("return", resp);
            case 14:
            case "end":
              return _context65.stop();
          }
        }, _callee65, this);
      }));
    }
  }]);
  return HeadlessB2BMagicLinksClient;
}();
var HeadlessB2BSelfClient = /*#__PURE__*/_createClass(function HeadlessB2BSelfClient(_networkClient, _subscriptionService) {
  var _this13 = this;
  _classCallCheck(this, HeadlessB2BSelfClient);
  this._networkClient = _networkClient;
  this._subscriptionService = _subscriptionService;
  this.get = function () {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee66() {
      var resp;
      return _regeneratorRuntime().wrap(function _callee66$(_context66) {
        while (1) switch (_context66.prev = _context66.next) {
          case 0:
            _context66.next = 2;
            return this._networkClient.fetchSDK({
              url: "/b2b/organizations/members/me",
              errorMessage: 'Failed to retrieve member info.',
              method: 'GET'
            });
          case 2:
            resp = _context66.sent;
            this._subscriptionService.updateMember(resp.member);
            return _context66.abrupt("return", resp.member);
          case 5:
          case "end":
            return _context66.stop();
        }
      }, _callee66, this);
    }));
  };
  this.getSync = function () {
    return _this13._subscriptionService.getMember();
  };
  this.onChange = function (callback) {
    return _this13._subscriptionService.subscribeToState(function (state) {
      var _a;
      return callback((_a = state === null || state === void 0 ? void 0 : state.member) !== null && _a !== void 0 ? _a : null);
    });
  };
  this.update = function (data) {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee67() {
      var resp;
      return _regeneratorRuntime().wrap(function _callee67$(_context67) {
        while (1) switch (_context67.prev = _context67.next) {
          case 0:
            validate('stytch.self.update').isOptionalString('name', data.name).isOptionalObject('untrusted_metadata', data.untrusted_metadata).isOptionalBoolean('mfa_enrolled', data.mfa_enrolled).isOptionalString('mfa_phone_number', data.mfa_phone_number);
            _context67.next = 3;
            return this._networkClient.fetchSDK({
              url: '/b2b/organizations/members/update',
              body: data,
              errorMessage: 'Failed to update member.',
              method: 'PUT'
            });
          case 3:
            resp = _context67.sent;
            this._subscriptionService.updateMember(resp.member);
            return _context67.abrupt("return", resp);
          case 6:
          case "end":
            return _context67.stop();
        }
      }, _callee67, this);
    }));
  };
  this.deleteMFAPhoneNumber = function () {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee68() {
      var resp;
      return _regeneratorRuntime().wrap(function _callee68$(_context68) {
        while (1) switch (_context68.prev = _context68.next) {
          case 0:
            _context68.next = 2;
            return this._networkClient.fetchSDK({
              url: '/b2b/organizations/members/deletePhoneNumber',
              errorMessage: 'Failed to delete member phone number.',
              method: 'DELETE'
            });
          case 2:
            resp = _context68.sent;
            this._subscriptionService.updateMember(resp.member);
            return _context68.abrupt("return", resp);
          case 5:
          case "end":
            return _context68.stop();
        }
      }, _callee68, this);
    }));
  };
  this.deletePassword = function (passwordId) {
    return __awaiter(_this13, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee69() {
      var resp;
      return _regeneratorRuntime().wrap(function _callee69$(_context69) {
        while (1) switch (_context69.prev = _context69.next) {
          case 0:
            _context69.next = 2;
            return this._networkClient.fetchSDK({
              url: "/b2b/organizations/members/passwords/".concat(passwordId),
              errorMessage: 'Failed to delete member password.',
              method: 'DELETE'
            });
          case 2:
            resp = _context69.sent;
            this._subscriptionService.updateMember(resp.member);
            return _context69.abrupt("return", resp);
          case 5:
          case "end":
            return _context69.stop();
        }
      }, _callee69, this);
    }));
  };
});
var HeadlessB2BSSOClient = /*#__PURE__*/function () {
  function HeadlessB2BSSOClient(_networkClient, _subscriptionService, _pkceManager, _dynamicConfig, _config) {
    var _this14 = this;
    var dfpProtectedAuth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : DisabledDFPProtectedAuthProvider();
    _classCallCheck(this, HeadlessB2BSSOClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._dynamicConfig = _dynamicConfig;
    this._config = _config;
    this.dfpProtectedAuth = dfpProtectedAuth;
    this.saml = {
      createConnection: function createConnection(data) {
        return __awaiter(_this14, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee70() {
          return _regeneratorRuntime().wrap(function _callee70$(_context70) {
            while (1) switch (_context70.prev = _context70.next) {
              case 0:
                _context70.next = 2;
                return this._networkClient.fetchSDK({
                  url: '/b2b/sso/saml',
                  method: 'POST',
                  body: data,
                  errorMessage: 'Failed to create SAML Connection.'
                });
              case 2:
                return _context70.abrupt("return", _context70.sent);
              case 3:
              case "end":
                return _context70.stop();
            }
          }, _callee70, this);
        }));
      },
      updateConnection: function updateConnection(data) {
        return __awaiter(_this14, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee71() {
          return _regeneratorRuntime().wrap(function _callee71$(_context71) {
            while (1) switch (_context71.prev = _context71.next) {
              case 0:
                _context71.next = 2;
                return this._networkClient.fetchSDK({
                  url: "/b2b/sso/saml/".concat(data.connection_id),
                  method: 'PUT',
                  body: data,
                  errorMessage: 'Failed to update SAML Connection.'
                });
              case 2:
                return _context71.abrupt("return", _context71.sent);
              case 3:
              case "end":
                return _context71.stop();
            }
          }, _callee71, this);
        }));
      },
      updateConnectionByURL: function updateConnectionByURL(data) {
        return __awaiter(_this14, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee72() {
          return _regeneratorRuntime().wrap(function _callee72$(_context72) {
            while (1) switch (_context72.prev = _context72.next) {
              case 0:
                _context72.next = 2;
                return this._networkClient.fetchSDK({
                  url: "/b2b/sso/saml/".concat(data.connection_id, "/url"),
                  method: 'PUT',
                  body: data,
                  errorMessage: 'Failed to update SAML Connection.'
                });
              case 2:
                return _context72.abrupt("return", _context72.sent);
              case 3:
              case "end":
                return _context72.stop();
            }
          }, _callee72, this);
        }));
      },
      deleteVerificationCertificate: function deleteVerificationCertificate(data) {
        return __awaiter(_this14, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee73() {
          return _regeneratorRuntime().wrap(function _callee73$(_context73) {
            while (1) switch (_context73.prev = _context73.next) {
              case 0:
                _context73.next = 2;
                return this._networkClient.fetchSDK({
                  url: "/b2b/sso/saml/".concat(data.connection_id, "/verification_certificates/").concat(data.certificate_id),
                  method: 'DELETE',
                  errorMessage: 'Failed to delete SAML Verification Certificate.'
                });
              case 2:
                return _context73.abrupt("return", _context73.sent);
              case 3:
              case "end":
                return _context73.stop();
            }
          }, _callee73, this);
        }));
      }
    };
    this.oidc = {
      createConnection: function createConnection(data) {
        return __awaiter(_this14, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee74() {
          return _regeneratorRuntime().wrap(function _callee74$(_context74) {
            while (1) switch (_context74.prev = _context74.next) {
              case 0:
                _context74.next = 2;
                return this._networkClient.fetchSDK({
                  url: '/b2b/sso/oidc',
                  method: 'POST',
                  body: data,
                  errorMessage: 'Failed to create OIDC Connection.'
                });
              case 2:
                return _context74.abrupt("return", _context74.sent);
              case 3:
              case "end":
                return _context74.stop();
            }
          }, _callee74, this);
        }));
      },
      updateConnection: function updateConnection(data) {
        return __awaiter(_this14, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee75() {
          return _regeneratorRuntime().wrap(function _callee75$(_context75) {
            while (1) switch (_context75.prev = _context75.next) {
              case 0:
                _context75.next = 2;
                return this._networkClient.fetchSDK({
                  url: "/b2b/sso/oidc/".concat(data.connection_id),
                  method: 'PUT',
                  body: data,
                  errorMessage: 'Failed to update OIDC Connection.'
                });
              case 2:
                return _context75.abrupt("return", _context75.sent);
              case 3:
              case "end":
                return _context75.stop();
            }
          }, _callee75, this);
        }));
      }
    };
  }
  _createClass(HeadlessB2BSSOClient, [{
    key: "authenticate",
    value: function authenticate(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee76() {
        var keyPair, _yield$this$dfpProtec20, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee76$(_context76) {
          while (1) switch (_context76.prev = _context76.next) {
            case 0:
              validate('stytch.sso.authenticate').isString('sso_token', options.sso_token).isNumber('session_duration_minutes', options.session_duration_minutes).isOptionalString('locale', options.locale);
              _context76.next = 3;
              return this._pkceManager.getPKPair();
            case 3:
              keyPair = _context76.sent;
              if (!keyPair) {
                logger.warn('No code verifier found in local storage for SSO flow.\n' + 'Consider using stytch.sso.start() to add PKCE to your SSO flows for added security.\n' + 'See https://stytch.com/docs/oauth#guides_pkce for more information.');
              }
              _context76.next = 7;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 7:
              _yield$this$dfpProtec20 = _context76.sent;
              dfp_telemetry_id = _yield$this$dfpProtec20.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec20.captcha_token;
              _context76.next = 12;
              return this._networkClient.retriableFetchSDK({
                url: '/b2b/sso/authenticate',
                method: 'POST',
                body: Object.assign(Object.assign({
                  pkce_code_verifier: keyPair === null || keyPair === void 0 ? void 0 : keyPair.code_verifier
                }, options), {
                  dfp_telemetry_id: dfp_telemetry_id,
                  captcha_token: captcha_token
                }),
                errorMessage: 'Failed to authenticate token',
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 12:
              resp = _context76.sent;
              this._pkceManager.clearPKPair();
              if (resp.member_session) {
                this._subscriptionService.updateStateAndTokens({
                  state: {
                    session: resp.member_session,
                    member: resp.member
                  },
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt,
                  intermediate_session_token: null
                });
              } else {
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
              }
              return _context76.abrupt("return", resp);
            case 16:
            case "end":
              return _context76.stop();
          }
        }, _callee76, this);
      }));
    }
  }, {
    key: "getBaseApiUrl",
    value: function getBaseApiUrl() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee77() {
        return _regeneratorRuntime().wrap(function _callee77$(_context77) {
          while (1) switch (_context77.prev = _context77.next) {
            case 0:
              if (!isTestPublicToken(this._config.publicToken)) {
                _context77.next = 2;
                break;
              }
              return _context77.abrupt("return", this._config.testAPIURL);
            case 2:
              return _context77.abrupt("return", this._config.liveAPIURL);
            case 3:
            case "end":
              return _context77.stop();
          }
        }, _callee77, this);
      }));
    }
  }, {
    key: "start",
    value: function start(_ref9) {
      var connection_id = _ref9.connection_id,
        login_redirect_url = _ref9.login_redirect_url,
        signup_redirect_url = _ref9.signup_redirect_url;
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee78() {
        var _yield$this$_dynamicC3, pkceRequiredForSso, baseURL, startUrl, keyPair;
        return _regeneratorRuntime().wrap(function _callee78$(_context78) {
          while (1) switch (_context78.prev = _context78.next) {
            case 0:
              _context78.next = 2;
              return this._dynamicConfig;
            case 2:
              _yield$this$_dynamicC3 = _context78.sent;
              pkceRequiredForSso = _yield$this$_dynamicC3.pkceRequiredForSso;
              _context78.next = 6;
              return this.getBaseApiUrl();
            case 6:
              baseURL = _context78.sent;
              startUrl = new URL("".concat(baseURL, "/v1/public/sso/start"));
              startUrl.searchParams.set('public_token', this._config.publicToken);
              startUrl.searchParams.set('connection_id', connection_id);
              if (!pkceRequiredForSso) {
                _context78.next = 17;
                break;
              }
              _context78.next = 13;
              return this._pkceManager.startPKCETransaction();
            case 13:
              keyPair = _context78.sent;
              startUrl.searchParams.set('pkce_code_challenge', keyPair.code_challenge);
              _context78.next = 18;
              break;
            case 17:
              this._pkceManager.clearPKPair();
            case 18:
              login_redirect_url && startUrl.searchParams.set('login_redirect_url', login_redirect_url);
              signup_redirect_url && startUrl.searchParams.set('signup_redirect_url', signup_redirect_url);
              window.location.href = startUrl.toString();
            case 21:
            case "end":
              return _context78.stop();
          }
        }, _callee78, this);
      }));
    }
  }, {
    key: "getConnections",
    value: function getConnections() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee79() {
        return _regeneratorRuntime().wrap(function _callee79$(_context79) {
          while (1) switch (_context79.prev = _context79.next) {
            case 0:
              _context79.next = 2;
              return this._networkClient.fetchSDK({
                url: '/b2b/sso',
                method: 'GET',
                errorMessage: 'Failed to get SSO Connections.'
              });
            case 2:
              return _context79.abrupt("return", _context79.sent);
            case 3:
            case "end":
              return _context79.stop();
          }
        }, _callee79, this);
      }));
    }
  }, {
    key: "deleteConnection",
    value: function deleteConnection(connectionId) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee80() {
        return _regeneratorRuntime().wrap(function _callee80$(_context80) {
          while (1) switch (_context80.prev = _context80.next) {
            case 0:
              return _context80.abrupt("return", this._networkClient.fetchSDK({
                url: "/b2b/sso/".concat(connectionId),
                method: 'DELETE',
                errorMessage: 'Failed to delete SSO Connection.'
              }));
            case 1:
            case "end":
              return _context80.stop();
          }
        }, _callee80, this);
      }));
    }
  }]);
  return HeadlessB2BSSOClient;
}();
var HeadlessB2BOrganizationClient = /*#__PURE__*/_createClass(function HeadlessB2BOrganizationClient(_networkClient, _subscriptionService) {
  var _this15 = this;
  _classCallCheck(this, HeadlessB2BOrganizationClient);
  this._networkClient = _networkClient;
  this._subscriptionService = _subscriptionService;
  this.get = function () {
    return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee81() {
      var resp;
      return _regeneratorRuntime().wrap(function _callee81$(_context81) {
        while (1) switch (_context81.prev = _context81.next) {
          case 0:
            _context81.next = 2;
            return this._networkClient.fetchSDK({
              url: "/b2b/organizations/me",
              errorMessage: 'Failed to retrieve organization info.',
              method: 'GET'
            });
          case 2:
            resp = _context81.sent;
            return _context81.abrupt("return", resp.organization);
          case 4:
          case "end":
            return _context81.stop();
        }
      }, _callee81, this);
    }));
  };
  this.update = function (data) {
    return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee82() {
      var resp;
      return _regeneratorRuntime().wrap(function _callee82$(_context82) {
        while (1) switch (_context82.prev = _context82.next) {
          case 0:
            _context82.next = 2;
            return this._networkClient.fetchSDK({
              url: "/b2b/organizations/me",
              errorMessage: 'Failed to update organization info.',
              method: 'PUT',
              body: data
            });
          case 2:
            resp = _context82.sent;
            return _context82.abrupt("return", resp);
          case 4:
          case "end":
            return _context82.stop();
        }
      }, _callee82, this);
    }));
  };
  this["delete"] = function () {
    return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee83() {
      var resp;
      return _regeneratorRuntime().wrap(function _callee83$(_context83) {
        while (1) switch (_context83.prev = _context83.next) {
          case 0:
            _context83.next = 2;
            return this._networkClient.fetchSDK({
              url: "/b2b/organizations/me",
              errorMessage: 'Failed to delete organization.',
              method: 'DELETE'
            });
          case 2:
            resp = _context83.sent;
            this._subscriptionService.destroyState();
            return _context83.abrupt("return", resp);
          case 5:
          case "end":
            return _context83.stop();
        }
      }, _callee83, this);
    }));
  };
  this.members = {
    create: function create(data) {
      return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee84() {
        return _regeneratorRuntime().wrap(function _callee84$(_context84) {
          while (1) switch (_context84.prev = _context84.next) {
            case 0:
              return _context84.abrupt("return", this._networkClient.fetchSDK({
                url: "/b2b/organizations/members",
                errorMessage: 'Failed to create member.',
                method: 'POST',
                body: data
              }));
            case 1:
            case "end":
              return _context84.stop();
          }
        }, _callee84, this);
      }));
    },
    search: function search(data) {
      return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee85() {
        return _regeneratorRuntime().wrap(function _callee85$(_context85) {
          while (1) switch (_context85.prev = _context85.next) {
            case 0:
              return _context85.abrupt("return", this._networkClient.fetchSDK({
                url: "/b2b/organizations/me/members/search",
                errorMessage: 'Failed to search members.',
                method: 'POST',
                body: data
              }));
            case 1:
            case "end":
              return _context85.stop();
          }
        }, _callee85, this);
      }));
    },
    update: function update(data) {
      return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee86() {
        return _regeneratorRuntime().wrap(function _callee86$(_context86) {
          while (1) switch (_context86.prev = _context86.next) {
            case 0:
              return _context86.abrupt("return", this._networkClient.fetchSDK({
                url: "/b2b/organizations/members/".concat(data.member_id),
                errorMessage: 'Failed to update member.',
                method: 'PUT',
                body: data
              }));
            case 1:
            case "end":
              return _context86.stop();
          }
        }, _callee86, this);
      }));
    },
    deletePassword: function deletePassword(passwordId) {
      return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee87() {
        return _regeneratorRuntime().wrap(function _callee87$(_context87) {
          while (1) switch (_context87.prev = _context87.next) {
            case 0:
              return _context87.abrupt("return", this._networkClient.fetchSDK({
                url: "/b2b/organizations/members/passwords/".concat(passwordId),
                errorMessage: 'Failed to delete member password.',
                method: 'DELETE'
              }));
            case 1:
            case "end":
              return _context87.stop();
          }
        }, _callee87, this);
      }));
    },
    deleteMFAPhoneNumber: function deleteMFAPhoneNumber(memberId) {
      return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee88() {
        return _regeneratorRuntime().wrap(function _callee88$(_context88) {
          while (1) switch (_context88.prev = _context88.next) {
            case 0:
              return _context88.abrupt("return", this._networkClient.fetchSDK({
                url: "/b2b/organizations/members/mfa_phone_numbers/".concat(memberId),
                errorMessage: 'Failed to delete member MFA Phone number.',
                method: 'DELETE'
              }));
            case 1:
            case "end":
              return _context88.stop();
          }
        }, _callee88, this);
      }));
    },
    "delete": function _delete(memberId) {
      return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee89() {
        return _regeneratorRuntime().wrap(function _callee89$(_context89) {
          while (1) switch (_context89.prev = _context89.next) {
            case 0:
              return _context89.abrupt("return", this._networkClient.fetchSDK({
                url: "/b2b/organizations/members/".concat(memberId),
                errorMessage: 'Failed to delete member.',
                method: 'DELETE'
              }));
            case 1:
            case "end":
              return _context89.stop();
          }
        }, _callee89, this);
      }));
    },
    reactivate: function reactivate(memberId) {
      return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee90() {
        return _regeneratorRuntime().wrap(function _callee90$(_context90) {
          while (1) switch (_context90.prev = _context90.next) {
            case 0:
              return _context90.abrupt("return", this._networkClient.fetchSDK({
                url: "/b2b/organizations/members/".concat(memberId, "/reactivate"),
                errorMessage: 'Failed to reactivate member.',
                method: 'PUT'
              }));
            case 1:
            case "end":
              return _context90.stop();
          }
        }, _callee90, this);
      }));
    }
  };
});
var HeadlessB2BOAuthClient = /*#__PURE__*/function () {
  function HeadlessB2BOAuthClient(_networkClient, _subscriptionService, _pkceManager, _dynamicConfig, _config) {
    var _this16 = this;
    var dfpProtectedAuth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : DisabledDFPProtectedAuthProvider();
    _classCallCheck(this, HeadlessB2BOAuthClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._dynamicConfig = _dynamicConfig;
    this._config = _config;
    this.dfpProtectedAuth = dfpProtectedAuth;
    this.discovery = {
      authenticate: function authenticate(data) {
        return __awaiter(_this16, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee91() {
          var pkPair, _yield$this$dfpProtec21, dfp_telemetry_id, captcha_token, requestBody, resp;
          return _regeneratorRuntime().wrap(function _callee91$(_context91) {
            while (1) switch (_context91.prev = _context91.next) {
              case 0:
                validate('stytch.oauth.discovery.authenticate').isString('discovery_oauth_token', data.discovery_oauth_token);
                _context91.next = 3;
                return this._pkceManager.getPKPair();
              case 3:
                pkPair = _context91.sent;
                _context91.next = 6;
                return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
              case 6:
                _yield$this$dfpProtec21 = _context91.sent;
                dfp_telemetry_id = _yield$this$dfpProtec21.dfp_telemetry_id;
                captcha_token = _yield$this$dfpProtec21.captcha_token;
                requestBody = Object.assign({
                  pkce_code_verifier: pkPair === null || pkPair === void 0 ? void 0 : pkPair.code_verifier,
                  dfp_telemetry_id: dfp_telemetry_id,
                  captcha_token: captcha_token
                }, data);
                _context91.next = 12;
                return this._networkClient.retriableFetchSDK({
                  url: '/b2b/oauth/discovery/authenticate',
                  body: requestBody,
                  errorMessage: 'Failed to authenticate discovery oauth token',
                  method: 'POST',
                  retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
                });
              case 12:
                resp = _context91.sent;
                this._pkceManager.clearPKPair();
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
                return _context91.abrupt("return", resp);
              case 16:
              case "end":
                return _context91.stop();
            }
          }, _callee91, this);
        }));
      }
    };
    this.google = {
      start: this.startOAuthFlow(B2BOAuthProviders.Google),
      discovery: {
        start: this.startDiscoveryOAuthFlow(B2BOAuthProviders.Google)
      }
    };
    this.microsoft = {
      start: this.startOAuthFlow(B2BOAuthProviders.Microsoft),
      discovery: {
        start: this.startDiscoveryOAuthFlow(B2BOAuthProviders.Microsoft)
      }
    };
  }
  _createClass(HeadlessB2BOAuthClient, [{
    key: "authenticate",
    value: function authenticate(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee92() {
        var keyPair, _yield$this$dfpProtec22, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee92$(_context92) {
          while (1) switch (_context92.prev = _context92.next) {
            case 0:
              validate('stytch.oauth.authenticate').isString('oauth_token', options.oauth_token).isNumber('session_duration_minutes', options.session_duration_minutes).isOptionalString('locale', options.locale);
              _context92.next = 3;
              return this._pkceManager.getPKPair();
            case 3:
              keyPair = _context92.sent;
              if (!keyPair) {
                logger.warn('No code verifier found in local storage for OAuth flow.\n' + 'Consider using stytch.oauth.$provider.start() to add PKCE to your OAuth flows for added security.\n' + 'See https://stytch.com/docs/oauth#guides_pkce for more information.');
              }
              _context92.next = 7;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 7:
              _yield$this$dfpProtec22 = _context92.sent;
              dfp_telemetry_id = _yield$this$dfpProtec22.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec22.captcha_token;
              _context92.next = 12;
              return this._networkClient.retriableFetchSDK({
                url: '/b2b/oauth/authenticate',
                method: 'POST',
                body: Object.assign({
                  pkce_code_verifier: keyPair === null || keyPair === void 0 ? void 0 : keyPair.code_verifier,
                  dfp_telemetry_id: dfp_telemetry_id,
                  captcha_token: captcha_token
                }, options),
                errorMessage: 'Failed to authenticate token',
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 12:
              resp = _context92.sent;
              this._pkceManager.clearPKPair();
              if (resp.member_session) {
                this._subscriptionService.updateStateAndTokens({
                  state: {
                    session: resp.member_session,
                    member: resp.member
                  },
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt,
                  intermediate_session_token: null
                });
              } else {
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
              }
              return _context92.abrupt("return", resp);
            case 16:
            case "end":
              return _context92.stop();
          }
        }, _callee92, this);
      }));
    }
  }, {
    key: "getBaseApiUrl",
    value: function getBaseApiUrl() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee93() {
        var _yield$this$_dynamicC4, cnameDomain;
        return _regeneratorRuntime().wrap(function _callee93$(_context93) {
          while (1) switch (_context93.prev = _context93.next) {
            case 0:
              _context93.next = 2;
              return this._dynamicConfig;
            case 2:
              _yield$this$_dynamicC4 = _context93.sent;
              cnameDomain = _yield$this$_dynamicC4.cnameDomain;
              if (!cnameDomain) {
                _context93.next = 6;
                break;
              }
              return _context93.abrupt("return", "https://".concat(cnameDomain));
            case 6:
              if (!isTestPublicToken(this._config.publicToken)) {
                _context93.next = 8;
                break;
              }
              return _context93.abrupt("return", this._config.testAPIURL);
            case 8:
              return _context93.abrupt("return", this._config.liveAPIURL);
            case 9:
            case "end":
              return _context93.stop();
          }
        }, _callee93, this);
      }));
    }
  }, {
    key: "startOAuthFlow",
    value: function startOAuthFlow(providerType) {
      var _this17 = this;
      return function (_ref10) {
        var organization_id = _ref10.organization_id,
          organization_slug = _ref10.organization_slug,
          login_redirect_url = _ref10.login_redirect_url,
          signup_redirect_url = _ref10.signup_redirect_url,
          custom_scopes = _ref10.custom_scopes,
          provider_params = _ref10.provider_params;
        return __awaiter(_this17, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee94() {
          var _yield$this$_dynamicC5, pkceRequiredForOAuth, baseURL, startUrl, key, keyPair;
          return _regeneratorRuntime().wrap(function _callee94$(_context94) {
            while (1) switch (_context94.prev = _context94.next) {
              case 0:
                _context94.next = 2;
                return this._dynamicConfig;
              case 2:
                _yield$this$_dynamicC5 = _context94.sent;
                pkceRequiredForOAuth = _yield$this$_dynamicC5.pkceRequiredForOAuth;
                _context94.next = 6;
                return this.getBaseApiUrl();
              case 6:
                baseURL = _context94.sent;
                startUrl = new URL("".concat(baseURL, "/v1/b2b/public/oauth/").concat(providerType, "/start"));
                startUrl.searchParams.set('public_token', this._config.publicToken);
                if (organization_id && organization_id != '') {
                  startUrl.searchParams.set('organization_id', organization_id);
                }
                if (organization_slug && organization_slug != '') {
                  startUrl.searchParams.set('slug', organization_slug);
                }
                if (custom_scopes) {
                  validate('startOAuthFlow').isStringArray('custom_scopes', custom_scopes);
                  startUrl.searchParams.set('custom_scopes', custom_scopes.join(' '));
                }
                if (provider_params) {
                  validate('startOAuthFlow').isOptionalObject('provider_params', provider_params);
                  for (key in provider_params) {
                    startUrl.searchParams.set('provider_' + key, provider_params[key]);
                  }
                }
                if (!pkceRequiredForOAuth) {
                  _context94.next = 20;
                  break;
                }
                _context94.next = 16;
                return this._pkceManager.startPKCETransaction();
              case 16:
                keyPair = _context94.sent;
                startUrl.searchParams.set('pkce_code_challenge', keyPair.code_challenge);
                _context94.next = 21;
                break;
              case 20:
                this._pkceManager.clearPKPair();
              case 21:
                login_redirect_url && startUrl.searchParams.set('login_redirect_url', login_redirect_url);
                signup_redirect_url && startUrl.searchParams.set('signup_redirect_url', signup_redirect_url);
                window.location.href = startUrl.toString();
              case 24:
              case "end":
                return _context94.stop();
            }
          }, _callee94, this);
        }));
      };
    }
  }, {
    key: "startDiscoveryOAuthFlow",
    value: function startDiscoveryOAuthFlow(providerType) {
      var _this18 = this;
      return function (_ref11) {
        var discovery_redirect_url = _ref11.discovery_redirect_url,
          custom_scopes = _ref11.custom_scopes,
          provider_params = _ref11.provider_params;
        return __awaiter(_this18, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee95() {
          var _yield$this$_dynamicC6, pkceRequiredForOAuth, baseURL, startUrl, key, keyPair;
          return _regeneratorRuntime().wrap(function _callee95$(_context95) {
            while (1) switch (_context95.prev = _context95.next) {
              case 0:
                _context95.next = 2;
                return this._dynamicConfig;
              case 2:
                _yield$this$_dynamicC6 = _context95.sent;
                pkceRequiredForOAuth = _yield$this$_dynamicC6.pkceRequiredForOAuth;
                _context95.next = 6;
                return this.getBaseApiUrl();
              case 6:
                baseURL = _context95.sent;
                startUrl = new URL("".concat(baseURL, "/v1/b2b/public/oauth/").concat(providerType, "/discovery/start"));
                startUrl.searchParams.set('public_token', this._config.publicToken);
                if (custom_scopes) {
                  validate('startOAuthFlow').isStringArray('custom_scopes', custom_scopes);
                  startUrl.searchParams.set('custom_scopes', custom_scopes.join(' '));
                }
                if (provider_params) {
                  validate('startOAuthFlow').isOptionalObject('provider_params', provider_params);
                  for (key in provider_params) {
                    startUrl.searchParams.set('provider_' + key, provider_params[key]);
                  }
                }
                if (!pkceRequiredForOAuth) {
                  _context95.next = 18;
                  break;
                }
                _context95.next = 14;
                return this._pkceManager.startPKCETransaction();
              case 14:
                keyPair = _context95.sent;
                startUrl.searchParams.set('pkce_code_challenge', keyPair.code_challenge);
                _context95.next = 19;
                break;
              case 18:
                this._pkceManager.clearPKPair();
              case 19:
                discovery_redirect_url && startUrl.searchParams.set('discovery_redirect_url', discovery_redirect_url);
                window.location.href = startUrl.toString();
              case 21:
              case "end":
                return _context95.stop();
            }
          }, _callee95, this);
        }));
      };
    }
  }]);
  return HeadlessB2BOAuthClient;
}();
var HeadlessB2BSessionClient = /*#__PURE__*/function () {
  function HeadlessB2BSessionClient(_networkClient, _subscriptionService) {
    var _this19 = this;
    _classCallCheck(this, HeadlessB2BSessionClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this.getSync = function () {
      return _this19._subscriptionService.getSession();
    };
    this.onChange = function (callback) {
      return _this19._subscriptionService.subscribeToState(function (state) {
        var _a;
        return callback((_a = state === null || state === void 0 ? void 0 : state.session) !== null && _a !== void 0 ? _a : null);
      });
    };
    this.revoke = function (options) {
      return __awaiter(_this19, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee96() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee96$(_context96) {
          while (1) switch (_context96.prev = _context96.next) {
            case 0:
              _context96.prev = 0;
              _context96.next = 3;
              return this._networkClient.fetchSDK({
                url: "/b2b/sessions/revoke",
                errorMessage: 'Error revoking session',
                method: 'POST'
              });
            case 3:
              resp = _context96.sent;
              this._subscriptionService.destroyState();
              return _context96.abrupt("return", resp);
            case 8:
              _context96.prev = 8;
              _context96.t0 = _context96["catch"](0);
              if (!!(options === null || options === void 0 ? void 0 : options.forceClear)) {
                this._subscriptionService.destroyState();
              } else if (UNRECOVERABLE_ERROR_TYPES.includes(_context96.t0.error_type)) {
                this._subscriptionService.destroyState();
              }
              throw _context96.t0;
            case 12:
            case "end":
              return _context96.stop();
          }
        }, _callee96, this, [[0, 8]]);
      }));
    };
    this.authenticate = function (options) {
      return __awaiter(_this19, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee97() {
        var requestBody, resp;
        return _regeneratorRuntime().wrap(function _callee97$(_context97) {
          while (1) switch (_context97.prev = _context97.next) {
            case 0:
              _context97.prev = 0;
              requestBody = {
                session_duration_minutes: options === null || options === void 0 ? void 0 : options.session_duration_minutes
              };
              _context97.next = 4;
              return this._networkClient.fetchSDK({
                url: '/b2b/sessions/authenticate',
                body: requestBody,
                errorMessage: 'Error authenticating session',
                method: 'POST'
              });
            case 4:
              resp = _context97.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.member_session,
                  member: resp.member
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context97.abrupt("return", resp);
            case 9:
              _context97.prev = 9;
              _context97.t0 = _context97["catch"](0);
              if (UNRECOVERABLE_ERROR_TYPES.includes(_context97.t0.error_type)) {
                this._subscriptionService.destroyState();
              }
              throw _context97.t0;
            case 13:
            case "end":
              return _context97.stop();
          }
        }, _callee97, this, [[0, 9]]);
      }));
    };
    this.exchange = function (data) {
      return __awaiter(_this19, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee98() {
        var resp;
        return _regeneratorRuntime().wrap(function _callee98$(_context98) {
          while (1) switch (_context98.prev = _context98.next) {
            case 0:
              validate('stytch.sessions.exchange').isString('organization_id', data.organization_id).isNumber('session_duration_minutes', data.session_duration_minutes).isOptionalString('locale', data.locale);
              _context98.prev = 1;
              _context98.next = 4;
              return this._networkClient.fetchSDK({
                url: '/b2b/sessions/exchange',
                body: data,
                errorMessage: 'Failed to exchange session',
                method: 'POST'
              });
            case 4:
              resp = _context98.sent;
              if (resp.member_session) {
                this._subscriptionService.updateStateAndTokens({
                  state: {
                    session: resp.member_session,
                    member: resp.member
                  },
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt,
                  intermediate_session_token: null
                });
              } else {
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
              }
              return _context98.abrupt("return", resp);
            case 9:
              _context98.prev = 9;
              _context98.t0 = _context98["catch"](1);
              throw _context98.t0;
            case 12:
            case "end":
              return _context98.stop();
          }
        }, _callee98, this, [[1, 9]]);
      }));
    };
  }
  _createClass(HeadlessB2BSessionClient, [{
    key: "getTokens",
    value: function getTokens() {
      return this._subscriptionService.getTokens();
    }
  }]);
  return HeadlessB2BSessionClient;
}();
var HeadlessB2BDiscoveryClient = /*#__PURE__*/_createClass(function HeadlessB2BDiscoveryClient(_networkClient, _subscriptionService) {
  var _this20 = this;
  _classCallCheck(this, HeadlessB2BDiscoveryClient);
  this._networkClient = _networkClient;
  this._subscriptionService = _subscriptionService;
  this.organizations = {
    list: function list() {
      return __awaiter(_this20, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee99() {
        return _regeneratorRuntime().wrap(function _callee99$(_context99) {
          while (1) switch (_context99.prev = _context99.next) {
            case 0:
              _context99.t0 = this._networkClient;
              _context99.next = 3;
              return this._subscriptionService.getIntermediateSessionToken();
            case 3:
              _context99.t1 = _context99.sent;
              if (_context99.t1) {
                _context99.next = 6;
                break;
              }
              _context99.t1 = undefined;
            case 6:
              _context99.t2 = _context99.t1;
              _context99.t3 = {
                intermediate_session_token: _context99.t2
              };
              _context99.t4 = {
                url: '/b2b/discovery/organizations',
                body: _context99.t3,
                errorMessage: 'Failed to retrieve discovered organizations',
                method: 'POST'
              };
              return _context99.abrupt("return", _context99.t0.fetchSDK.call(_context99.t0, _context99.t4));
            case 10:
            case "end":
              return _context99.stop();
          }
        }, _callee99, this);
      }));
    },
    create: function create(data) {
      return __awaiter(_this20, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee100() {
        var requestBody, resp;
        return _regeneratorRuntime().wrap(function _callee100$(_context100) {
          while (1) switch (_context100.prev = _context100.next) {
            case 0:
              validate('stytch.discovery.organizations.create').isNumber('session_duration_minutes', data.session_duration_minutes).isOptionalString('organization_name', data.organization_name).isOptionalString('organization_slug', data.organization_slug).isOptionalString('organization_logo_url', data.organization_logo_url).isOptionalString('sso_jit_provisioning', data.sso_jit_provisioning).isOptionalStringArray('email_allowed_domains', data.email_allowed_domains).isOptionalString('email_invites', data.email_invites).isOptionalString('auth_methods', data.auth_methods).isOptionalStringArray('allowed_auth_methods', data.allowed_auth_methods).isOptionalString('mfa_policy', data.mfa_policy);
              _context100.t0 = Object;
              _context100.t1 = Object.assign({}, data);
              _context100.next = 5;
              return this._subscriptionService.getIntermediateSessionToken();
            case 5:
              _context100.t2 = _context100.sent;
              if (_context100.t2) {
                _context100.next = 8;
                break;
              }
              _context100.t2 = undefined;
            case 8:
              _context100.t3 = _context100.t2;
              _context100.t4 = {
                intermediate_session_token: _context100.t3
              };
              requestBody = _context100.t0.assign.call(_context100.t0, _context100.t1, _context100.t4);
              _context100.next = 13;
              return this._networkClient.fetchSDK({
                url: '/b2b/discovery/organizations/create',
                body: requestBody,
                errorMessage: 'Failed to create organization and member',
                method: 'POST'
              });
            case 13:
              resp = _context100.sent;
              if (resp.member_session) {
                this._subscriptionService.updateStateAndTokens({
                  state: {
                    session: resp.member_session,
                    member: resp.member
                  },
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt,
                  intermediate_session_token: null
                });
              } else {
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
              }
              return _context100.abrupt("return", resp);
            case 16:
            case "end":
              return _context100.stop();
          }
        }, _callee100, this);
      }));
    }
  };
  this.intermediateSessions = {
    exchange: function exchange(data) {
      return __awaiter(_this20, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee101() {
        var requestBody, resp;
        return _regeneratorRuntime().wrap(function _callee101$(_context101) {
          while (1) switch (_context101.prev = _context101.next) {
            case 0:
              validate('stytch.discovery.intermediateSessions.exchange').isString('organization_id', data.organization_id).isNumber('session_duration_minutes', data.session_duration_minutes).isOptionalString('locale', data.locale);
              _context101.t0 = Object;
              _context101.t1 = Object.assign({}, data);
              _context101.next = 5;
              return this._subscriptionService.getIntermediateSessionToken();
            case 5:
              _context101.t2 = _context101.sent;
              if (_context101.t2) {
                _context101.next = 8;
                break;
              }
              _context101.t2 = undefined;
            case 8:
              _context101.t3 = _context101.t2;
              _context101.t4 = {
                intermediate_session_token: _context101.t3
              };
              requestBody = _context101.t0.assign.call(_context101.t0, _context101.t1, _context101.t4);
              _context101.next = 13;
              return this._networkClient.fetchSDK({
                url: '/b2b/discovery/intermediate_sessions/exchange',
                body: requestBody,
                errorMessage: 'Failed to exchange intermediate session',
                method: 'POST'
              });
            case 13:
              resp = _context101.sent;
              if (resp.member_session) {
                this._subscriptionService.updateStateAndTokens({
                  state: {
                    session: resp.member_session,
                    member: resp.member
                  },
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt,
                  intermediate_session_token: null
                });
              } else {
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
              }
              return _context101.abrupt("return", resp);
            case 16:
            case "end":
              return _context101.stop();
          }
        }, _callee101, this);
      }));
    }
  };
});
var DefaultDynamicConfig = Promise.resolve({
  pkceRequiredForPasswordResets: false
});
var HeadlessB2BPasswordsClient = /*#__PURE__*/function () {
  function HeadlessB2BPasswordsClient(_networkClient, _subscriptionService, _pkceManager) {
    var _config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultDynamicConfig;
    var dfpProtectedAuth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DisabledDFPProtectedAuthProvider();
    _classCallCheck(this, HeadlessB2BPasswordsClient);
    this._networkClient = _networkClient;
    this._subscriptionService = _subscriptionService;
    this._pkceManager = _pkceManager;
    this._config = _config;
    this.dfpProtectedAuth = dfpProtectedAuth;
  }
  _createClass(HeadlessB2BPasswordsClient, [{
    key: "getCodeChallenge",
    value: function getCodeChallenge() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee102() {
        var _yield$this$_config5, pkceRequiredForPasswordResets, keyPair;
        return _regeneratorRuntime().wrap(function _callee102$(_context102) {
          while (1) switch (_context102.prev = _context102.next) {
            case 0:
              _context102.next = 2;
              return this._config;
            case 2:
              _yield$this$_config5 = _context102.sent;
              pkceRequiredForPasswordResets = _yield$this$_config5.pkceRequiredForPasswordResets;
              if (pkceRequiredForPasswordResets) {
                _context102.next = 6;
                break;
              }
              return _context102.abrupt("return", undefined);
            case 6:
              _context102.next = 8;
              return this._pkceManager.getPKPair();
            case 8:
              keyPair = _context102.sent;
              if (!keyPair) {
                _context102.next = 11;
                break;
              }
              return _context102.abrupt("return", keyPair.code_challenge);
            case 11:
              _context102.next = 13;
              return this._pkceManager.startPKCETransaction();
            case 13:
              keyPair = _context102.sent;
              return _context102.abrupt("return", keyPair.code_challenge);
            case 15:
            case "end":
              return _context102.stop();
          }
        }, _callee102, this);
      }));
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee103() {
        var pkPair, code_verifier, _yield$this$dfpProtec23, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee103$(_context103) {
          while (1) switch (_context103.prev = _context103.next) {
            case 0:
              validate('stytch.passwords.authenticate').isString('org_id', options.organization_id).isString('password', options.password).isString('email_address', options.email_address).isNumber('session_duration_minutes', options.session_duration_minutes).isOptionalString('locale', options.locale);
              _context103.next = 3;
              return this._pkceManager.getPKPair();
            case 3:
              pkPair = _context103.sent;
              code_verifier = pkPair === null || pkPair === void 0 ? void 0 : pkPair.code_verifier;
              _context103.next = 7;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 7:
              _yield$this$dfpProtec23 = _context103.sent;
              dfp_telemetry_id = _yield$this$dfpProtec23.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec23.captcha_token;
              _context103.next = 12;
              return this._networkClient.retriableFetchSDK({
                url: '/b2b/passwords/authenticate',
                method: 'POST',
                errorMessage: 'Failed to authenticate password.',
                body: {
                  organization_id: options.organization_id,
                  email_address: options.email_address,
                  password: options.password,
                  session_duration_minutes: options.session_duration_minutes,
                  locale: options.locale,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id,
                  code_verifier: code_verifier
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 12:
              resp = _context103.sent;
              if (resp.member_session) {
                this._subscriptionService.updateStateAndTokens({
                  state: {
                    session: resp.member_session,
                    member: resp.member
                  },
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt,
                  intermediate_session_token: null
                });
              } else {
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
              }
              return _context103.abrupt("return", resp);
            case 15:
            case "end":
              return _context103.stop();
          }
        }, _callee103, this);
      }));
    }
  }, {
    key: "resetByEmailStart",
    value: function resetByEmailStart(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee104() {
        var code_challenge, _yield$this$dfpProtec24, dfp_telemetry_id, captcha_token;
        return _regeneratorRuntime().wrap(function _callee104$(_context104) {
          while (1) switch (_context104.prev = _context104.next) {
            case 0:
              validate('stytch.passwords.resetByEmailStart').isString('email', options.email_address).isOptionalString('login_redirect_url', options.login_redirect_url).isOptionalString('reset_password_redirect_url', options.reset_password_redirect_url).isOptionalString('reset_password_template_id', options.reset_password_template_id).isOptionalNumber('reset_password_expiration_minutes', options.reset_password_expiration_minutes);
              _context104.next = 3;
              return this.getCodeChallenge();
            case 3:
              code_challenge = _context104.sent;
              _context104.next = 6;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 6:
              _yield$this$dfpProtec24 = _context104.sent;
              dfp_telemetry_id = _yield$this$dfpProtec24.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec24.captcha_token;
              return _context104.abrupt("return", this._networkClient.retriableFetchSDK({
                url: '/b2b/passwords/email/reset/start',
                method: 'POST',
                errorMessage: 'Failed to start password reset flow.',
                body: {
                  organization_id: options.organization_id,
                  email_address: options.email_address,
                  login_redirect_url: options.login_redirect_url,
                  reset_password_redirect_url: options.reset_password_redirect_url,
                  reset_password_expiration_minutes: options.reset_password_expiration_minutes,
                  reset_password_template_id: options.reset_password_template_id,
                  code_challenge: code_challenge,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              }));
            case 10:
            case "end":
              return _context104.stop();
          }
        }, _callee104, this);
      }));
    }
  }, {
    key: "resetByEmail",
    value: function resetByEmail(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee105() {
        var _yield$this$dfpProtec25, dfp_telemetry_id, captcha_token, pkPair, code_verifier, resp;
        return _regeneratorRuntime().wrap(function _callee105$(_context105) {
          while (1) switch (_context105.prev = _context105.next) {
            case 0:
              validate('stytch.passwords.resetByEmail').isString('password_reset_token', options.password_reset_token).isString('password', options.password).isNumber('session_duration_minutes', options.session_duration_minutes).isOptionalString('locale', options.locale);
              _context105.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec25 = _context105.sent;
              dfp_telemetry_id = _yield$this$dfpProtec25.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec25.captcha_token;
              _context105.next = 8;
              return this._pkceManager.getPKPair();
            case 8:
              pkPair = _context105.sent;
              code_verifier = pkPair === null || pkPair === void 0 ? void 0 : pkPair.code_verifier;
              _context105.next = 12;
              return this._networkClient.retriableFetchSDK({
                url: '/b2b/passwords/email/reset',
                method: 'POST',
                errorMessage: 'Failed to reset password.',
                body: {
                  password_reset_token: options.password_reset_token,
                  password: options.password,
                  session_duration_minutes: options.session_duration_minutes,
                  locale: options.locale,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id,
                  code_verifier: code_verifier
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 12:
              resp = _context105.sent;
              this._pkceManager.clearPKPair();
              if (resp.member_session) {
                this._subscriptionService.updateStateAndTokens({
                  state: {
                    session: resp.member_session,
                    member: resp.member
                  },
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt,
                  intermediate_session_token: null
                });
              } else {
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
              }
              return _context105.abrupt("return", resp);
            case 16:
            case "end":
              return _context105.stop();
          }
        }, _callee105, this);
      }));
    }
  }, {
    key: "resetByExistingPassword",
    value: function resetByExistingPassword(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee106() {
        var _yield$this$dfpProtec26, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee106$(_context106) {
          while (1) switch (_context106.prev = _context106.next) {
            case 0:
              validate('stytch.passwords.resetByExistingPassword').isString('email', options.email_address).isString('existing_password', options.existing_password).isString('new_password', options.new_password).isOptionalString('locale', options.locale);
              _context106.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec26 = _context106.sent;
              dfp_telemetry_id = _yield$this$dfpProtec26.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec26.captcha_token;
              _context106.next = 8;
              return this._networkClient.retriableFetchSDK({
                url: '/b2b/passwords/existing_password/reset',
                method: 'POST',
                errorMessage: 'Failed to reset password.',
                body: {
                  organization_id: options.organization_id,
                  email_address: options.email_address,
                  existing_password: options.existing_password,
                  new_password: options.new_password,
                  locale: options.locale,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 8:
              resp = _context106.sent;
              if (resp.member_session) {
                this._subscriptionService.updateStateAndTokens({
                  state: {
                    session: resp.member_session,
                    member: resp.member
                  },
                  session_token: resp.session_token,
                  session_jwt: resp.session_jwt,
                  intermediate_session_token: null
                });
              } else {
                this._subscriptionService.updateStateAndTokens({
                  state: null,
                  session_token: null,
                  session_jwt: null,
                  intermediate_session_token: resp.intermediate_session_token
                });
              }
              return _context106.abrupt("return", resp);
            case 11:
            case "end":
              return _context106.stop();
          }
        }, _callee106, this);
      }));
    }
  }, {
    key: "resetBySession",
    value: function resetBySession(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee107() {
        var _yield$this$dfpProtec27, dfp_telemetry_id, captcha_token, resp;
        return _regeneratorRuntime().wrap(function _callee107$(_context107) {
          while (1) switch (_context107.prev = _context107.next) {
            case 0:
              validate('stytch.passwords.resetBySession').isString('password', options.password);
              _context107.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec27 = _context107.sent;
              dfp_telemetry_id = _yield$this$dfpProtec27.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec27.captcha_token;
              _context107.next = 8;
              return this._networkClient.retriableFetchSDK({
                url: '/b2b/passwords/session/reset',
                method: 'POST',
                errorMessage: 'Failed to reset by session.',
                body: {
                  password: options.password,
                  captcha_token: captcha_token,
                  dfp_telemetry_id: dfp_telemetry_id
                },
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 8:
              resp = _context107.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.member_session,
                  member: resp.member
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context107.abrupt("return", resp);
            case 11:
            case "end":
              return _context107.stop();
          }
        }, _callee107, this);
      }));
    }
  }, {
    key: "strengthCheck",
    value: function strengthCheck(options) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee108() {
        return _regeneratorRuntime().wrap(function _callee108$(_context108) {
          while (1) switch (_context108.prev = _context108.next) {
            case 0:
              validate('stytch.passwords.strengthCheck').isOptionalString('email', options.email_address).isString('password', options.password);
              return _context108.abrupt("return", this._networkClient.fetchSDK({
                url: '/b2b/passwords/strength_check',
                method: 'POST',
                errorMessage: 'Failed to check password strength.',
                body: {
                  email_address: options.email_address,
                  password: options.password
                }
              }));
            case 2:
            case "end":
              return _context108.stop();
          }
        }, _callee108, this);
      }));
    }
  }]);
  return HeadlessB2BPasswordsClient;
}();
var HeadlessB2BOTPsClient = /*#__PURE__*/_createClass(function HeadlessB2BOTPsClient(_networkClient, _subscriptionService) {
  var _this21 = this;
  var dfpProtectedAuth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DisabledDFPProtectedAuthProvider();
  _classCallCheck(this, HeadlessB2BOTPsClient);
  this._networkClient = _networkClient;
  this._subscriptionService = _subscriptionService;
  this.dfpProtectedAuth = dfpProtectedAuth;
  this.sms = {
    send: function send(data) {
      return __awaiter(_this21, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee109() {
        var _yield$this$dfpProtec28, dfp_telemetry_id, captcha_token;
        return _regeneratorRuntime().wrap(function _callee109$(_context109) {
          while (1) switch (_context109.prev = _context109.next) {
            case 0:
              validate('stytch.otps.sms.send').isString('organization_id', data.organization_id).isString('member_id', data.member_id).isOptionalString('mfa_phone_number', data.mfa_phone_number).isOptionalString('locale', data.locale);
              _context109.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec28 = _context109.sent;
              dfp_telemetry_id = _yield$this$dfpProtec28.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec28.captcha_token;
              return _context109.abrupt("return", this._networkClient.retriableFetchSDK({
                url: '/b2b/otps/sms/send',
                body: Object.assign(Object.assign({}, data), {
                  dfp_telemetry_id: dfp_telemetry_id,
                  captcha_token: captcha_token
                }),
                errorMessage: 'Failed to send one time passcode',
                method: 'POST',
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              }));
            case 7:
            case "end":
              return _context109.stop();
          }
        }, _callee109, this);
      }));
    },
    authenticate: function authenticate(data) {
      return __awaiter(_this21, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee110() {
        var _yield$this$dfpProtec29, dfp_telemetry_id, captcha_token, requestBody, resp;
        return _regeneratorRuntime().wrap(function _callee110$(_context110) {
          while (1) switch (_context110.prev = _context110.next) {
            case 0:
              validate('stytch.otps.sms.authenticate').isString('organization_id', data.organization_id).isString('member_id', data.member_id).isString('code', data.code).isOptionalString('set_mfa_enrollment', data.set_mfa_enrollment);
              _context110.next = 3;
              return this.dfpProtectedAuth.getDFPTelemetryIDAndCaptcha();
            case 3:
              _yield$this$dfpProtec29 = _context110.sent;
              dfp_telemetry_id = _yield$this$dfpProtec29.dfp_telemetry_id;
              captcha_token = _yield$this$dfpProtec29.captcha_token;
              _context110.t0 = Object;
              _context110.t1 = Object.assign({}, data);
              _context110.t2 = dfp_telemetry_id;
              _context110.t3 = captcha_token;
              _context110.next = 12;
              return this._subscriptionService.getIntermediateSessionToken();
            case 12:
              _context110.t4 = _context110.sent;
              if (_context110.t4) {
                _context110.next = 15;
                break;
              }
              _context110.t4 = undefined;
            case 15:
              _context110.t5 = _context110.t4;
              _context110.t6 = {
                dfp_telemetry_id: _context110.t2,
                captcha_token: _context110.t3,
                intermediate_session_token: _context110.t5
              };
              requestBody = _context110.t0.assign.call(_context110.t0, _context110.t1, _context110.t6);
              _context110.next = 20;
              return this._networkClient.retriableFetchSDK({
                url: '/b2b/otps/sms/authenticate',
                body: requestBody,
                errorMessage: 'Failed to authenticate one time passcode',
                method: 'POST',
                retryCallback: this.dfpProtectedAuth.retryWithCaptchaAndDFP
              });
            case 20:
              resp = _context110.sent;
              this._subscriptionService.updateStateAndTokens({
                state: {
                  session: resp.member_session,
                  member: resp.member
                },
                session_token: resp.session_token,
                session_jwt: resp.session_jwt,
                intermediate_session_token: null
              });
              return _context110.abrupt("return", resp);
            case 23:
            case "end":
              return _context110.stop();
          }
        }, _callee110, this);
      }));
    }
  };
});
var HeadlessB2BRBACClient = /*#__PURE__*/function () {
  function HeadlessB2BRBACClient(cachedConfig, dynamicConfig, _subscriptionService) {
    var _this22 = this;
    _classCallCheck(this, HeadlessB2BRBACClient);
    this._subscriptionService = _subscriptionService;
    this.isAuthorizedSync = function (resourceId, action) {
      var _a;
      return !!((_a = _this22.cachedPolicy) === null || _a === void 0 ? void 0 : _a.callerIsAuthorized(_this22.roleIds(), resourceId, action));
    };
    this.isAuthorized = function (resourceId, action) {
      return _this22.policyPromise.then(function (policy) {
        return policy.callerIsAuthorized(_this22.roleIds(), resourceId, action);
      });
    };
    this.cachedPolicy = cachedConfig.rbacPolicy ? RBACPolicy.fromJSON(cachedConfig.rbacPolicy) : null;
    this.policyPromise = dynamicConfig.then(function (data) {
      if (!data.rbacPolicy) {
        logger.error('Unable to retrieve RBAC policy from servers. Assuming caller has no permissions.');
        return new RBACPolicy([], []);
      }
      // Update the existing policy too, so isAuthorizedSync will be up-to-date
      _this22.cachedPolicy = RBACPolicy.fromJSON(data.rbacPolicy);
      return _this22.cachedPolicy;
    });
  }
  _createClass(HeadlessB2BRBACClient, [{
    key: "allPermissions",
    value: function allPermissions() {
      var _this23 = this;
      return this.policyPromise.then(function (policy) {
        return policy.allPermissionsForCaller(_this23.roleIds());
      });
    }
  }, {
    key: "roleIds",
    value: function roleIds() {
      var _a;
      var session = this._subscriptionService.getSession();
      if (!session) {
        return [];
      }
      // Although session.roles is guaranteed to exist for fresh data, there is a minuscule chance
      // that the member session stored in localstorage clientside comes from before roles were added to
      // the API response - in which case session.roles will be undefined and this will crash
      // TODO: [AUTH-2294] We can safely remove this ~3mos after RBAC is released
      return (_a = session.roles) !== null && _a !== void 0 ? _a : [];
    }
  }]);
  return HeadlessB2BRBACClient;
}();
var IframeHostClient = /*#__PURE__*/function () {
  function IframeHostClient(iframeURL) {
    _classCallCheck(this, IframeHostClient);
    this.iframeURL = iframeURL;
    this.createIframe();
  }
  _createClass(IframeHostClient, [{
    key: "createIframe",
    value: function createIframe() {
      var existingIframe = document.querySelector("[src~=\"".concat(this.iframeURL, "\"]"));
      /* If an iframe does not exist yet, create one */
      if (!existingIframe) {
        existingIframe = document.createElement('iframe');
        existingIframe.src = this.iframeURL;
        existingIframe.style.position = 'absolute';
        existingIframe.style.width = '0';
        existingIframe.style.height = '0';
        existingIframe.style.border = '0';
        document.body.appendChild(existingIframe);
      } else {
        logger.warn("It looks like you're creating multiple copies of the Stytch client." + ' This behavior is unsupported, and unintended side effects may occur. ' + "Make sure you are creating the Stytch client at the global level, and not inside a component's render function.");
      }
      /**
       * [NASTY BUG]
       * If we postMessage to an iframe that is _not yet loaded_, chrome will give a cryptic error message
       * Failed to execute 'postMessage' on 'DOMWindow':
       *   The target origin provided ('https://js.stytch.com') does not match the recipient window's origin ('http://localhost:3000').
       * There is no builtin way to determine if an iframe is already loaded,
       * so we set a dataset attr in our onload handler and use that to determine loading state
       */
      if (existingIframe.dataset.loaded === 'true') {
        this.frame = Promise.resolve(existingIframe);
        return;
      }
      this.frame = new Promise(function (resolve) {
        existingIframe.addEventListener('load', function () {
          existingIframe.dataset.loaded = 'true';
          resolve(existingIframe);
        }, {
          once: true
        });
      });
    }
  }, {
    key: "call",
    value: function call(method, args) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee111() {
        var _this24 = this;
        var frame, channel;
        return _regeneratorRuntime().wrap(function _callee111$(_context111) {
          while (1) switch (_context111.prev = _context111.next) {
            case 0:
              _context111.next = 2;
              return this.frame;
            case 2:
              frame = _context111.sent;
              channel = new MessageChannel();
              return _context111.abrupt("return", new Promise(function (resolve, reject) {
                var _a;
                channel.port1.onmessage = function (event) {
                  var resp = event.data;
                  channel.port1.close();
                  if (resp.success) {
                    resolve(resp.payload);
                  } else {
                    reject(ErrorMarshaller.unmarshall(resp.error));
                  }
                };
                var message = {
                  method: method,
                  args: args
                };
                (_a = frame.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message, _this24.iframeURL, [channel.port2]);
              }));
            case 5:
            case "end":
              return _context111.stop();
          }
        }, _callee111, this);
      }));
    }
  }]);
  return IframeHostClient;
}();
var IframeEmbeddedClient = /*#__PURE__*/function () {
  function IframeEmbeddedClient() {
    var _this25 = this;
    _classCallCheck(this, IframeEmbeddedClient);
    this.handlers = {};
    window.addEventListener('message', function (event) {
      _this25.runHandler(event);
    });
  }
  _createClass(IframeEmbeddedClient, [{
    key: "runHandler",
    value: function runHandler(event) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee112() {
        var req, port, handler, payload;
        return _regeneratorRuntime().wrap(function _callee112$(_context112) {
          while (1) switch (_context112.prev = _context112.next) {
            case 0:
              req = event.data;
              port = event.ports[0];
              handler = this.handlers[req.method];
              if (!(!handler || !port)) {
                _context112.next = 5;
                break;
              }
              return _context112.abrupt("return");
            case 5:
              _context112.prev = 5;
              _context112.next = 8;
              return handler.apply(void 0, _toConsumableArray(req.args));
            case 8:
              payload = _context112.sent;
              port.postMessage({
                success: true,
                payload: payload
              });
              _context112.next = 15;
              break;
            case 12:
              _context112.prev = 12;
              _context112.t0 = _context112["catch"](5);
              port.postMessage({
                success: false,
                error: ErrorMarshaller.marshall(_context112.t0)
              });
            case 15:
            case "end":
              return _context112.stop();
          }
        }, _callee112, this, [[5, 12]]);
      }));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "registerHandler",
    value: function registerHandler(handler, handlerImpl) {
      this.handlers[handler] = handlerImpl;
    }
  }]);
  return IframeEmbeddedClient;
}();
var SessionManager = /*#__PURE__*/function () {
  function SessionManager(_subscriptionService, _headlessSessionClient) {
    var _this26 = this;
    _classCallCheck(this, SessionManager);
    this._subscriptionService = _subscriptionService;
    this._headlessSessionClient = _headlessSessionClient;
    /**
     * We need to listen to a few types of events:
     * - If the user logs in via invoking a .authenticate() call, we should start the background worker
     * - If the user steps up their authentication via another .authenticate call(), we should restart the background worker
     * - If the user logs out, we should terminate the worker
     * - We should ignore session changes that we ourselves caused - so if we already have a timeout, leave it be!
     */
    this._onDataChange = function (state) {
      if (state === null || state === void 0 ? void 0 : state.session) {
        _this26.scheduleBackgroundRefresh();
      } else {
        _this26.cancelBackgroundRefresh();
      }
    };
    // In cases where we cannot get a satisfactory request:
    // - Stytch is hard-down
    // - The user's network is disconnected for an extended period of time
    // we will continue to retry every 4 minutes ad infinum
    this._reauthenticateWithBackoff = function () {
      return __awaiter(_this26, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee113() {
        var count;
        return _regeneratorRuntime().wrap(function _callee113$(_context113) {
          while (1) switch (_context113.prev = _context113.next) {
            case 0:
              count = 0;
            case 1:
              if (!true) {
                _context113.next = 17;
                break;
              }
              _context113.prev = 2;
              _context113.next = 5;
              return this._headlessSessionClient.authenticate();
            case 5:
              return _context113.abrupt("return", _context113.sent);
            case 8:
              _context113.prev = 8;
              _context113.t0 = _context113["catch"](2);
              if (!SessionManager.isUnrecoverableError(_context113.t0)) {
                _context113.next = 12;
                break;
              }
              return _context113.abrupt("return", Promise.reject(_context113.t0));
            case 12:
              count++;
              _context113.next = 15;
              return new Promise(function (done) {
                return setTimeout(done, SessionManager.timeoutForAttempt(count));
              });
            case 15:
              _context113.next = 1;
              break;
            case 17:
            case "end":
              return _context113.stop();
          }
        }, _callee113, this, [[2, 8]]);
      }));
    };
    this.timeout = null;
    this._subscriptionService.subscribeToState(this._onDataChange);
  }
  /**
   * The core logic of the session refresh recursive trampoline
   * - Refreshes the currently issued session
   * - Schedules a future refresh if successful
   */
  _createClass(SessionManager, [{
    key: "performBackgroundRefresh",
    value: function performBackgroundRefresh() {
      var _this27 = this;
      logger.debug('performing background refresh at ', Date.now());
      this._reauthenticateWithBackoff().then(function () {
        _this27.scheduleBackgroundRefresh();
      })["catch"](function (error) {
        logger.warn('Session background refresh failed. Signalling to app that user is logged out.', {
          error: error
        });
        _this27._subscriptionService.destroyState();
      });
    }
  }, {
    key: "scheduleBackgroundRefresh",
    value: function scheduleBackgroundRefresh() {
      var _this28 = this;
      /* Highlander rules - there can only ever be one */
      this.cancelBackgroundRefresh();
      logger.debug('Scheduling bg refresh', Date.now());
      this.timeout = setTimeout(function () {
        _this28.performBackgroundRefresh();
      }, SessionManager.REFRESH_INTERVAL_MS);
    }
  }, {
    key: "cancelBackgroundRefresh",
    value: function cancelBackgroundRefresh() {
      if (this.timeout !== null) {
        logger.debug('Cancelling bg refresh', Date.now());
        clearTimeout(this.timeout);
        this.timeout = null;
      }
    }
    // We start with a backoff of 2000ms and increase exponentially to ~4 minutes (+/- 175 ms for jitter)
    // A short backoff initially helps increase the chance that we refresh the session before the JWT expires
  }], [{
    key: "timeoutForAttempt",
    value: function timeoutForAttempt(count) {
      count = Math.min(count, 7);
      var jitter = Math.floor(Math.random() * 350) - 175;
      var delayMS = 2000 * Math.pow(2, count);
      return jitter + delayMS;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "isUnrecoverableError",
    value: function isUnrecoverableError(error) {
      return UNRECOVERABLE_ERROR_TYPES.includes(error.error_type);
    }
  }]);
  return SessionManager;
}(); // Three minutes
SessionManager.REFRESH_INTERVAL_MS = 1000 * 60 * 3;
var LOCAL_STORAGE_KEY_PREFIX = 'stytch_sdk_state_';
var getLocalStorageKey = function getLocalStorageKey(publicToken) {
  return "".concat(LOCAL_STORAGE_KEY_PREFIX).concat(publicToken);
};
var SubscriptionDataLayer = /*#__PURE__*/function () {
  function SubscriptionDataLayer(_publicToken, _storageClient) {
    var _this29 = this;
    _classCallCheck(this, SubscriptionDataLayer);
    this._publicToken = _publicToken;
    this._storageClient = _storageClient;
    this.syncFromLocalStorage = function () {
      return __awaiter(_this29, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee114() {
        var _this30 = this;
        return _regeneratorRuntime().wrap(function _callee114$(_context114) {
          while (1) switch (_context114.prev = _context114.next) {
            case 0:
              return _context114.abrupt("return", this._storageClient.getData(getLocalStorageKey(this._publicToken)).then(function (localData) {
                if (!localData) {
                  return null;
                }
                var parsedState;
                try {
                  parsedState = JSON.parse(localData);
                } catch (e) {
                  // Overwrite the bad data
                  _this30._storageClient.clearData(getLocalStorageKey(_this30._publicToken));
                  // this.removeSessionCookie();
                  return null;
                }
                var _parsedState = parsedState,
                  state = _parsedState.state,
                  session_token = _parsedState.session_token,
                  session_jwt = _parsedState.session_jwt,
                  intermediate_session_token = _parsedState.intermediate_session_token;
                _this30.state = state;
                _this30.session_token = session_token;
                _this30.session_jwt = session_jwt;
                _this30.intermediate_session_token = intermediate_session_token;
                return {
                  state: state,
                  session_token: session_token,
                  session_jwt: session_jwt,
                  intermediate_session_token: intermediate_session_token
                };
              })["catch"](function () {
                return null;
              }));
            case 1:
            case "end":
              return _context114.stop();
          }
        }, _callee114, this);
      }));
    };
    this.state = null;
    this.session_token = null;
    this.session_jwt = null;
    this.intermediate_session_token = null;
    this.subscriptions = {};
  }
  _createClass(SubscriptionDataLayer, [{
    key: "syncToLocalStorage",
    value: function syncToLocalStorage() {
      this._storageClient.setData(getLocalStorageKey(this._publicToken), JSON.stringify({
        state: this.state,
        session_token: this.session_token,
        session_jwt: this.session_jwt,
        intermediate_session_token: this.intermediate_session_token
      }));
    }
  }]);
  return SubscriptionDataLayer;
}();
var addSubscriber = function addSubscriber(collection, subscriber) {
  var uniqueId = Math.random().toString(36).slice(-10);
  collection[uniqueId] = subscriber;
  return function () {
    return delete collection[uniqueId];
  };
};
var notifySubscribers = function notifySubscribers(collection, value) {
  Object.values(collection).forEach(function (cb) {
    return cb(value);
  });
};
var SubscriptionService = /*#__PURE__*/function () {
  function SubscriptionService(publicToken, storageClient) {
    _classCallCheck(this, SubscriptionService);
    var _a;
    // TODO: Generalize this for Mobile and Web based SDKs
    this._datalayer = new SubscriptionDataLayer(publicToken, storageClient);
    var session = (_a = this._datalayer.state) === null || _a === void 0 ? void 0 : _a.session;
    if (session && Date.parse(session.expires_at) < Date.now()) {
      this.destroyState();
      return;
    }
  }
  _createClass(SubscriptionService, [{
    key: "syncFromDeviceStorage",
    value: function syncFromDeviceStorage(onCompleteCallback) {
      var _this31 = this;
      this._datalayer.syncFromLocalStorage().then(function (res) {
        var _a;
        if (!res) {
          onCompleteCallback();
        } else if (((_a = res.state) === null || _a === void 0 ? void 0 : _a.session) && Date.parse(res.state.session.expires_at) < Date.now()) {
          _this31.destroyState();
          onCompleteCallback();
        } else {
          _this31.updateStateAndTokens(res);
          onCompleteCallback();
        }
      })["catch"](function () {
        onCompleteCallback();
      });
    }
  }, {
    key: "getState",
    value: function getState() {
      return this._datalayer.state;
    }
  }, {
    key: "getTokens",
    value: function getTokens() {
      if (!(typeof this._datalayer.session_token === 'string') || !(typeof this._datalayer.session_jwt === 'string')) {
        return null;
      }
      return {
        session_token: this._datalayer.session_token,
        session_jwt: this._datalayer.session_jwt
      };
    }
  }, {
    key: "getIntermediateSessionToken",
    value: function getIntermediateSessionToken() {
      return this._datalayer.intermediate_session_token;
    }
  }, {
    key: "destroyState",
    value: function destroyState() {
      this.updateStateAndTokens({
        state: null,
        session_token: null,
        session_jwt: null,
        intermediate_session_token: null
      });
    }
  }, {
    key: "_updateStateAndTokensInternal",
    value: function _updateStateAndTokensInternal(stateDiff) {
      var state = stateDiff.state,
        session_token = stateDiff.session_token,
        session_jwt = stateDiff.session_jwt,
        intermediate_session_token = stateDiff.intermediate_session_token;
      var newData = state == null ? null : Object.assign(Object.assign({}, this._datalayer.state), state);
      this._datalayer.state = newData;
      this._datalayer.session_token = session_token;
      this._datalayer.session_jwt = session_jwt;
      this._datalayer.intermediate_session_token = intermediate_session_token;
      notifySubscribers(this._datalayer.subscriptions, newData);
    }
  }, {
    key: "updateStateAndTokens",
    value: function updateStateAndTokens(stateDiff) {
      this._updateStateAndTokensInternal(stateDiff);
      this._datalayer.syncToLocalStorage();
    }
  }, {
    key: "updateState",
    value: function updateState(state) {
      var newState = Object.assign(Object.assign({}, this._datalayer.state), state);
      this._datalayer.state = newState;
      notifySubscribers(this._datalayer.subscriptions, newState);
      // Delay notifying other tabs until after we have refreshed ourselves
      this._datalayer.syncToLocalStorage();
    }
  }, {
    key: "updateTokens",
    value: function updateTokens(tokens) {
      this._datalayer.session_token = tokens.session_token;
      this._datalayer.session_jwt = tokens.session_jwt;
      this._datalayer.syncToLocalStorage();
    }
  }, {
    key: "subscribeToState",
    value: function subscribeToState(callback) {
      return addSubscriber(this._datalayer.subscriptions, callback);
    }
  }]);
  return SubscriptionService;
}();
var ConsumerSubscriptionService = /*#__PURE__*/function (_SubscriptionService) {
  _inherits(ConsumerSubscriptionService, _SubscriptionService);
  var _super6 = _createSuper(ConsumerSubscriptionService);
  function ConsumerSubscriptionService() {
    var _this32;
    _classCallCheck(this, ConsumerSubscriptionService);
    _this32 = _super6.apply(this, arguments);
    _this32.updateUser = function (user) {
      return _this32.updateState({
        user: user
      });
    };
    _this32.getUser = function () {
      var _a, _b;
      return (_b = (_a = _this32.getState()) === null || _a === void 0 ? void 0 : _a.user) !== null && _b !== void 0 ? _b : null;
    };
    _this32.getSession = function () {
      var _a, _b;
      return (_b = (_a = _this32.getState()) === null || _a === void 0 ? void 0 : _a.session) !== null && _b !== void 0 ? _b : null;
    };
    return _this32;
  }
  return _createClass(ConsumerSubscriptionService);
}(SubscriptionService);
var B2BSubscriptionService = /*#__PURE__*/function (_SubscriptionService2) {
  _inherits(B2BSubscriptionService, _SubscriptionService2);
  var _super7 = _createSuper(B2BSubscriptionService);
  function B2BSubscriptionService() {
    var _this33;
    _classCallCheck(this, B2BSubscriptionService);
    _this33 = _super7.apply(this, arguments);
    _this33.updateMember = function (member) {
      return _this33.updateState({
        member: member
      });
    };
    _this33.getMember = function () {
      var _a, _b;
      return (_b = (_a = _this33.getState()) === null || _a === void 0 ? void 0 : _a.member) !== null && _b !== void 0 ? _b : null;
    };
    _this33.getSession = function () {
      var _a, _b;
      return (_b = (_a = _this33.getState()) === null || _a === void 0 ? void 0 : _a.session) !== null && _b !== void 0 ? _b : null;
    };
    return _this33;
  }
  return _createClass(B2BSubscriptionService);
}(SubscriptionService);
var WILDCARD_ACTION = '*';
/**
 * RBACPolicy represents an instance of a parsed Stytch RBAC policy object
 * It contains methods for computing outcomes for various permissions questions
 */
var RBACPolicy = /*#__PURE__*/function () {
  function RBACPolicy(roles, resources) {
    var _this34 = this;
    _classCallCheck(this, RBACPolicy);
    this.roles = roles;
    this.resources = resources;
    this.rolesByID = {};
    roles.forEach(function (role) {
      return _this34.rolesByID[role.role_id] = role;
    });
  }
  _createClass(RBACPolicy, [{
    key: "callerIsAuthorized",
    value:
    /**
     * isAuthorized returns whether or not a user with a specific set of roles can perform a desired action
     * @example
     *  const canDoIt = policy.callerIsAuthorized(roles, 'files', 'create')
     *  console.log(canDoIt) // true
     */
    function callerIsAuthorized(memberRoles, resourceId, action) {
      var _this35 = this;
      return !!memberRoles.map(function (roleId) {
        return _this35.rolesByID[roleId];
      })
      // Defense in depth: filter out null/undefined in case memberRoles contains a role that doesn't match the policy
      // This may happen if the member is loaded _before_ a fresh RBAC policy is loaded
      .filter(function (v) {
        return v;
      }).flatMap(function (role) {
        return role.permissions;
      }).filter(function (permission) {
        return permission.resource_id === resourceId;
      }).find(function (permission) {
        return permission.actions.includes(action) || permission.actions.includes(WILDCARD_ACTION);
      });
    }
    /**
     * allPermissions generates a map that allows quick lookup of all the permissions available to the user
     * @example
     *   const perms = policy.allPermissions(roles)
     *   console.log(perms.files.create) // true
     *   console.log(perms.files.delete) // false
     */
  }, {
    key: "allPermissionsForCaller",
    value: function allPermissionsForCaller(memberRoles) {
      var _this36 = this;
      var allPermsMap = {};
      this.resources.forEach(function (resource) {
        allPermsMap[resource.resource_id] = {};
        resource.actions.forEach(function (action) {
          allPermsMap[resource.resource_id][action] = _this36.callerIsAuthorized(memberRoles, resource.resource_id, action);
        });
      });
      return allPermsMap;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(input) {
      return new RBACPolicy(input.roles, input.resources);
    }
  }]);
  return RBACPolicy;
}();
export { B2BSubscriptionService, CLIENTSIDE_SERVICES_IFRAME_URL, ConsumerSubscriptionService, DEFAULT_INTERVAL_DURATION_MS, DEFAULT_MAX_BATCH_SIZE, DEFAULT_OTP_EXPIRATION_MINUTES, DEFAULT_SESSION_DURATION_MINUTES, DFPProtectedAuthProvider, DisabledDFPProtectedAuthProvider, EmailSentType, ErrorMarshaller, EventLogger, GOOGLE_ONE_TAP_HOST, GOOGLE_ONE_TAP_SCRIPT_URL, HeadlessB2BDiscoveryClient, HeadlessB2BMagicLinksClient, HeadlessB2BOAuthClient, HeadlessB2BOTPsClient, HeadlessB2BOrganizationClient, HeadlessB2BPasswordsClient, HeadlessB2BRBACClient, HeadlessB2BSSOClient, HeadlessB2BSelfClient, HeadlessB2BSessionClient, HeadlessCryptoWalletClient, HeadlessMagicLinksClient, HeadlessOAuthClient, HeadlessOTPClient, HeadlessPasswordClient, HeadlessSessionClient, HeadlessTOTPClient, HeadlessUserClient, HeadlessWebAuthnClient, IframeEmbeddedClient, IframeHostClient, LIVE_API_URL, POWERED_BY_STYTCH_IMG_URL, RBACPolicy, RetriableError, RetriableErrorType, STYTCH_CSRF_TOKEN_NAME, STYTCH_DFP_BACKEND_URL, STYTCH_DFP_CDN_URL, STYTCH_SESSION_COOKIE, STYTCH_SESSION_JWT_COOKIE, STYTCH_WEB_BACKEND_URL, SessionManager, SubscriptionDataLayer, SubscriptionService, TEST_API_URL, WILDCARD_ACTION, baseFetchSDK, checkB2BNotSSR, checkNotSSR, checkPublicToken, createAppSessionId, createDeepEqual, createEventId, createPersistentId, isEmailMethod, isPhoneMethod, isTestPublicToken, loadESModule, logger, normalizePromiseLike, omitUser, removeResponseCommon, retriableFetchSDK, validate };
