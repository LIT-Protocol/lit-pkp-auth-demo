'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, '__esModule', {
  value: true
});

/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `oauth`, `otp`, `crypto` and `passwords`.
 */
exports.Products = void 0;
(function (Products) {
  Products["emailMagicLinks"] = "emailMagicLinks";
  Products["oauth"] = "oauth";
  Products["otp"] = "otp";
  Products["crypto"] = "crypto";
  Products["passwords"] = "passwords";
  Products["passkeys"] = "passkeys";
})(exports.Products || (exports.Products = {}));
/**
 * The OAuth providers we support in our OAuth product.
 * Currently we support `Amazon`, `Apple`, `Bitbucket`, `Discord`, `Facebook`, `Figma`, `Google`, `GitLab`,
 * `LinkedIn`, `Microsoft`, `Salesforce`, `Slack`, `Snapchat`, `TikTok`, `Twitch`, `Twitter`, and `Yahoo`.
 */
exports.OAuthProviders = void 0;
(function (OAuthProviders) {
  OAuthProviders["Google"] = "google";
  OAuthProviders["Microsoft"] = "microsoft";
  OAuthProviders["Apple"] = "apple";
  OAuthProviders["Github"] = "github";
  OAuthProviders["GitLab"] = "gitlab";
  OAuthProviders["Facebook"] = "facebook";
  OAuthProviders["Discord"] = "discord";
  OAuthProviders["Salesforce"] = "salesforce";
  OAuthProviders["Slack"] = "slack";
  OAuthProviders["Amazon"] = "amazon";
  OAuthProviders["Bitbucket"] = "bitbucket";
  OAuthProviders["LinkedIn"] = "linkedin";
  OAuthProviders["Coinbase"] = "coinbase";
  OAuthProviders["Twitch"] = "twitch";
  OAuthProviders["Twitter"] = "twitter";
  OAuthProviders["TikTok"] = "tiktok";
  OAuthProviders["Snapchat"] = "snapchat";
  OAuthProviders["Figma"] = "figma";
  OAuthProviders["Yahoo"] = "yahoo";
})(exports.OAuthProviders || (exports.OAuthProviders = {}));
/**
 * The Crypto Wallets we support in our crypto product.
 * Currently we support all ethereum and solana wallets.
 * We additionally detect and show popular wallets as distinct options.
 * The list of poular wallets include `Binance`, `Coinbase`, `Metamask`, `Phantom`, and `Vessel`
 */
exports.Wallets = void 0;
(function (Wallets) {
  Wallets["Vessel"] = "Vessel";
  Wallets["Phantom"] = "Phantom";
  Wallets["Metamask"] = "Metamask";
  Wallets["Coinbase"] = "Coinbase";
  Wallets["Binance"] = "Binance";
  Wallets["GenericEthereumWallet"] = "Other Ethereum Wallet";
  Wallets["GenericSolanaWallet"] = "Other Solana Wallet";
})(exports.Wallets || (exports.Wallets = {}));
/**
 * For Google One Tap, we support two different position options:
 * `embedded` will display Google One Tap within the existing JavaScript SDK login form
 * `floating` will display the One Tap prompt in the top right corner.
 */
exports.OneTapPositions = void 0;
(function (OneTapPositions) {
  OneTapPositions["embedded"] = "embedded";
  OneTapPositions["floating"] = "floating";
})(exports.OneTapPositions || (exports.OneTapPositions = {}));
/**
 * The methods array allows you to specify the authentication methods that you would like to expose
 * to your users. The order of the products that you include here will also be the order in which
 * they appear in the login form, with the first product specified appearing at the top of the login
 * form. We currently support passcodes on `email`, `sms` and `whatsapp`
 */
exports.OTPMethods = void 0;
(function (OTPMethods) {
  OTPMethods["SMS"] = "sms";
  OTPMethods["WhatsApp"] = "whatsapp";
  OTPMethods["Email"] = "email";
})(exports.OTPMethods || (exports.OTPMethods = {}));
exports.StytchEventType = void 0;
(function (StytchEventType) {
  StytchEventType["MagicLinkLoginOrCreateEvent"] = "MAGIC_LINK_LOGIN_OR_CREATE";
  StytchEventType["OTPsLoginOrCreateEvent"] = "OTP_LOGIN_OR_CREATE";
  StytchEventType["OTPsAuthenticate"] = "OTP_AUTHENTICATE";
  StytchEventType["CryptoWalletAuthenticateStart"] = "CRYPTO_WALLET_AUTHENTICATE_START";
  StytchEventType["CryptoWalletAuthenticate"] = "CRYPTO_WALLET_AUTHENTICATE";
  StytchEventType["PasswordCreate"] = "PASSWORD_CREATE";
  StytchEventType["PasswordAuthenticate"] = "PASSWORD_AUTHENTICATE";
  StytchEventType["PasswordResetByEmailStart"] = "PASSWORD_RESET_BY_EMAIL_START";
  StytchEventType["PasswordResetByEmail"] = "PASSWORD_RESET_BY_EMAIL";
  StytchEventType["PasskeyRegister"] = "PASSKEY_REGISTER";
  StytchEventType["PasskeyAuthenticate"] = "PASSKEY_AUTHENTICATE";
  StytchEventType["PasskeySkip"] = "PASSKEY_SKIP";
  StytchEventType["PasskeyDone"] = "PASSKEY_DONE";
  // More Events will go here ...
  // B2B Events
  StytchEventType["B2BMagicLinkEmailLoginOrSignup"] = "B2B_MAGIC_LINK_EMAIL_LOGIN_OR_SIGNUP";
  StytchEventType["B2BMagicLinkAuthenticate"] = "B2B_MAGIC_LINK_AUTHENTICATE";
  StytchEventType["B2BMagicLinkEmailDiscoverySend"] = "B2B_MAGIC_LINK_EMAIL_DISCOVERY_SEND";
  StytchEventType["B2BMagicLinkDiscoveryAuthenticate"] = "B2B_MAGIC_LINK_DISCOVERY_AUTHENTICATE";
  StytchEventType["B2BSSOStart"] = "B2B_SSO_START";
  StytchEventType["B2BSSOAuthenticate"] = "B2B_SSO_AUTHENTICATE";
  StytchEventType["B2BOAuthAuthenticate"] = "B2B_OAUTH_AUTHENTICATE";
  StytchEventType["B2BOAuthDiscoveryAuthenticate"] = "B2B_OAUTH_DISCOVERY_AUTHENTICATE";
  StytchEventType["B2BDiscoveryOrganizationsCreate"] = "B2B_DISCOVERY_ORGANIZATIONS_CREATE";
  StytchEventType["B2BDiscoveryIntermediateSessionExchange"] = "B2B_DISCOVERY_INTERMEDIATE_SESSION_EXCHANGE";
  StytchEventType["B2BPasswordAuthenticate"] = "B2B_PASSWORD_AUTHENTICATE";
  StytchEventType["B2BPasswordResetByEmailStart"] = "B2B_PASSWORD_RESET_BY_EMAIL_START";
  StytchEventType["B2BPasswordResetByEmail"] = "B2B_PASSWORD_RESET_BY_EMAIL";
  StytchEventType["B2BPasswordResetBySession"] = "B2B_PASSWORD_RESET_BY_SESSION";
})(exports.StytchEventType || (exports.StytchEventType = {}));

/**
 * An Error class thrown when the SDK is unable to reach the Stytch servers,
 * or when the Stytch servers return a value the SDK cannot understand.
 * Usually - it means that you're offline!
 */
var SDKAPIUnreachableError = /*#__PURE__*/function (_Error) {
  _inherits(SDKAPIUnreachableError, _Error);
  var _super = _createSuper(SDKAPIUnreachableError);
  function SDKAPIUnreachableError(message, details) {
    var _this;
    _classCallCheck(this, SDKAPIUnreachableError);
    _this = _super.call(this, message + '\n' + details);
    _this.message = message + '\n' + details;
    _this.name = 'SDKAPIUnreachableError';
    _this.details = details;
    Object.setPrototypeOf(_assertThisInitialized(_this), SDKAPIUnreachableError.prototype);
    return _this;
  }
  return _createClass(SDKAPIUnreachableError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input fails client-side validation -
 * for example if a field that was expected to be a number is instead a string.
 */
var StytchSDKUsageError = /*#__PURE__*/function (_Error2) {
  _inherits(StytchSDKUsageError, _Error2);
  var _super2 = _createSuper(StytchSDKUsageError);
  function StytchSDKUsageError(methodName, message) {
    var _this2;
    _classCallCheck(this, StytchSDKUsageError);
    _this2 = _super2.call(this);
    _this2.name = 'StytchSDKUsageError';
    _this2.message = "Invalid call to ".concat(methodName, "\n") + message;
    return _this2;
  }
  return _createClass(StytchSDKUsageError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class thrown when the provided input does not adhere to the Stytch API schema -
 * for example if a field that was expected to be a number is instead a string.
 */
var StytchSDKSchemaError = /*#__PURE__*/function (_Error3) {
  _inherits(StytchSDKSchemaError, _Error3);
  var _super3 = _createSuper(StytchSDKSchemaError);
  function StytchSDKSchemaError(schemaError) {
    var _this3;
    _classCallCheck(this, StytchSDKSchemaError);
    var _a;
    _this3 = _super3.call(this);
    _this3.name = 'StytchSDKSchemaError';
    var messages = (_a = schemaError.body) === null || _a === void 0 ? void 0 : _a.map(function (err) {
      return "".concat(err.dataPath, ": ").concat(err.message);
    }).join('\n');
    _this3.message = "[400] Request does not match expected schema\n".concat(messages);
    return _this3;
  }
  return _createClass(StytchSDKSchemaError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class wrapping a well-formed JSON error from the Stytch API.
 * The Stytch error should match one listed at {@link https://stytch.com/docs/api/errors}
 */
var StytchSDKAPIError = /*#__PURE__*/function (_Error4) {
  _inherits(StytchSDKAPIError, _Error4);
  var _super4 = _createSuper(StytchSDKAPIError);
  function StytchSDKAPIError(details) {
    var _this4;
    _classCallCheck(this, StytchSDKAPIError);
    _this4 = _super4.call(this);
    _this4.name = 'StytchSDKAPIError';
    var status_code = details.status_code,
      error_type = details.error_type,
      error_message = details.error_message,
      error_url = details.error_url,
      request_id = details.request_id;
    _this4.error_type = error_type;
    _this4.error_message = error_message;
    _this4.error_url = error_url;
    _this4.request_id = request_id;
    _this4.status_code = status_code;
    _this4.message = "[".concat(status_code, "] ").concat(error_type, "\n") + "".concat(error_message, "\n") + "See ".concat(error_url, " for more information.\n") + (
    // Web-Backend doesn't have request IDs yet, so if a request fails there it won't have one.
    // We should figure out how returning tracing info should work
    request_id ? "request_id: ".concat(request_id, "\n") : '');
    return _this4;
  }
  return _createClass(StytchSDKAPIError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An Error class used in the Stytch React Native SDK.
 */
var StytchSDKNativeError = /*#__PURE__*/function (_Error5) {
  _inherits(StytchSDKNativeError, _Error5);
  var _super5 = _createSuper(StytchSDKNativeError);
  function StytchSDKNativeError(error_type) {
    var _this5;
    _classCallCheck(this, StytchSDKNativeError);
    _this5 = _super5.call(this);
    _this5.name = 'StytchSDKNativeError';
    _this5.error_type = error_type;
    _this5.message = "".concat(error_type);
    return _this5;
  }
  return _createClass(StytchSDKNativeError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * If the SDK throws an error with an error type included in this array, the local session and
 * user state will be cleared locally.
 */
var UNRECOVERABLE_ERROR_TYPES = ['unauthorized_credentials', 'user_unauthenticated', 'invalid_secret_authentication', 'session_not_found'];

/**
 * Biometric error types used in the React Native SDK.
 */
exports.BiometricsErrors = void 0;
(function (BiometricsErrors) {
  BiometricsErrors["BiometricsSensorError"] = "biometrics_sensor_error";
  BiometricsErrors["DeviceCredentialsNotAllowed"] = "device_credentials_not_allowed";
  BiometricsErrors["DeviceHardwareError"] = "device_hardware_error";
  BiometricsErrors["InternalError"] = "internal_error";
  BiometricsErrors["KeyInvalidated"] = "key_invalidated";
  BiometricsErrors["KeystoreUnavailable"] = "keystore_unavailable";
  BiometricsErrors["NoBiometricsEnrolled"] = "no_biometrics_enrolled";
  BiometricsErrors["NoBiometricsRegistration"] = "no_biometrics_registration";
  BiometricsErrors["SessionExpired"] = "session_expired";
  BiometricsErrors["UserCancellation"] = "user_cancellation";
  BiometricsErrors["UserLockedOut"] = "user_locked_out";
  BiometricsErrors["BiometricsNotAvailable"] = "biometrics_not_available";
})(exports.BiometricsErrors || (exports.BiometricsErrors = {}));

/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `sso`, `passwords`, and `oauth`.
 */
exports.B2BProducts = void 0;
(function (B2BProducts) {
  B2BProducts["emailMagicLinks"] = "emailMagicLinks";
  B2BProducts["sso"] = "sso";
  B2BProducts["passwords"] = "passwords";
  B2BProducts["oauth"] = "oauth";
})(exports.B2BProducts || (exports.B2BProducts = {}));
exports.AuthFlowType = void 0;
(function (AuthFlowType) {
  AuthFlowType["Discovery"] = "Discovery";
  AuthFlowType["Organization"] = "Organization";
  AuthFlowType["PasswordReset"] = "PasswordReset";
})(exports.AuthFlowType || (exports.AuthFlowType = {}));
/**
 * The OAuth providers we support in our B2B OAuth product.
 * Currently we support `google`, and `microsoft`.
 */
exports.B2BOAuthProviders = void 0;
(function (B2BOAuthProviders) {
  B2BOAuthProviders["Google"] = "google";
  B2BOAuthProviders["Microsoft"] = "microsoft";
})(exports.B2BOAuthProviders || (exports.B2BOAuthProviders = {}));
exports.SDKAPIUnreachableError = SDKAPIUnreachableError;
exports.StytchSDKAPIError = StytchSDKAPIError;
exports.StytchSDKNativeError = StytchSDKNativeError;
exports.StytchSDKSchemaError = StytchSDKSchemaError;
exports.StytchSDKUsageError = StytchSDKUsageError;
exports.UNRECOVERABLE_ERROR_TYPES = UNRECOVERABLE_ERROR_TYPES;
