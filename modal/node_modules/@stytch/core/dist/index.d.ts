declare const TEST_API_URL = "https://test.stytch.com";
declare const LIVE_API_URL = "https://api.stytch.com";
declare const CLIENTSIDE_SERVICES_IFRAME_URL = "https://js.stytch.com/clientside-services/index.html";
declare const STYTCH_WEB_BACKEND_URL = "https://web.stytch.com";
declare const STYTCH_DFP_BACKEND_URL = "https://telemetry.stytch.com";
declare const STYTCH_DFP_CDN_URL = "https://elements.stytch.com";
declare const STYTCH_SESSION_COOKIE = "stytch_session";
declare const STYTCH_SESSION_JWT_COOKIE = "stytch_session_jwt";
declare const POWERED_BY_STYTCH_IMG_URL = "https://public-assets.stytch.com/et_powered_by_stytch_logo.png";
declare const GOOGLE_ONE_TAP_HOST = "https://accounts.google.com/gsi";
declare const GOOGLE_ONE_TAP_SCRIPT_URL: string;
declare const STYTCH_CSRF_TOKEN_NAME = "stytch_csrf_private_token";
declare const DEFAULT_SESSION_DURATION_MINUTES = 30;
declare const DEFAULT_OTP_EXPIRATION_MINUTES = 5;
// Factors
interface EmailFactor {
    delivery_method: "email" | "embedded";
    type: string;
    last_authenticated_at: string;
    email_factor: {
        email_id: string;
        email_address: string;
    };
}
interface PhoneNumberFactor {
    delivery_method: "sms" | "whatsapp";
    type: string;
    last_authenticated_at: string;
    phone_number_factor: {
        phone_id: string;
        phone_number: string;
    };
}
interface GoogleOAuthFactor {
    delivery_method: "oauth_google";
    type: string;
    last_authenticated_at: string;
    google_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface MicrosoftOAuthFactor {
    delivery_method: "oauth_microsoft";
    type: string;
    last_authenticated_at: string;
    microsoft_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface AppleOAuthFactor {
    delivery_method: "oauth_apple";
    type: string;
    last_authenticated_at: string;
    apple_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface GithubOAuthFactor {
    delivery_method: "oauth_github";
    type: string;
    last_authenticated_at: string;
    github_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface GitLabOAuthFactor {
    delivery_method: "oauth_gitlab";
    type: string;
    last_authenticated_at: string;
    gitlab_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface FacebookOAuthFactor {
    delivery_method: "oauth_facebook";
    type: string;
    last_authenticated_at: string;
    facebook_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface DiscordOAuthFactor {
    delivery_method: "oauth_discord";
    type: string;
    last_authenticated_at: string;
    discord_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface SalesforceOAuthFactor {
    delivery_method: "oauth_salesforce";
    type: string;
    last_authenticated_at: string;
    salesforce_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface SlackOAuthFactor {
    delivery_method: "oauth_slack";
    type: string;
    last_authenticated_at: string;
    slack_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface AmazonOAuthFactor {
    delivery_method: "oauth_amazon";
    type: string;
    last_authenticated_at: string;
    amazon_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface BitbucketOAuthFactor {
    delivery_method: "oauth_bitbucket";
    type: string;
    last_authenticated_at: string;
    bitbucket_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface LinkedInOAuthFactor {
    delivery_method: "oauth_linkedin";
    type: string;
    last_authenticated_at: string;
    linkedin_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface CoinbaseOAuthFactor {
    delivery_method: "oauth_coinbase";
    type: string;
    last_authenticated_at: string;
    coinbase_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface TwitchOAuthFactor {
    delivery_method: "oauth_twitch";
    type: string;
    last_authenticated_at: string;
    twitch_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface TwitterOAuthFactor {
    delivery_method: "oauth_twitter";
    type: string;
    last_authenticated_at: string;
    twitter_oauth_factor: {
        id: string;
        provider_subject: string;
    };
}
interface TikTokOAuthFactor {
    delivery_method: "oauth_tiktok";
    type: string;
    last_authenticated_at: string;
    tiktok_oauth_factor: {
        id: string;
        provider_subject: string;
    };
}
interface FigmaOAuthFactor {
    delivery_method: "oauth_figma";
    type: string;
    last_authenticated_at: string;
    figma_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface SnapchatOAuthFactor {
    delivery_method: "oauth_snapchat";
    type: string;
    last_authenticated_at: string;
    snapchat_oauth_factor: {
        id: string;
        provider_subject: string;
    };
}
interface YahooOAuthFactor {
    delivery_method: "oauth_yahoo";
    type: string;
    last_authenticated_at: string;
    yahoo_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
}
interface WebAuthnFactor {
    delivery_method: "webauthn_registration";
    type: string;
    last_authenticated_at: string;
    webauthn_factor: {
        webauthn_registration_id: string;
        domain: string;
        user_agent: string;
    };
}
interface AuthenticatorAppFactor {
    delivery_method: "authenticator_app";
    type: string;
    last_authenticated_at: string;
    authenticator_app_factor: {
        totp_id: string;
    };
}
interface RecoveryCodeFactor {
    delivery_method: "recovery_code";
    type: string;
    last_authenticated_at: string;
    recovery_code_factor: {
        totp_recovery_code_id: string;
    };
}
interface CryptoWalletFactor {
    delivery_method: "crypto_wallet";
    type: string;
    last_authenticated_at: string;
    crypto_wallet_factor: {
        crypto_wallet_id: string;
        crypto_wallet_address: string;
        crypto_wallet_type: string;
    };
}
interface PasswordFactor {
    delivery_method: "knowledge";
    type: string;
    last_authenticated_at: string;
}
type AuthenticationFactor = EmailFactor | PhoneNumberFactor | GoogleOAuthFactor | MicrosoftOAuthFactor | AppleOAuthFactor | GithubOAuthFactor | GitLabOAuthFactor | FacebookOAuthFactor | DiscordOAuthFactor | SalesforceOAuthFactor | SlackOAuthFactor | AmazonOAuthFactor | BitbucketOAuthFactor | LinkedInOAuthFactor | CoinbaseOAuthFactor | TwitchOAuthFactor | TwitterOAuthFactor | TikTokOAuthFactor | SnapchatOAuthFactor | FigmaOAuthFactor | YahooOAuthFactor | WebAuthnFactor | AuthenticatorAppFactor | RecoveryCodeFactor | CryptoWalletFactor | PasswordFactor;
type Session = {
    attributes: {
        ip_address: string;
        user_agent: string;
    };
    /**
     * All the authentication factors that have been associated with the current session.
     * @example
     * const userIsMFAd = session.authentication_factors.length > 2;
     */
    authentication_factors: AuthenticationFactor[];
    /**
     * The timestamp of the session's expiration.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    expires_at: string;
    /**
     * The timestamp of the last time the session was accessed.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    last_accessed_at: string;
    /**
     * Globally unique UUID that identifies a specific session in the Stytch API.
     */
    session_id: string;
    /**
     * The timestamp of the session's creation.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    started_at: string;
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     */
    user_id: string;
    /**
     * A map of the custom claims associated with the session.
     * Custom claims can only be set from the server, they cannot be set using the clientside SDKs.
     * After claims have been added to a session, call {@link IHeadlessSessionClient#authenticate stytch.sessions.authenticate} to refresh the session state clientside.
     * See our {@link https://stytch.com/docs/sessions#using-sessions_custom-claims guide} for more information.
     * If no claims are set, this field will be null.
     */
    custom_claims: null | Record<string, unknown>;
};
type SessionAuthenticateOptions = Partial<SessionDurationOptions>;
type SessionAuthenticateResponse = AuthenticateResponse;
type SessionRevokeOptions = {
    /**
     * When true, clear the user and session object in the local storage, even in the event of a network failure revoking the session.
     * When false, the user and session object will not be cleared in the event that the SDK cannot contact the Stytch servers.
     * The user and session object will always be cleared when the session revoke call succeeds.
     * Defaults to false
     */
    forceClear?: boolean;
};
type SessionRevokeResponse = ResponseCommon;
type SessionOnChangeCallback = (session: Session | null) => void;
type SessionTokens = {
    /**
     * An opaque session token.
     * Session tokens need to be authenticated via the {@link https://stytch.com/docs/api/session-auth SessionsAuthenticate}
     * endpoint before a user takes any action that requires authentication
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_tokens our documentation} for more information.
     */
    session_token: string;
    /**
     * A JSON Web Token that contains standard claims about the user as well as information about the Stytch session
     * Session JWTs can be authenticated locally without an API call.
     * A session JWT is signed by project-specific keys stored by Stytch.
     * You can retrieve your project's public keyset via our {@link https://stytch.com/docs/api/jwks-get GetJWKS} endpoint
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_jwts our documentation} for more information.
     */
    session_jwt: string;
};
type SessionTokensUpdate = {
    /**
     * An opaque session token.
     * Session tokens need to be authenticated via the {@link https://stytch.com/docs/api/session-auth SessionsAuthenticate}
     * endpoint before a user takes any action that requires authentication
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_tokens our documentation} for more information.
     */
    session_token: string | null;
    /**
     * A JSON Web Token that contains standard claims about the user as well as information about the Stytch session
     * Session JWTs can be authenticated locally without an API call.
     * A session JWT is signed by project-specific keys stored by Stytch.
     * You can retrieve your project's public keyset via our {@link https://stytch.com/docs/api/jwks-get GetJWKS} endpoint
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_jwts our documentation} for more information.
     */
    session_jwt: string | null;
};
interface IHeadlessSessionClient {
    /**
     * If logged in, `getSync` returns the in-memory session object. Otherwise, it returns `null`.
     * @example
     * const sess = stytch.session.getSync();
     * const hasWebAuthn = sess.authentication_factors.find(
     *   factor => factor.delivery_method === 'webauthn_registration'
     * );
     * @returns The user's active {@link Session} object or `null`
     */
    getSync(): Session | null;
    /**
     * If logged in, `getTokens` returns the session tokens currently issued to the client.
     * Stytch issues two types of tokens - opaque bearer tokens and JWTs.
     * See Stytch's {@link https://stytch.com/docs/sessions#using-sessions session management guide} for an explanation of the difference between the two.
     * On each request authenticate the user's session on the backend using one of Stytch's client libraries.
     *
     * @example
     * const {session_jwt} = stytch.session.getTokens();
     * fetch('https://api.example.com, {
     *   headers: new Headers({
     *    'Authorization': 'Bearer ' + session_jwt,
     *    credentials: 'include',
     *   }),
     * })
     *
     */
    getTokens(): SessionTokens | null;
    /**
     * Use `onChange` to register a listener for session change events.
     * If using `@stytch/react` or `@stytch/nextjs` - you may prefer the `useStytchSession` hook.
     * @example
     * stytch.session.onChange((sess) => {
     *   if(!sess) {
     *     // The user has been logged out!
     *     window.location.href = 'https://example.com/login'
     *   }
     * })
     * @param callback - {@link SessionOnChangeCallback}
     */
    onChange(callback: SessionOnChangeCallback): UnsubscribeFunction;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/session-auth authenticate } Session endpoint and validates that the session issued to the user is still valid.
     * You can call this method to programmatically extend the lifetime of the user's existing session
     * If you're trying to determine if the user is logged in, call {@link IHeadlessSessionClient.getSync} instead.
     * @example
     * stytch.session.authenticate({
     *   // Extend the session for another 60 minutes
     *   session_duration_minutes: 60
     * })
     * @param options - {@link SessionAuthenticateOptions}
     * @returns A {@link SessionAuthenticateResponse}
     */
    authenticate(options?: SessionAuthenticateOptions): Promise<SessionAuthenticateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/session-revoke revoke} Session endpoint and revokes the user's current session.
     * This method should be used to log out a user. While calling this method, we clear the user and session objects from local storage
     * unless the SDK cannot contact the Stytch servers. This behavior can be overriden by using the optional param object.
     *
     * @param options - {@link SessionRevokeOptions}
     * @example
     * stytch.sessions.revoke()
     *   .then(() => window.location.href = 'https://example.com/login');
     * @returns A {@link SessionRevokeResponse}
     */
    revoke(options?: SessionRevokeOptions): Promise<SessionRevokeResponse>;
    /**
     *  Updates the current session with a sessionToken. After setting this, you will need to make an {@link https://stytch.com/docs/api/session-auth authenticate } call to authenticate the session and retrieve the latest state.
     *
     * @param tokens - The session tokens to update to
     */
    updateSession(tokens: SessionTokensUpdate): void;
}
type ResponseCommon = {
    /**
     * Globally unique UUID that is returned with every API call.
     * This value is important to log for debugging purposes;
     * Stytch may ask for this value to help identify a specific API call when helping you debug an issue.
     */
    request_id: string;
    /**
     * The HTTP status code of the response.
     * Stytch follows standard HTTP response status code patterns, e.g. 2XX values equate to success,
     * 3XX values are redirects, 4XX are client errors, and 5XX are server errors.
     */
    status_code: number;
};
type User = {
    /**
     * The timestamp of the user's creation.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    created_at: string;
    /**
     * The `crypto_wallets` array contains a list of all crypto wallets that a user has linked via Stytch.
     */
    crypto_wallets: {
        /**
         * Globally unique UUID that identifies a specific crypto wallet in the Stytch API.
         * The `crypto_wallet_id` is used when you need to operate on a specific user's crypto wallet, e.g. to remove the crypto wallet from the Stytch user.
         */
        crypto_wallet_id: string;
        /**
         * The `crypto_wallet_address` is the actual blockchain address of this user's crypto wallet.
         */
        crypto_wallet_address: string;
        /**
         * The `crypto_wallet_type` is the blockchain that the user's crypto wallet operates on, e.g. Ethereum, Solana, etc.
         */
        crypto_wallet_type: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }[];
    /**
     * The `emails` array contains an array of `email` objects for the user.
     */
    emails: {
        /**
         * The email address.
         */
        email: string;
        /**
         * Globally unique UUID that identifies a specific email address in the Stytch API.
         * The `email_id` is used when you need to operate on a specific user's email address,
         * e.g. to delete the email address from the Stytch user.
         */
        email_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }[];
    name: {
        first_name: string;
        last_name: string;
        middle_name: string;
    };
    /**
     * A JSON object containing application-specific metadata.
     * This field can only be updated by a direct API integration.
     * Use it to store fields that a user should not be allowed to edit without backend validation - such as `role` or `subscription_status`.
     * See our {@link https://stytch.com/docs/api/metadata metadata reference} for complete details.
     */
    trusted_metadata: Record<string, unknown>;
    /**
     * A JSON object containing application-specific metadata.
     * Use it to store fields that a user can be allowed to edit directly without backend validation - such as `display_theme` or `preferred_locale`.
     * See our {@link https://stytch.com/docs/api/metadata metadata reference} for complete details.
     */
    untrusted_metadata: Record<string, unknown>;
    /**
     * The `phone_numbers` array contains an array of phone number objects for the user.
     */
    phone_numbers: {
        /**
         * A phone number.
         */
        phone_number: string;
        /**
         * Globally unique UUID that identifies a specific phone number in the Stytch API.
         * The `phone_id` is used when you need to operate on a specific user's phone number,
         * e.g. to delete the phone number from the Stytch user.
         */
        phone_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }[];
    /**
     * The `providers` array contains an array of provider objects for the user, i.e. which OAuth providers the user has used to link their account.
     */
    providers: {
        /**
         * Globally unique UUID that identifies singluar registration of a user with an OAuth identity provider in the Stytch API.
         */
        oauth_user_registration_id: string;
        /**
         * The `provider_subject` field is the unique identifier used to identify the user within a given OAuth provider.
         * Also commonly called the "sub" or "Subject field" in OAuth protocols.
         */
        provider_subject: string;
        /**
         * The `type` field denotes the OAuth identity provider that the user has authenticated with, e.g. Google, Facebook, GitHub etc.
         */
        provider_type: string;
        /**
         * If available, the `profile_picture_url` is a url of the user's profile picture set in OAuth identity the provider that the user has authenticated with, e.g. Facebook profile picture.
         */
        profile_picture_url: string;
        /**
         * If available, the `locale` is the user's locale set in the OAuth identity provider that the user has authenticated with.
         */
        locale: string;
    }[];
    /**
     * The `password` object is returned for users with a password.
     */
    password: null | {
        /**
         * Globally unique UUID that identifies a specific password in the Stytch API.
         */
        password_id: string;
        /**
         * The `requires_reset` field indicates whether the user will need to reset their password to use it in the future.
         * See {@link https://stytch.com/docs/api/password-authenticate the API docs} for explanations of scenarios where
         * this might be required.
         */
        requires_reset: boolean;
    };
    /**
     * The `status` value denotes whether or not a user has successfully logged in at least once with any available login method.
     * Possible values are `active` and `pending`.
     */
    status: "active" | "pending";
    /**
     * The `totps` array contains a list of all TOTP instances for a given user in the Stytch API.
     */
    totps: {
        /**
         * Globally unique UUID that identifies a specific TOTP instance in the Stytch API.
         * The `totp_id` is used when you need to operate on a specific user's TOTP instance, e.g. to delete the TOTP instance from the Stytch user.
         */
        totp_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }[];
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
    /**
     * The `webauthn_registrations` array contains a list of all WebAuthn registrations for a given user in the Stytch API.
     */
    webauthn_registrations: WebAuthnRegistration[];
    /**
     * The `biometric_registrations` array contains a list of all Biometric registrations for a given user in the Stytch API.
     */
    biometric_registrations: {
        /**
         * Globally unique UUID that identifies a specific Biometric registration in the Stytch API.
         * The `biometric_registration_id` is used when you need to operate on a specific user's Biometric registration,
         * e.g. to delete the Biometric instance from the Stytch user.
         */
        biometric_registration_id: string;
        /**
         * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
         */
        verified: boolean;
    }[];
};
type WebAuthnRegistration = {
    /**
     * The `domain` on which a WebAuthn registration was started.
     * This will be the domain of your app.
     */
    domain: string;
    /**
     * The `user_agent` of the user's browser or device.
     */
    user_agent: string;
    /**
     * The `authenticator_type` string displays the requested authenticator type of the WebAuthn device.
     * The two valid types are "platform" and "cross-platform".
     * If no value is present, the WebAuthn device was created without an authenticator type preference.
     */
    authenticator_type: string;
    /**
     * The `verified` boolean denotes whether or not this method has been successfully authenticated by the user.
     */
    verified: boolean;
    /**
     * Globally unique UUID that identifies a specific WebAuthn registration in the Stytch API.
     * The `webauthn_registration_id` is used when you need to operate on a specific user's WebAuthn registration,
     * e.g. to delete the WebAuthn instance from the Stytch user.
     */
    webauthn_registration_id: string;
    /**
     * The name of the WebAuthn device. We randomly generate the field to begin with but you can update it to a
     * custom value via the {@link https://stytch.com/docs/api/webauthn-update WebAuthnUpdate} endpoint.
     * TODO: Ensure this value is correct.
     */
    name: string;
};
type AuthenticateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
    /**
     * An opaque session token.
     * Session tokens need to be authenticated via the {@link https://stytch.com/docs/api/session-auth SessionsAuthenticate}
     * endpoint before a user takes any action that requires authentication
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_tokens our documentation} for more information.
     */
    session_token: string;
    /**
     * A JSON Web Token that contains standard claims about the user as well as information about the Stytch session
     * Session JWTs can be authenticated locally without an API call.
     * A session JWT is signed by project-specific keys stored by Stytch.
     * You can retrieve your project's public keyset via our {@link https://stytch.com/docs/api/jwks-get GetJWKS} endpoint
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_jwts our documentation} for more information.
     */
    session_jwt: string;
    /**
     * The Session object created.
     * See {@link Session} for details.
     */
    session: Session;
    /**
     * The user object affected by this API call.
     * See the {@link https://stytch.com/docs/api/get-user Get user} endpiont for complete response field detail.
     */
    user: User;
};
type DeleteResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
};
type UpdateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     * The user_id critical to perform operations on a user in our API, like Get user, Delete user, etc,
     * so be sure to preserve this value.
     */
    user_id: string;
};
type SessionDurationOptions = {
    /**
     * Set the session lifetime to be this many minutes from now.
     * This will return both an opaque `session_token` and `session_jwt` for this session, which will automatically be stored in the browser cookies.
     * The `session_jwt` will have a fixed lifetime of five minutes regardless of the underlying session duration, and will be automatically refreshed by the SDK in the background over time.
     * This value must be a minimum of 5 and may not exceed the maximum session duration minutes value set in the
     * {@link https://stytch.com/dashboard/sdk-configuration SDK Configuration } page of the Stytch dashboard.
     */
    session_duration_minutes: number;
};
type UnsubscribeFunction = () => void;
type StytchClientOptions = {
    cookieOptions?: {
        /**
         * The name of the cookie containing the opaque Stytch session token.
         * Defaults to `stytch_session`
         */
        opaqueTokenCookieName?: string;
        /**
         * The name of the cookie containing the opaque Stytch session token.
         * Defaults to `stytch_session_jwt`
         */
        jwtCookieName?: string;
        /**
         * The name of the cookie containing the Stytch intermediate session token.
         * Defaults to `stytch_intermediate_session_token`
         */
        istCookieName?: string;
        /**
         * What HTTP path the cookies should be available on.
         * Equal to configuring the `;path=${}` param in the set-cookie directive.
         * Defaults to unset.
         */
        path?: string;
        /**
         * What domain the cookies should be available on.
         * Equal to configuring the `;domain=${}` param in the set-cookie directive.
         * The domain _must_ match the domain of the Javascript origin the SDK is running on.
         * Also requires setting availableToSubdomains: true to have any effect.
         * Defaults to unset.
         */
        domain?: string;
        /**
         * Whether to make the cookies available to subdomains.
         * When true, equivalent to configuring the `;domain=${window.location.host}` directive
         * When false, equivalent to leaving the directive unset
         * Defaults to false.
         */
        availableToSubdomains?: boolean;
    };
};
type ConsumerState = {
    user?: User;
    session?: Session;
};
type locale = "en" | "es" | "pt-br" | string;
type OAuthGetURLOptions = {
    /**
     * The URL that Stytch redirects to after the OAuth flow is completed for a user that already exists.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /oauth/authenticate endpoint and finishes the login.
     * The URL should be configured as a Login URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    login_redirect_url?: string;
    /**
     * The URL that Stytch redirects to after the OAuth flow is completed for a user that does not yet exist.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /oauth/authenticate endpoint and finishes the login.
     * The URL should be configured as a Sign Up URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    signup_redirect_url?: string;
    /**
     * An optional list of custom scopes that you'd like to request from the user in addition to the ones Stytch requests by default.
     * @example Google Custom Scopes
     * ['https://www.googleapis.com/auth/gmail.compose', 'https://www.googleapis.com/auth/firebase']
     *
     * @example Facebook Custom Scopes
     * ['public_profile', 'instagram_shopping_tag_products']
     */
    custom_scopes?: string[];
    /**
     * An optional mapping of provider specific values to pass through to the OAuth provider
     * @example Google authorization parameters
     * {"prompt": "select_account", "login_hint": "example@stytch.com"}
     */
    provider_params?: Record<string, string>;
};
type OAuthAuthenticateOptions = SessionDurationOptions;
type OAuthAuthenticateResponse = AuthenticateResponse & {
    /**
     * The `provider_subject` field is the unique identifier used to identify the user within a given OAuth provider.
     * Also commonly called the "sub" or "Subject field" in OAuth protocols.
     */
    provider_subject: string;
    /**
     * The `type` field denotes the OAuth identity provider that the user has authenticated with, e.g. Google, Facebook, GitHub etc.
     */
    provider_type: string;
    /**
     * If available, the `profile_picture_url` is a url of the user's profile picture set in OAuth identity the provider that the user has authenticated with, e.g. Facebook profile picture.
     */
    profile_picture_url: string;
    /**
     * If available, the `locale` is the user's locale set in the OAuth identity provider that the user has authenticated with.
     */
    locale: string;
    /**
     * The `provider_values` object lists relevant identifiers, values, and scopes for a given OAuth provider.
     * For example this object will include a provider's `access_token` that you can use to access the provider's API for a given user.
     * Note that these values will vary based on the OAuth provider in question, e.g. `id_token` may not be returned by all providers.
     */
    provider_values: {
        /**
         * The `access_token` that you may use to access the user's data in the provider's API.
         */
        access_token: string;
        /**
         * The `id_token` returned by the OAuth provider.
         * ID Tokens are JWTs that contain structured information about a user.
         * The exact content of each ID Token varies from provider to provider.
         * ID Tokens are returned from OAuth providers that conform to the {@link https://openid.net/foundation/ OpenID Connect} specification, which is based on OAuth.
         */
        id_token: string;
        /**
         * The `refresh_token` that you may use to refresh a user's session within the provider's API.
         */
        refresh_token: string;
        /**
         * The OAuth scopes included for a given provider.
         * See each provider's section above to see which scopes are included by default and how to add custom scopes.
         */
        scopes: string[];
    };
};
type OAuthStartFailureReason = "User Canceled" | "Authentication Failed" | "Invalid Platform";
type OAuthStartResponse = void | {
    success: true;
} | {
    success: false;
    reason: OAuthStartFailureReason;
    error?: Error;
};
/**
 * Methods for interacting with an individual OAuth provider.
 */
interface IOAuthProvider {
    /**
     * Start an OAuth flow by redirecting the browser to one of Stytch's {@link https://stytch.com/docs/api/oauth-google-start oauth start} endpoints.
     * If enabled, this method will also generate a PKCE code_verifier and store it in localstorage on the device (See the {@link https://stytch.com/docs/oauth#guides_pkce PKCE OAuth guide} for details).
     * If your application is configured to use a custom subdomain with Stytch, it will be used automatically.
     * @example
     * const loginWithGoogle = useCallback(()=> {
     *   stytch.oauth.google.start({
     *     login_redirect_url: 'https://example.com/oauth/callback',
     *     signup_redirect_url: 'https://example.com/oauth/callback',
     *     custom_scopes: ['https://www.googleapis.com/auth/gmail.compose']
     *   })
     * }, [stytch]);
     * return (
     *   <Button onClick={loginWithGoogle}> Log in! </Button>
     * );
     *
     * @param options - An {@link OAuthGetURLOptions} object
     *
     * @returns OAuthStartResponse - In browsers, the browser is redirected during this function call and will return void. You should not attempt to run any code after calling this function. In React Native applications, an external browser is opened, and this method will return the result of the browser/native authentication attempt.
     *
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    start(options?: OAuthGetURLOptions): Promise<OAuthStartResponse>;
}
interface IHeadlessOAuthClient {
    google: IOAuthProvider;
    microsoft: IOAuthProvider;
    apple: IOAuthProvider;
    github: IOAuthProvider;
    gitlab: IOAuthProvider;
    facebook: IOAuthProvider;
    discord: IOAuthProvider;
    salesforce: IOAuthProvider;
    slack: IOAuthProvider;
    amazon: IOAuthProvider;
    bitbucket: IOAuthProvider;
    linkedin: IOAuthProvider;
    coinbase: IOAuthProvider;
    twitch: IOAuthProvider;
    twitter: IOAuthProvider;
    tiktok: IOAuthProvider;
    snapchat: IOAuthProvider;
    figma: IOAuthProvider;
    yahoo: IOAuthProvider;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/oauth-authenticate oauth authenticate} endpointwhich validates the OAuth token passed in.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * const token = new URLSearchParams(window.location.search).get('token');
     * stytch.oauth.authenticate(token, {
     *   session_duration_minutes: 60
     * }).then(...)
     *
     * @param token - The token to authenticate
     * @param options - {@link OAuthAuthenticateOptions}
     *
     * @returns A {@link OAuthAuthenticateResponse} indicating the token has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(token: string, options: OAuthAuthenticateOptions): Promise<OAuthAuthenticateResponse>;
}
type UserOnChangeCallback = (user: User | null) => void;
type UserUpdateOptions = {
    /**
     * The name of the user. If at least one name field is passed, all name fields will be updated.
     */
    name?: {
        /**
         * The first name of the user. Replaces an existing first name, if it exists.
         */
        first_name?: string;
        /**
         * The middle name(s) of the user. Replaces an existing middle name, if it exists.
         */
        middle_name?: string;
        /**
         * The last name of the user. Replaces an existing last name, if it exists.
         */
        last_name?: string;
    };
    /**
     * A JSON object containing application-specific metadata.
     * Use it to store fields that a user can be allowed to edit directly without backend validation - such as `display_theme` or `preferred_locale`.
     * See our {@link https://stytch.com/docs/api/metadata metadata reference} for complete details.
     */
    untrusted_metadata?: Record<string, unknown>;
};
type UserUpdateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     */
    user_id: string;
    /**
     * The updated emails for the user.
     */
    emails: User["emails"];
    /**
     * The updated phone numbers for the user.
     */
    phone_numbers: User["phone_numbers"];
    /**
     * The updated crypto wallets for the user.
     */
    crypto_wallets: User["crypto_wallets"];
};
interface IHeadlessUserClient {
    /**
     * The asynchronous method for getting a user. This wraps the {@link https://stytch.com/docs/api/get-user get} user endpoint.
     * It fetches the user's data and refreshes the cached object if changes are detected.
     * The Stytch SDK will invoke this method automatically in the background, so you probably won't need to call this method directly.
     *
     * @returns A {@link User} object, or null if no user exists.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    get(): Promise<User | null>;
    /**
     * Wraps Stytch's {@link update https://stytch.com/docs/api/update-user} user endpoint. Use this method to change the user's name.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * const updateName = useCallback(() => {
     *  stytchClient.user.update({
     *    name: {
     *      first_name: 'Jane',
     *      last_name: 'Doe',
     *    },
     *  });
     * }, [stytchClient]);
     * ```
     *
     * @param options - {@link UserUpdateOptions}
     *
     * @returns A {@link UserUpdateResponse} indicating the user has been updated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    update(options: UserUpdateOptions): Promise<UserUpdateResponse>;
    /**
     * The synchronous method for getting a user. This is the recommended approach. You can listen to changes with the {@link onChange onChange} method.
     * If logged in, this returns the cached user object, otherwise it returns null. This method does not refresh the user's data.
     * The `stytch-react` library provides the `useStytchUser` hook that implements these methods for you to easily access the user and listen for changes.
     *
     * @returns A {@link User} object, or null if no user exists.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    getSync(): User | null;
    /**
     * Allows listening to changes in the user object when using {@link getSync getSync()}.
     *
     * @param callback - Gets called whenever the user object changes. See {@link UserOnChangeCallback}.
     *
     * @returns An {@link UnsubscribeFunction} for you to call when you no longer want to listen for changes in the user object.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    onChange(callback: UserOnChangeCallback): UnsubscribeFunction;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-email delete user email} endpoint.
     * This methods cannot be used to remove all factors from a user. A user must have at least one email, phone number, or OAuth provider associated with their account at all times, otherwise they will not be able to log in again.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param emailId - ID of the email to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user email has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteEmail(emailId: string): Promise<DeleteResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-phone-number delete phone number} endpoint.
     * This methods cannot be used to remove all factors from a user. A user must have at least one email, phone number, or OAuth provider associated with their account at all times, otherwise they will not be able to log in again.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param phoneId - ID of the phone number to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user phone number has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deletePhoneNumber(phoneId: string): Promise<DeleteResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-totp delete TOTP} endpoint.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param totpId - ID of the TOTP registration to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user TOTP registration has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteTOTP(totpId: string): Promise<DeleteResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-oauth-registration delete OAuth} endpoint.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param oauthUserRegistrationId - ID of the OAuth registration to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user OAuth registration has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteOAuthRegistration(oauthUserRegistrationId: string): Promise<DeleteResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-webauthn-registration delete WebAuthn} endpoint.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @param webAuthnId - ID of the WebAuthn registration to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user WebAuthn registration has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteWebauthnRegistration(webAuthnId: string): Promise<DeleteResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/delete-user-biometric-registration delete biometric} endpoint.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     *
     * @param biometricRegistrationId - ID of the biometric registration to be deleted.
     *
     * @returns A {@link DeleteResponse} that indicates the user Biometric registration has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteBiometricRegistration(biometricRegistrationId: string): Promise<DeleteResponse>;
}
type MagicLinksBaseOptions = {
    /**
     * The url the user clicks from the sign-up email magic link.
     * This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and sign-up the user.
     * If this value is not passed, the default sign-up redirect URL that you set in your Dashboard is used.
     * If you have not set a default sign-up redirect URL, an error is returned.
     */
    signup_magic_link_url?: string;
    /**
     * Set the expiration for the sign-up email magic link, in minutes.
     * By default, it expires in 1 week.
     * The minimum expiration is 5 minutes and the maximum is 10080 minutes (7 days).
     */
    signup_expiration_minutes?: number;
    /**
     * The url the user clicks from the login email magic link.
     * This should be a url that your app receives and parses and subsequently send an API request to authenticate the magic link and log in the user.
     * If this value is not passed, the default login redirect URL that you set in your Dashboard is used.
     * If you have not set a default login redirect URL, an error is returned.
     */
    login_magic_link_url?: string;
    /**
     * Set the expiration for the login email magic link, in minutes.
     * By default, it expires in 1 hour.
     * The minimum expiration is 5 minutes and the maximum is 10080 minutes (7 days).
     */
    login_expiration_minutes?: number;
    /**
     * The email template ID to use for login emails.
     * If not provided, your default email template will be sent. If providing a template ID, it must be either a template using Stytch's customizations,
     * or a Magic link Login custom HTML template.
     */
    login_template_id?: string;
    /**
     * The email template ID to use for sign-up emails.
     * If not provided, your default email template will be sent. If providing a template ID, it must be either a template using Stytch's customizations,
     * or a Magic link Sign-up custom HTML template.
     */
    signup_template_id?: string;
};
type MagicLinksLoginOrCreateOptions = MagicLinksBaseOptions;
type MagicLinksSendOptions = MagicLinksBaseOptions;
type MagicLinksLoginOrCreateResponse = ResponseCommon;
type MagicLinksSendResponse = ResponseCommon;
type MagicLinksAuthenticateOptions = SessionDurationOptions;
type MagicLinksAuthenticateResponse = AuthenticateResponse & {
    /**
     * The ID of the method used to send a magic link.
     */
    method_id: string;
};
interface IHeadlessMagicLinksClient {
    email: {
        /**
         * The loginOrCreate method wraps the {@link https://stytch.com/docs/api/log-in-or-create-user-by-email login_or_create} Email magic link API endpoint.
         *
         * See the {@link https://stytch.com/docs/sdks/javascript-sdk#email-magic-links_methods_send Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.magicLinks.email.loginOrCreate('sandbox@stytch.com', {
         *   login_magic_link_url: 'https://example.com/authenticate',
         *   login_expiration_minutes: 60,
         *   signup_magic_link_url: 'https://example.com/authenticate',
         *   signup_expiration_minutes: 60,
         * });
         *
         * @param email - The email of the user to send the invite magic link to.
         * @param options - {@link MagicLinksLoginOrCreateOptions}
         *
         * @returns A {@link MagicLinksLoginOrCreateResponse} indicating that the email has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        loginOrCreate(email: string, options?: MagicLinksLoginOrCreateOptions): Promise<MagicLinksLoginOrCreateResponse>;
        /**
         * The send method wraps the {@link https://stytch.com/docs/api/send-by-email send} Email magic link API endpoint.
         *
         * See the {@link https://stytch.com/docs/sdks/javascript-sdk#email-magic-links_methods_send Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.magicLinks.email.send('sandbox@stytch.com', {
         *   login_magic_link_url: 'https://example.com/authenticate',
         *   login_expiration_minutes: 60,
         *   signup_magic_link_url: 'https://example.com/authenticate',
         *   signup_expiration_minutes: 60,
         * });
         *
         * @param email - The email of the user to send the invite magic link to.
         * @param options - {@link MagicLinksSendOptions}
         *
         * @returns A {@link MagicLinksSendResponse} indicating that the email has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        send(email: string, options?: MagicLinksSendOptions): Promise<MagicLinksSendResponse>;
    };
    /**
     * The Authenticate method wraps the {@link https://stytch.com/docs/api/authenticate-magic-link authenticate}
     * Magic link API endpoint which validates the magic link token passed in.
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * See the {@link https://stytch.com/docs/sdks/javascript-sdk#email-magic-links_methods_authenticate Stytch Docs} for a complete reference.
     *
     * @example
     * const currentLocation = new URL(window.location.href);
     * const token = currentLocation.searchParams.get('token');
     * stytch.magicLinks.authenticate(token, {
     *   session_duration_minutes: 60,
     * });
     *
     * @param token - The magic link token from the token query parameter in the URL.
     * @param options - {@link MagicLinksLoginOrCreateOptions}
     *
     * @returns A {@link MagicLinksAuthenticateResponse} indicating that magic link has been authenticated and the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    authenticate(token: string, options: MagicLinksAuthenticateOptions): Promise<MagicLinksAuthenticateResponse>;
}
type OTPCodeOptions = {
    /**
     * Set the expiration for the one-time passcode, in minutes. The minimum expiration is 1 minute and the maximum is 10 minutes. The default expiration is 2 minutes.
     */
    expiration_minutes: number;
};
type OTPCodeEmailOptions = OTPCodeOptions & {
    /**
     * The email template ID to use for login emails.
     * If not provided, your default email template will be sent. If providing a template ID, it must be either a template using Stytch's customizations,
     * or a OTP Login custom HTML template.
     */
    login_template_id?: string;
    /**
     * The email template ID to use for sign-up emails.
     * If not provided, your default email template will be sent. If providing a template ID, it must be either a template using Stytch's customizations,
     * or a OTP Sign-up custom HTML template.
     */
    signup_template_id?: string;
};
type OTPAuthenticateOptions = {
    /**
     * Set the session lifetime to be this many minutes from now.
     * This value must be a minimum of 5 and may not exceed the `maximum session duration minutes` value set in the {@link https://stytch.com/dashboard/sdk-configuration SDK Configuration} page of the Stytch dashboard.
     * A successful authentication will continue to extend the session this many minutes.
     */
    session_duration_minutes: number;
};
type OTPsBaseResponse = ResponseCommon & {
    /**
     * The ID of the method used to send a one-time passcode.
     */
    method_id: string;
};
type OTPsLoginOrCreateResponse = OTPsBaseResponse;
type OTPsSendResponse = OTPsBaseResponse;
type OTPsAuthenticateResponse = AuthenticateResponse & {
    /**
     * The ID of the method used to send a one-time passcode.
     */
    method_id: string;
};
interface IHeadlessOTPsClient {
    sms: {
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/log-in-or-create-user-by-sms login_or_create} via SMS API endpoint. Call this method to send an SMS passcode to new or existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.sms.loginOrCreate('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsLoginOrCreateResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        loginOrCreate(phone_number: string, options?: OTPCodeOptions): Promise<OTPsLoginOrCreateResponse>;
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/send-otp-by-sms send} via SMS API endpoint. Call this method to send an SMS passcode to existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.sms.send('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsSendResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(phone_number: string, options?: OTPCodeOptions): Promise<OTPsSendResponse>;
    };
    whatsapp: {
        /**
         *  Wraps Stytch's {@link https://stytch.com/docs/api/log-in-or-create-user-by-whatsapp login_or_create} via WhatsApp API endpoint. Call this method to send a WhatsApp passcode to new or existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.whatsapp.loginOrCreate('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsLoginOrCreateResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        loginOrCreate(phone_number: string, options?: OTPCodeOptions): Promise<OTPsLoginOrCreateResponse>;
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/whatsapp-send send} via WhatsApp API endpoint. Call this method to send an WhatsApp passcode to existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.whatsapp.send('+12025550162', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param phone_number - The phone number of the user to send a one-time passcode. The phone number should be in E.164 format (i.e. +1XXXXXXXXXX). You may use +10000000000 to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeOptions}
         *
         * @returns A {@link OTPsSendResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(phone_number: string, options?: OTPCodeOptions): Promise<OTPsSendResponse>;
    };
    email: {
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/log-in-or-create-user-by-email login_or_create} via email API endpoint. Call this method to send an email passcode to new or existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.email.loginOrCreate('sandbox@stytch.com', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param email - The email address of the user to send the one-time passcode to. You may use sandbox@stytch.com to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeEmailOptions}
         *
         * @returns A {@link OTPsLoginOrCreateResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        loginOrCreate(email: string, options?: OTPCodeEmailOptions): Promise<OTPsLoginOrCreateResponse>;
        /**
         * Wraps Stytch's {@link https://stytch.com/docs/api/send-otp-by-email send} via Email API endpoint. Call this method to send an email passcode to existing users.
         *
         * @example
         * ```
         * const sendPasscode = useCallback(() => {
         *  stytchClient.otps.email.send('sandbox@stytch.com', {
         *    expiration_minutes: 5,
         *  });
         * }, [stytchClient]);
         * ```
         *
         * @param email - The email address of the user to send the one-time passcode to. You may use sandbox@stytch.com to test this endpoint, see {@link https://stytch.com/docs/testing Testing} for more detail.
         * @param options - {@link OTPCodeEmailOptions}
         *
         * @returns A {@link OTPsSendResponse} indicating the one-time passcode has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(email: string, options?: OTPCodeEmailOptions): Promise<OTPsSendResponse>;
    };
    /**
     * The authenticate method wraps the {@link https://stytch.com/docs/api/authenticate-otp authenticate} one-time passcode API method which validates the code passed in.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link session cookies https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * const [code, setCode] = useState('');
     *
     * const method_id = "phone-number-test-d5a3b680-e8a3-40c0-b815-ab79986666d0"
     * // returned from calling loginOrCreate for OTPs on SMS, WhatsApp or Email
     *
     * const authenticate = useCallback((e) => {
     *  e.preventDefault();
     *  stytchClient.otps.authenticate(code, method_id, {
     *    session_duration_minutes: 60,
     *  });
     * }, [stytchClient, code]);
     *
     * const handleChange = useCallback((e) => {
     *  setCode(e.target.value);
     * }, []);
     * ```
     *
     * @param otp - The code to authenticate.
     * @param method_id - The ID of the method used to send a one-time passcode.
     * @param options - {@link OTPAuthenticateOptions}
     *
     * @returns A {@link OTPsAuthenticateResponse} indicating the one-time passcode method has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(otp: string, method_id: string, options?: OTPAuthenticateOptions): Promise<OTPsAuthenticateResponse>;
}
type CryptoWalletAuthenticateStartOptions = {
    /**
     * The address to authenticate.
     */
    crypto_wallet_address: string;
    /**
     * The type of wallet to authenticate. Currently `ethereum` and `solana` are supported.
     */
    crypto_wallet_type: string;
};
type CryptoWalletAuthenticateStartResponse = ResponseCommon & {
    /**
     * The challenge to be signed by the user's wallet.
     */
    challenge: string;
};
type CryptoWalletAuthenticateOptions = SessionDurationOptions & {
    /**
     * The address to authenticate.
     */
    crypto_wallet_address: string;
    /**
     * The type of wallet to authenticate. Currently `ethereum` and `solana` are supported.
     */
    crypto_wallet_type: string;
    /**
     * The signature from the message.
     */
    signature: string;
};
type CryptoWalletAuthenticateResponse = AuthenticateResponse;
interface IHeadlessCryptoWalletClient {
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/crypto-wallet-authenticate-start authenticate_start} crypto wallet endpoint. Call this method to load the challenge data. Pass this challenge to your user's wallet for signing.
     *
     * @example
     * ```
     * // Request user's address
     * const [crypto_wallet_address] = await ethereum.request({
     *   method: 'eth_requestAccounts',
     * });
     *
     * // Ask Stytch to generate a challenge for the user
     * const { challenge } = await stytch.cryptoWallets.authenticateStart({
     *   crypto_wallet_address: crypto_wallet_address,
     *   crypto_wallet_type: 'ethereum',
     * });
     * ```
     * @param options - {@link CryptoWalletAuthenticateStartOptions}
     *
     * @returns A {@link CryptoWalletAuthenticateStartResponse} containing a challenge to be passed to the user's wallet for signing.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticateStart(options: CryptoWalletAuthenticateStartOptions): Promise<CryptoWalletAuthenticateStartResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/crypto-wallet-authenticate authenticate} crypto wallet endpoint. Call this method after the user signs the challenge to validate the signature.
     * If this method succeeds and the user is not already logged in, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * If the user is already logged in, the crypto wallet will be added to the `user.crypto_wallets[]` array and associated with user's existing session as an `authentication_factor`.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * // Ask the user to sign the challenge
     * const signature = await ethereum.request({
     *   method: 'personal_sign',
     *   params: [challenge, crypto_wallet_address],
     * });
     *
     * // Authenticate the signature
     * stytch.cryptoWallets.authenticate({
     *  crypto_wallet_address: crypto_wallet_address,
     *  crypto_wallet_type: 'ethereum',
     *  signature: signature,
     *  session_duration_minutes: 60,
     * });
     * ```
     *
     * @param options - {@link CryptoWalletAuthenticateOptions}
     *
     * @returns A {@link CryptoWalletAuthenticateResponse} indicating the user has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(options: CryptoWalletAuthenticateOptions): Promise<CryptoWalletAuthenticateResponse>;
}
type TOTPCreateOptions = {
    /**
     * The expiration for the TOTP instance. If the newly created TOTP is not authenticated within this time frame the TOTP will be unusable. Defaults to 60 (1 hour) with a minimum of 5 and a maximum of 1440.
     */
    expiration_minutes: number;
};
type TOTPCreateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
    /**
     * The TOTP secret key shared between the authenticator app and the server used to generate TOTP codes.
     */
    secret: string;
    /**
     * The QR code image encoded in base64.
     */
    qr_code: string;
    /**
     * The recovery codes used to authenticate the user without an authenticator app.
     */
    recovery_codes: string[];
};
type TOTPAuthenticateOptions = SessionDurationOptions & {
    /**
     * The TOTP code to authenticate. The TOTP code should consist of 6 digits.
     */
    totp_code: string;
};
type TOTPAuthenticateResponse = AuthenticateResponse & {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
};
type TOTPRecovery = {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
    /**
     * Indicates whether or not the TOTP registration has been verified by the user.
     */
    verified: boolean;
    /**
     * The recovery codes for the TOTP registration.
     */
    recovery_codes: string[];
};
type TOTPRecoveryCodesResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific user in the Stytch API.
     */
    user_id: string;
    /**
     * See {@link TOTPRecovery}.
     */
    totps: TOTPRecovery;
};
type TOTPRecoverOptions = SessionDurationOptions & {
    /**
     * The recovery code to authenticate.
     */
    recovery_code: string;
};
type TOTPRecoverResponse = AuthenticateResponse & {
    /**
     * Globally unique UUID that identifies a specific TOTP registration in the Stytch API.
     */
    totp_id: string;
};
interface IHeadlessTOTPClient {
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-create create} endpoint. Call this method to create a new TOTP instance for a user. The user can use the authenticator application of their choice to scan the QR code or enter the secret.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * stytchClient.totps.create({ expiration_minutes: 60 });
     * ```
     *
     * @param options - {@link TOTPCreateOptions}
     *
     * @returns A {@link TOTPCreateResponse} indicating a new TOTP instance has been created.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    create(options: TOTPCreateOptions): Promise<TOTPCreateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-authenticate authenticate} endpoint. Call this method to authenticate a TOTP code entered by a user.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * stytch.totps.authenticate({ totp_code: '123456', session_duration_minutes: 60 });
     * ```
     *
     * @param options - {@link TOTPAuthenticateOptions}
     *
     * @returns A {@link TOTPAuthenticateResponse} indicating the TOTP code has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(options: TOTPAuthenticateOptions): Promise<TOTPAuthenticateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-get-recovery-codes recovery_codes} endpoint. Call this method to retrieve the recovery codes for a TOTP instance tied to a user.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * stytchClient.totps.recoveryCodes();
     * ```
     *
     * @returns A {@link TOTPRecoveryCodesResponse} containing the TOTP recovery codes tied to the user.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    recoveryCodes(): Promise<TOTPRecoveryCodesResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/totp-recover recover} endpoint. Call this method to authenticate a recovery code for a TOTP instance.
     * If this method succeeds, the user will be logged in, granted an active session, and the {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * stytch.totps.recover({ recovery_code: 'xxxx-xxxx-xxxx', session_duration_minutes: 60 });
     * ```
     *
     * @param options - {@link TOTPRecoverOptions}
     *
     * @returns A {@link TOTPRecoverResponse} indicating the TOTP recovery code has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    recover(options: TOTPRecoverOptions): Promise<TOTPRecoverResponse>;
}
type WebAuthnRegisterStartOptions = SessionDurationOptions & {
    /**
     * The domain for the WebAuthn registration. Defaults to `window.location.hostname`.
     */
    domain?: string;
    /**
     * The requested authenticator type of the WebAuthn device. The two valid values are `platform` and `cross-platform`. If no value passed, we assume both values are allowed.
     */
    authenticator_type?: "platform" | "cross-platform";
    /**
     * Whether the flow should be optimized for Passkeys.
     */
    is_passkey?: boolean;
};
type WebAuthnRegisterResponse = AuthenticateResponse & {
    /**
     * A unique ID that identifies a specific WebAuthn registration.
     */
    webauthn_registration_id: string;
};
type WebAuthnAuthenticateStartOptions = SessionDurationOptions & {
    /**
     * The domain for the WebAuthn registration.
     */
    domain?: string;
    /**
     * Whether the flow should be optimized for Passkeys.
     */
    is_passkey?: boolean;
    /**
     * Whether to use conditional mediation (autofill) in the authentication flow.
     */
    conditional_mediation?: boolean;
    /**
     * An optional `AbortSignal` to allow aborting the authentication process.
     */
    signal?: AbortSignal;
};
type WebAuthnAuthenticateResponse = AuthenticateResponse & {
    /**
     * A unique ID that identifies a specific WebAuthn registration.
     */
    webauthn_registration_id: string;
};
type WebAuthnUpdateOptions = {
    /**
     * A unique ID that identifies a specific WebAuthn registration.
     */
    webauthn_registration_id: string;
    /**
     * A readable name for the registration.
     */
    name: string;
};
type WebAuthnUpdateResponse = ResponseCommon & {
    /**
     * The webauthn registration object.
     */
    webauthn_registration: WebAuthnRegistration;
};
interface IHeadlessWebAuthnClient {
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/webauthn-register-start register_start} and {@link https://stytch.com/docs/api/webauthn-register register} WebAuthn endpoints and the {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create navigator.credentials} web API. Call this method to prompt the user to enroll a new WebAuthn factor and save the factor in Stytch.
     * You can listen for successful user updates anywhere in the codebase with the `stytch.user.onChange()` method or `useStytchUser()` hook if you are using React.
     * Note: If a user has enrolled another MFA method, this method will require MFA. See the {@link https://stytch.com/docs/sdks/javascript-sdk#resources_multi-factor-authentication Multi-factor authentication} section for more details.
     *
     * @example
     * ```
     * const registerWebAuthn = useCallback(() => {
     *  stytchClient.register({
     *    domain: 'subdomain.example.com',
     *    authenticator_type: 'platform'
     *  });
     * }, [stytchClient]);
     * ```
     *
     * @param options - {@link WebAuthnRegisterStartOptions}
     *
     * @returns A {@link WebAuthnRegisterResponse} indicating WebAuthn has been registered.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    register(options?: WebAuthnRegisterStartOptions): Promise<WebAuthnRegisterResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/api/webauthn-authenticate-start authenticate_start} and {@link https://stytch.com/docs/api/webauthn-authenticate authenticate} WebAuthn endpoints and the navigator.credentials web API.
     * Call this method to prompt the user to authenticate an existing WebAuthn registration.
     * In order to use these methods, the user must have already logged in with a primary method - OAuth, one-time passcodes, or magic links.
     * If this method succeeds, the WebAuthn credential will be added to the user's existing session as an `authentication_factor`, the user will be logged in, granted an active session, and the session cookies will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * ```
     * const authenticateWebAuthn = useCallback(() => {
     *  stytchClient.webauthn.authenticate({
     *    domain: 'subdomain.example.com',
     *    session_duration_minutes: 60,
     *  });
     * }, [stytchClient]);
     * ```
     *
     * @param options - {@link WebAuthnAuthenticateStartOptions}
     *
     * @returns A {@link WebAuthnAuthenticateResponse} indicating the WebAuthn registration has been authenticated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(options: WebAuthnAuthenticateStartOptions): Promise<WebAuthnAuthenticateResponse | null>;
    update(options: WebAuthnUpdateOptions): Promise<WebAuthnUpdateResponse>;
    browserSupportsAutofill(): Promise<boolean>;
}
type PasswordCreateOptions = SessionDurationOptions & {
    /**
     * The email of the new user.
     */
    email: string;
    /**
     * The password for the new user.
     */
    password: string;
};
type PasswordCreateResponse = AuthenticateResponse & {
    /**
     * Globally unique UUID that identifies a specific email address in the Stytch API.
     * The `email_id` is used when you need to operate on a specific user's email address,
     * e.g. to delete the email address from the Stytch user.
     */
    email_id: string;
};
type PasswordAuthenticateOptions = SessionDurationOptions & {
    /**
     * The email of the user.
     */
    email: string;
    /**
     * The password for the user.
     */
    password: string;
};
type PasswordAuthenticateResponse = AuthenticateResponse;
type PasswordResetByEmailStartOptions = {
    /**
     * The email of the user that requested the password reset.
     */
    email: string;
    /**
     * The url that the user clicks from the password reset email to skip resetting their password and directly login.
     * This should be a url that your app receives, parses, and subsequently sends an API request to the magic link authenticate endpoint to complete the login process without reseting their password.
     * If this value is not passed, the login redirect URL that you set in your Dashboard is used.
     * If you have not set a default login redirect URL, an error is returned.
     */
    login_redirect_url?: string;
    /**
     * Set the expiration for the login email magic link, in minutes.
     * By default, it expires in 1 hour.
     * The minimum expiration is 5 minutes and the maximum is 10080 minutes (7 days).
     */
    login_expiration_minutes?: number;
    /**
     * The url that the user clicks from the password reset email to finish the reset password flow.
     * This should be a url that your app receives and parses before showing your app's reset password page.
     * After the user submits a new password to your app, it should send an API request to complete the password reset process.
     * If this value is not passed, the default reset password redirect URL that you set in your Dashboard is used.
     * If you have not set a default reset password redirect URL, an error is returned.
     */
    reset_password_redirect_url?: string;
    /**
     * Set the expiration for the password reset, in minutes.
     * By default, it expires in 30 minutes.
     * The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     */
    reset_password_expiration_minutes?: number;
    /**
     * The email template ID to use for password reset.
     * If not provided, your default email template will be sent. If providing a template ID, it must be either a template using Stytch's customizations,
     * or a Passwords reset custom HTML template.
     */
    reset_password_template_id?: string;
};
type PasswordResetByEmailStartResponse = ResponseCommon;
type PasswordResetByEmailOptions = SessionDurationOptions & {
    /**
     * The token to authenticate.
     */
    token: string;
    /**
     * The new password for the user.
     */
    password: string;
};
type PasswordResetByEmailResponse = AuthenticateResponse;
type PasswordResetByExistingPasswordOptions = SessionDurationOptions & {
    /**
     * The user's email.
     */
    email: string;
    /**
     * The user's existing password.
     */
    existing_password: string;
    /**
     * The new password for the user.
     */
    new_password: string;
};
type PasswordResetByExistingPasswordResponse = AuthenticateResponse;
type PasswordResetBySessionOptions = SessionDurationOptions & {
    /**
     * The new password for the user.
     */
    password: string;
};
type PasswordResetBySessionResponse = AuthenticateResponse;
type PasswordStrengthCheckOptions = {
    /**
     * The email associated with the password. Provide this for a more accurate strength check.
     */
    email?: string;
    /**
     * The password to strength check.
     */
    password: string;
};
type PasswordStrengthCheckResponse = ResponseCommon & {
    /**
     * Whether or not the password is considered valid and secure.
     * Read more about password validity {@link https://stytch.com/docs/api/password-strength-check in our docs}.
     */
    valid_password: boolean;
    /**
     * The score of the password as determined by {@link https://github.com/dropbox/zxcvbn zxcvbn}.
     */
    score: number;
    /**
     * Determines if the password has been breached using {@link https://haveibeenpwned.com/ HaveIBeenPwned}.
     */
    breached_password: boolean;
    /**
     * Will return true if breach detection will be evaluated. By default this option is enabled.
     * This option can be disabled by contacting support@stytch.com. If this value is false then
     * breached_password will always be false as well.
     */
    breach_detection_on_create: boolean;
    /**
     * The strength policy type enforced, either `zxcvbn` or `luds`.
     */
    strength_policy: "luds" | "zxcvbn";
    /**
     * Feedback for how to improve the password's strength using {@link https://github.com/dropbox/zxcvbn zxcvbn}.
     */
    feedback: {
        suggestions: string[];
        warning: string;
        /**
         * Contains which LUDS properties are fulfilled by the password and which are missing to convert
         * an invalid password into a valid one. You'll use these fields to provide feedback to the user
         * on how to improve the password.
         */
        luds_requirements: {
            has_digit: boolean;
            has_lower_case: boolean;
            has_symbol: boolean;
            has_upper_case: boolean;
            missing_characters: number;
            missing_complexity: number;
        };
    };
};
interface IHeadlessPasswordClient {
    /**
     * The Create method wraps the {@link https://stytch.com/docs/api/password-create Create} Password API endpoint.
     * If a user with this email already exists in the project, this API will return an error.
     * Existing passwordless users who wish to create a password need to go through the reset password flow.
     *
     * This endpoint will return an error if the password provided does not meet our strength requirements,
     * which you can check beforehand with the {@link IHeadlessPasswordClient#strengthCheck password strength} endpoint.
     *
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * const {valid_password} = await stytch.passwords.strengthCheck({ email, password });
     * if (valid_password) {
     *   stytch.passwords.create({ email, password, session_duration_minutes: 60 });
     * }
     *
     * @param options - {@link PasswordCreateOptions}
     *
     * @returns A {@link PasswordCreateResponse} indicating the user has been created and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    create(options: PasswordCreateOptions): Promise<PasswordCreateResponse>;
    /**
     * The Authenticate method wraps the {@link https://stytch.com/docs/api/password-authenticate Authenticate} Password API endpoint.
     * This endpoint verifies that the user has a password currently set, and that the entered password is correct.
     *
     * There are cases where this endpoint will return a `reset_password` error even if the password entered is correct.
     * View our {@link https://stytch.com/docs/api/password-authenticate API Docs} for complete details.
     *
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * stytch.passwords.authenticate({
     *   email: 'sandbox@stytch.com',
     *   password: 'aVerySecurePassword',
     *   session_duration_minutes: 60
     * });
     *
     * @param options - {@link PasswordAuthenticateOptions}
     *
     * @returns A {@link PasswordAuthenticateResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    authenticate(options: PasswordAuthenticateOptions): Promise<PasswordAuthenticateResponse>;
    /**
     * The resetByEmailStart method wraps the {@link https://stytch.com/docs/api/password-email-reset-start Reset By Email Start} Password API endpoint.
     * This endpoint initiates a password reset for the email address provided.
     * This will trigger an email to be sent to the address, containing a magic link that will allow them to set a new password and authenticate.
     *
     * @example
     * stytch.passwords.resetByEmailStart({
     *   email: 'sandbox@stytch.com',
     *   reset_password_redirect_url: 'https://example.com/login/reset',
     *   reset_password_expiration_minutes: 10,
     *   login_redirect_url: 'https://example.com/login/authenticate',
     * });
     *
     * @param options - {@link PasswordResetByEmailStartOptions}
     *
     * @returns A {@link PasswordResetByEmailStartResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByEmailStart(options: PasswordResetByEmailStartOptions): Promise<PasswordResetByEmailStartResponse>;
    /**
     * The resetByEmail method wraps the {@link https://stytch.com/docs/api/password-email-reset Reset By Email} Password API endpoint.
     * This endpoint the users password and authenticate them.
     * This endpoint checks that the magic link token is valid, hasn't expired, or already been used.
     * The provided password needs to meet our password strength requirements, which can be checked in advance with the {@link IHeadlessPasswordClient#strengthCheck password strength} endpoint.
     *
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * const currentLocation = new URL(window.location.href);
     * const token = currentLocation.searchParams.get('token');
     * stytch.passwords.resetByEmail({
     *   token,
     *   email: 'sandbox@stytch.com',
     *   password: 'aVerySecurePassword',
     *   session_duration_minutes: 60
     * });
     *
     * @param options - {@link PasswordResetByEmailOptions}
     *
     * @returns A {@link PasswordResetByEmailResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByEmail(options: PasswordResetByEmailOptions): Promise<PasswordResetByEmailResponse>;
    /**
     * The strengthCheck method wraps the {@link https://stytch.com/docs/api/password-strength-check Strength Check} Password API endpoint.
     * This endpoint allows you to check whether or not the users provided password is valid,
     * and to provide feedback to the user on how to increase the strength of their password.
     *
     * @example
     * const {valid_password, feedback} = await stytch.passwords.strengthCheck({ email, password });
     * if (!valid_password) {
     *   throw new Error('Password is not strong enough: ' + feedback.warning);
     * }
     *
     * @param options - {@link PasswordStrengthCheckOptions}
     *
     * @returns A {@link PasswordStrengthCheckResponse} containing password strength feedback.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    strengthCheck(options: PasswordStrengthCheckOptions): Promise<PasswordStrengthCheckResponse>;
    /**
     * The resetByExistingPassword method wraps the {@link https://stytch.com/docs/api/password-existing-password-reset Reset By Existing Password} API endpoint.
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * stytch.passwords.resetByExistingPassword({
     *   email: 'sandbox@stytch.com',
     *   existing_password: 'aVerySecurePassword',
     *   new_password: 'aVerySecureNewPassword'
     * });
     *
     * @param options - {@link PasswordResetByExistingPasswordOptions}
     *
     * @returns A {@link PasswordResetByExistingPasswordResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByExistingPassword(options: PasswordResetByExistingPasswordOptions): Promise<PasswordResetByExistingPasswordResponse>;
    /**
     * The resetBySession method wraps the {@link https://stytch.com/docs/api/password-session-reset Reset By Session} API endpoint.
     * If this method succeeds, the user will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * stytch.passwords.resetBySession({
     *   password: 'aVerySecurePassword'
     * });
     *
     * @param options - {@link PasswordResetBySessionOptions}
     *
     * @returns A {@link PasswordResetBySessionResponse} indicating the password is valid and that the user is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetBySession(options: PasswordResetBySessionOptions): Promise<PasswordResetBySessionResponse>;
}
// Authentication Factors
interface B2BEmailFactor {
    delivery_method: "email";
    type: string;
    last_authenticated_at: string;
    email_factor: {
        email_id: string;
        email_address: string;
    };
    sequence_order: "PRIMARY";
}
interface B2BPhoneNumberFactor {
    delivery_method: "sms" | "whatsapp";
    type: string;
    last_authenticated_at: string;
    phone_number_factor: {
        phone_id: string;
        phone_number: string;
    };
    sequence_order: "SECONDARY";
}
interface B2BGoogleOAuthFactor {
    delivery_method: "oauth_google";
    type: string;
    last_authenticated_at: string;
    google_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
    sequence_order: "PRIMARY";
}
interface B2BMicrosoftOAuthFactor {
    delivery_method: "oauth_microsoft";
    type: string;
    last_authenticated_at: string;
    microsoft_oauth_factor: {
        id: string;
        email_id: string;
        provider_subject: string;
    };
    sequence_order: "PRIMARY";
}
type B2BAuthenticationFactor = B2BEmailFactor | B2BPhoneNumberFactor | B2BGoogleOAuthFactor | B2BMicrosoftOAuthFactor;
type MemberResponseCommon = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific member in the Stytch API.
     * The member_id critical to perform operations on a member in our API
     * so be sure to preserve this value.
     */
    member_id: string;
    /**
     * The Member object.
     * See {@link Member} for details.
     */
    member: Member;
    /**
     * The Organization object.
     * See {@link Organization} for details.
     */
    organization: Organization;
};
interface MemberSession {
    /**
     * Globally unique UUID that identifies a specific member session in the Stytch API.
     */
    member_session_id: string;
    /**
     * Globally unique UUID that identifies a specific member in the Stytch API.
     * The member_id critical to perform operations on a member in our API
     * so be sure to preserve this value.
     */
    member_id: string;
    /**
     * Globally unique UUID that identifies an organization in the Stytch API.
     */
    organization_id: string;
    /**
     * The timestamp of the session's creation.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    started_at: string;
    /**
     * The timestamp of the last time the session was accessed.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    last_accessed_at: string;
    /**
     * The timestamp of the session's expiration.
     * Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    expires_at: string;
    /**
     * All the authentication factors that have been associated with the current member session.
     */
    authentication_factors: B2BAuthenticationFactor[];
    /**
     * A map of the custom claims associated with the session.
     * Custom claims can only be set from the server, they cannot be set using the clientside SDKs.
     * After claims have been added to a session, call {@link IHeadlessB2BSessionClient#authenticate stytch.sessions.authenticate} to refresh the session state clientside.
     * See our {@link https://stytch.com/docs/sessions#using-sessions_custom-claims guide} for more information.
     * If no claims are set, this field will be null.
     */
    custom_claims?: Record<string, unknown>;
    /**
     * A list of the roles associated with the session.
     * Members may inherit certain roles depending on the factors in their session.
     * For example, some roles may only be active if the member logged in from a specific SAML IDP.
     */
    roles: string[];
}
interface SSORegistration {
    connection_id: string;
    external_id: string;
    registration_id: string;
    sso_attributes: Record<string, unknown>;
}
type RoleSource = {
    type: "direct_assignment";
    details: Record<string, never>;
} | {
    type: "email_assignment";
    details: {
        email_domain: string;
    };
} | {
    type: "sso_connection";
    details: {
        connection_id: string;
    };
} | {
    type: "sso_connection_group";
    details: {
        connection_id: string;
        group: string;
    };
};
interface Member {
    /**
     * Globally unique UUID that identifies an organization in the Stytch API.
     */
    organization_id: string;
    /**
     * Globally unique UUID that identifies a specific member in the Stytch API.
     * The member_id critical to perform operations on a member in our API
     * so be sure to preserve this value.
     */
    member_id: string;
    /**
     * The email address of the member.
     */
    email_address: string;
    /**
     * Whether the member's email address is verified.
     */
    email_address_verified: boolean;
    /**
     * The `status` value denotes whether or not a user has successfully logged in at least once with any available login method.
     */
    status: string;
    /**
     * The name of the member
     */
    name: string;
    /**
     * A JSON object containing application-specific metadata.
     * This field can only be updated by a direct API integration.
     * Use it to store fields that a member should not be allowed to edit without backend validation - such as `role` or `subscription_status`.
     * See our {@link https://stytch.com/docs/api/metadata metadata reference} for complete details.
     */
    trusted_metadata: Record<string, unknown>;
    /**
     * A JSON object containing application-specific metadata.
     * Use it to store fields that a member can be allowed to edit directly without backend validation - such as `display_theme` or `preferred_locale`.
     * See our {@link https://stytch.com/docs/api/metadata metadata reference} for complete details.
     */
    untrusted_metadata: Record<string, unknown>;
    sso_registrations: SSORegistration[];
    /**
     * Identifies the Member as a break glass user - someone who has permissions to authenticate into an Organization by bypassing the Organization's settings.
     * A break glass account is typically used for emergency purposes to gain access outside of normal authentication procedures.
     */
    is_breakglass: boolean;
    /**
     * Returned if the member has a registered password
     */
    member_password_id: string;
    /**
     * If true, the member must complete a secondary authentication flow, such as SMS OTP, along with their
     * primary authentication factor in order to log in and attain a member session.
     */
    mfa_enrolled: boolean;
    /**
     * Returned if the member has a phone number.
     */
    mfa_phone_number: string;
    /**
     * Whether the member's phone number is verified.
     */
    mfa_phone_number_verified: boolean;
    /**
     * A list of the member's roles and their sources
     */
    roles: {
        role_id: string;
        sources: RoleSource[];
    }[];
}
type B2BAuthenticateResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific member in the Stytch API.
     * The member_id critical to perform operations on a member in our API
     * so be sure to preserve this value.
     */
    member_id: string;
    /**
     * An opaque session token.
     * Session tokens need to be authenticated via the {@link https://stytch.com/docs/b2b/api/authenticate-session SessionsAuthenticate}
     * endpoint before a member takes any action that requires authentication
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_tokens our documentation} for more information.
     */
    session_token: string;
    /**
     * A JSON Web Token that contains standard claims about the user as well as information about the Stytch session
     * Session JWTs can be authenticated locally without an API call.
     * A session JWT is signed by project-specific keys stored by Stytch.
     * See {@link https://stytch.com/docs/sessions#session-tokens-vs-JWTs_jwts our documentation} for more information.
     */
    session_jwt: string;
    /**
     * The Member Session object.
     * See {@link MemberSession} for details.
     */
    member_session: MemberSession;
    /**
     * The Member object.
     * See {@link Member} for details.
     */
    member: Member;
    /**
     * The Organization object.
     * See {@link Organization} for details.
     */
    organization: Organization;
};
type B2BAuthenticateResponseWithMFA = B2BAuthenticateResponse & {
    /**
     * The Member Session object.
     * See {@link MemberSession} for details.
     */
    member_session: MemberSession | null;
    /**
     * Returns true if the member is fully authenticated, in which case a member session is returned.
     * Returns false if the member still needs to complete a secondary authentication requirement,
     * in which case an intermediate_session_token is returned.
     */
    member_authenticated: boolean;
    /**
     * If the intermediate_session_token is present, the member needs to complete MFA.
     * The intermediate_session_token can be passed into a secondary authentication endpoint, such as OTP authenticate,
     * in order to receive a member session. The intermediate_session_token can also be used with discovery endpoints
     * to join a different organization or create a new organization.
     */
    intermediate_session_token: string;
    /**
     * Contains information about the member's options for completing MFA, if applicable.
     */
    mfa_required: MfaRequired | null;
};
interface Organization {
    /**
     * Globally unique UUID that identifies an organization in the Stytch API.
     */
    organization_id: string;
    /**
     * The name of the organization.
     */
    organization_name: string;
    /**
     * The slug of the organization.
     */
    organization_slug: string;
    /**
     * A URL of the organization's logo.
     */
    organization_logo_url: string;
    /**
     * A JSON object containing application-specific metadata.
     * This field can only be updated by a direct API integration.
     */
    trusted_metadata: Record<string, unknown>;
    /**
     * The default connection used for SSO when there are multiple active connections.
     */
    sso_default_connection_id: string | null;
    /**
     * The authentication setting that controls the JIT provisioning of Members when authenticating via SSO.
     * The accepted values are:
     *   ALL_ALLOWED  new Members will be automatically provisioned upon successful authentication via any of the Organization's sso_active_connections.
     *   RESTRICTED  only new Members with SSO logins that comply with sso_jit_provisioning_allowed_connections can be provisioned upon authentication.
     *   NOT_ALLOWED  disable JIT provisioning via SSO.
     */
    sso_jit_provisioning: "ALL_ALLOWED" | "RESTRICTED" | "NOT_ALLOWED";
    /**
     * An array of connection_ids that reference SAML Connection objects.
     * Only these connections will be allowed to JIT provision Members via SSO when sso_jit_provisioning is set to RESTRICTED.
     */
    sso_jit_provisioning_allowed_connections: string[];
    /**
     * An array of active SSO Connection references.
     */
    sso_active_connections: {
        connection_id: string;
        display_name: string;
    }[];
    /**
     * An array of email domains that allow invites or JIT provisioning for new Members.
     * This list is enforced when either email_invites or email_jit_provisioning is set to RESTRICTED.
     * Common domains such as gmail.com are not allowed.
     */
    email_allowed_domains: string[];
    /**
     * The authentication setting that controls how a new Member can be provisioned by authenticating via Email Magic Link.
     * The accepted values are:
     *   RESTRICTED  only new Members with verified emails that comply with email_allowed_domains can be provisioned upon authentication via Email Magic Link.
     *   NOT_ALLOWED  disable JIT provisioning via Email Magic Link.
     */
    email_jit_provisioning: "RESTRICTED" | "NOT_ALLOWED";
    /**
     * The authentication setting that controls how a new Member can be invited to an organization by email.
     * The accepted values are:
     *   ALL_ALLOWED  any new Member can be invited to join via email.
     *   RESTRICTED  only new Members with verified emails that comply with email_allowed_domains can be invited via email.
     *   NOT_ALLOWED  disable email invites.
     */
    email_invites: "ALL_ALLOWED" | "RESTRICTED" | "NOT_ALLOWED";
    /**
     * The setting that controls which authentication methods can be used by Members of an Organization.
     * The accepted values are:
     *   ALL_ALLOWED  the default setting which allows all authentication methods to be used.
     *   RESTRICTED  only methods that comply with allowed_auth_methods can be used for authentication. This setting does not apply to Members with is_breakglass set to true.
     */
    auth_methods: "ALL_ALLOWED" | "RESTRICTED";
    /**
     * An array of allowed authentication methods.
     * This list is enforced when auth_methods is set to RESTRICTED.
     * The list's accepted values are: sso, magic_link, password, google_oauth, and microsoft_oauth.
     */
    allowed_auth_methods: string[];
    /**
     * The setting that controls the MFA policy for all Members in the Organization. The accepted values are:
     *   REQUIRED_FOR_ALL  All Members within the Organization will be required to complete MFA every time they wish to log in.
     *   OPTIONAL  The default value. The Organization does not require MFA by default for all Members. Members will be required to complete MFA only if their mfa_enrolled status is set to true
     */
    mfa_policy: "OPTIONAL" | "REQUIRED_FOR_ALL";
    /**
     * An array of implicit role assignments granted to members in this organization whose emails match the domain.
     */
    rbac_email_implicit_role_assignments?: {
        role_id: string;
        domain: string;
    }[];
}
type B2BState = {
    member?: Member;
    session?: MemberSession;
};
interface DiscoveredOrganization {
    organization: Organization;
    membership: {
        type: "eligible_to_join_by_email_domain";
        details: {
            domain: string;
        };
        member: null;
    } | {
        type: "active_member" | "pending_member" | "invited_member";
        details: null;
        member: Member;
    };
    member_authenticated: boolean;
    primary_required: {
        allowed_auth_methods: string[];
    } | null;
    mfa_required: MfaRequired | null;
}
interface MfaRequired {
    member_options: MemberOptions;
    /**
     * Equal to 'sms_otp' if an OTP code was sent to the member's phone number.
     */
    secondary_auth_initiated: "sms_otp" | null;
}
interface MemberOptions {
    mfa_phone_number: string;
}
interface X509Certificate {
    certificate_id: string;
    certificate: string;
    issuer: string;
    created_at: string;
    expires_at: string;
}
interface SAMLConnection {
    /**
     * Globally unique UUID that identifies a specific Organization.
     */
    organization_id: string;
    /**
     * Globally unique UUID that identifies a specific SAML Connection.
     */
    connection_id: string;
    /**
     * The status of the connection.
     * The possible values are `pending` or `active`.
     * See the {@link https://stytch.com/docs/b2b/api/update-saml-connection Update SAML Connection} endpoint for more details.
     */
    status: string;
    /**
     * An object that represents the attributes used to identify a Member.
     * This object will map the IdP-defined User attributes to Stytch-specific values.
     * Required attributes: `email` and one of `full_name` or `first_name` and `last_name`.
     */
    attribute_mapping: Record<string, string>;
    /**
     * A globally unique name for the IdP. This will be provided by the IdP.
     */
    idp_entity_id: string;
    /**
     * A human-readable display name for the connection.
     */
    display_name: string;
    /**
     * The URL for which assertions for login requests will be sent. This will be provided by the IdP.
     */
    idp_sso_url: string;
    /**
     * The URL of the Assertion Consumer Service.
     * This value will be passed to the IdP to redirect the Member back to Stytch after a sign-in attempt.
     * Read our {@link https://stytch.com/docs/b2b/api/saml-overview SAML Overview} for more info.
     */
    acs_url: string;
    /**
     * The URL of the Audience Restriction.
     * This value will indicate that Stytch is the intended audience of an assertion.
     * Read our {@link https://stytch.com/docs/b2b/api/saml-overview SAML Overview} for more info.
     */
    audience_uri: string;
    /**
     * A list of X.509 certificates Stytch will use to sign its assertion requests. Certificates should be uploaded to the IdP.
     */
    signing_certificates: X509Certificate[];
    /**
     * A list of X.509 certificates Stytch will use to validate an assertion callback. Certificates should be populated from the IdP.
     */
    verification_certificates: X509Certificate[];
    /**
     * An array of implicit role assignments granted to members in this organization who log in with this SAML connection.
     * See our {@link https://stytch.com/docs/b2b/guides/rbac/role-assignment RBAC guide} for more information about
     * role assignment.
     */
    saml_connection_implicit_role_assignments: {
        role_id: string;
    }[];
    /**
     * An array of implicit role assignments granted to members in this organization who log in with this SAML connection
     * and belong to the specified group.
     * See our {@link https://stytch.com/docs/b2b/guides/rbac/role-assignment RBAC guide} for more information about
     * role assignment.
     */
    saml_group_implicit_role_assignments: {
        role_id: string;
        group: string;
    }[];
}
interface OIDCConnection {
    /**
     * Globally unique UUID that identifies a specific Organization.
     */
    organization_id: string;
    /**
     * Globally unique UUID that identifies a specific OIDC Connection.
     */
    connection_id: string;
    /**
     * The status of the connection.
     * The possible values are `pending` or `active`.
     * See the {@link https://stytch.com/docs/b2b/api/update-oidc-connection Update OIDC Connection} endpoint for more details.
     */
    status: string;
    /**
     * A human-readable display name for the connection.
     */
    display_name: string;
    /**
     * The callback URL for this OIDC connection. This value will be passed to the IdP to redirect the Member back to Stytch after a sign-in attempt.
     */
    redirect_url: string;
    /**
     * A case-sensitive `https://` URL that uniquely identifies the IdP. This will be provided by the IdP.
     */
    issuer: string;
    /**
     * The OAuth2.0 client ID used to authenticate login attempts. This will be provided by the IdP.
     */
    client_id: string;
    /**
     * The secret belonging to the OAuth2.0 client used to authenticate login attempts. This will be provided by the IdP.
     */
    client_secret: string;
    /**
     * The location of the URL that starts an OAuth login at the IdP. This will be provided by the IdP.
     */
    authorization_url: string;
    /**
     * The location of the URL that issues OAuth2.0 access tokens and OIDC ID tokens. This will be provided by the IdP.
     */
    token_url: string;
    /**
     * The location of the IDP's UserInfo Endpoint. This will be provided by the IdP.
     */
    userinfo_url: string;
    /**
     * The location of the IdP's JSON Web Key Set, used to verify credentials issued by the IdP. This will be provided by the IdP.
     */
    jwks_url: string;
}
type B2BSessionAuthenticateResponse = B2BAuthenticateResponse;
type B2BSessionRevokeOptions = {
    /**
     * When true, clear the user and session object in the local storage, even in the event of a network failure revoking the session.
     * When false, the user and session object will not be cleared in the event that the SDK cannot contact the Stytch servers.
     * The user and session object will always be cleared when the session revoke call succeeds.
     * Defaults to false
     */
    forceClear?: boolean;
};
type B2BSessionOnChangeCallback = (session: MemberSession | null) => void;
type B2BSessionExchangeOptions = SessionDurationOptions & {
    /**
     * The ID of the organization that the new session should belong to.
     */
    organization_id: string;
    /**
     * The locale will be used if an OTP code is sent to the member's phone number as part of a
     * secondary authentication requirement.
     */
    locale?: locale;
};
type B2BSessionExchangeResponse = B2BAuthenticateResponseWithMFA;
interface IHeadlessB2BSessionClient {
    /**
     * If logged in, `getSync` returns the in-memory member session object. Otherwise, it returns `null`.
     *
     * @example
     * const memberSession = stytch.session.getSync();
     * @returns The user's active {@link MemberSession} object or `null`
     */
    getSync(): MemberSession | null;
    /**
     * If logged in, `getTokens` returns the session tokens currently issued to the client.
     * Stytch issues two types of tokens - opaque bearer tokens and JWTs.
     * See Stytch's {@link https://stytch.com/docs/sessions#using-sessions session management guide} for an explanation of the difference between the two.
     * On each request authenticate the user's session on the backend using one of Stytch's client libraries.
     *
     * @example
     * const {session_jwt} = stytch.session.getTokens();
     * fetch('https://api.example.com, {
     *   headers: new Headers({
     *    'Authorization': 'Bearer ' + session_jwt,
     *    credentials: 'include',
     *   }),
     * })
     *
     */
    getTokens(): SessionTokens | null;
    /**
     * Use `onChange` to register a listener for session change events.
     * If using `@stytch/react` or `@stytch/nextjs` - you may prefer the `useStytchMemberSession` hook.
     * @example
     * stytch.session.onChange((memberSession) => {
     *   if(!memberSession) {
     *     // The member has been logged out!
     *     window.location.href = 'https://example.com/login'
     *   }
     * })
     * @param callback - {@link B2BSessionOnChangeCallback}
     */
    onChange(callback: B2BSessionOnChangeCallback): UnsubscribeFunction;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/b2b/api/authenticate-session authenticate } Session endpoint and validates that the session issued to the user is still valid.
     * You can call this method to programmatically extend the lifetime of the user's existing session
     * If you're trying to determine if the user is logged in, call {@link IHeadlessB2BSessionClient.getSync} instead.
     * @example
     * stytch.session.authenticate({
     *   // Extend the session for another 60 minutes
     *   session_duration_minutes: 60
     * })
     * @param options - {@link SessionAuthenticateOptions}
     * @returns A {@link B2BSessionAuthenticateResponse} object
     */
    authenticate(options?: SessionAuthenticateOptions): Promise<B2BSessionAuthenticateResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/b2b/api/revoke-session revoke} Session endpoint and revokes the user's current session.
     * This method should be used to log out a user. While calling this method, we clear the user and session objects from local storage
     * unless the SDK cannot contact the Stytch servers. This behavior can be overriden by using the optional param object.
     *
     * @param options - {@link B2BSessionRevokeOptions}
     *
     * @example
     * stytch.sessions.revoke()
     *   .then(() => window.location.href = 'https://example.com/login');
     * @returns A {@link SessionRevokeResponse}
     */
    revoke(options?: B2BSessionRevokeOptions): Promise<SessionRevokeResponse>;
    /**
     * Wraps Stytch's {@link https://stytch.com/docs/b2b/api/exchange-session Exchange Session} endpoint.
     * @example
     * stytch.sessions.exchange({
     *   organization_id: 'organization-123',
     *   session_duration_minutes: 60
     * })
     * @param options - {@link B2BSessionExchangeOptions}
     * @returns A {@link B2BSessionExchangeResponse}
     */
    exchange(data: B2BSessionExchangeOptions): Promise<B2BSessionExchangeResponse>;
}
type B2BDiscoveryOrganizationsResponse = ResponseCommon & {
    /**
     * The email corresponding to the intermediate_session_token, session_token, or session_jwt that was passed in
     */
    email_address: string;
    discovered_organizations: DiscoveredOrganization[];
    /**
     * The organization_id that the intermediate_session_token is associated with, if any. This field will be null
     * if a session_token or session_jwt is passed in.
     */
    organization_id_hint: string | null;
};
type B2BDiscoveryOrganizationsCreateOptions = SessionDurationOptions & {
    /**
     * The name of the new Organization. If the name is not specified, a name will be created based on the email
     * that was used in the discovery flow.
     */
    organization_name?: string;
    /**
     * The unique URL slug of the new Organization. If the slug is not specified, a slug will be created based on the
     * email that was used in the discovery flow.
     */
    organization_slug?: string;
    /**
     * The image URL of the new Organization.
     */
    organization_logo_url?: string;
    /**
     * The authentication setting that controls the JIT provisioning of Members to the new Organization
     * when authenticating via SSO. The accepted values are: ALL_ALLOWED, RESTRICTED, and NOT_ALLOWED.
     */
    sso_jit_provisioning?: string;
    /**
     * An array of email domains that allow invites or JIT provisioning for new Members to the new Organization.
     * This list is enforced when email_invites, email_jit_provisioning, or sso_jit_provisioning are set to RESTRICTED.
     */
    email_allowed_domains?: string[];
    /**
     * The authentication setting that controls how a new Member can be provisioned to the new Organization by
     * authenticating via Email Magic Link. The accepted values are RESTRICTED and NOT_ALLOWED.
     */
    email_jit_provisioning?: string;
    /**
     * The authentication setting that controls how a new Member can be invited to the new Organization via
     * Email Magic Link. The accepted values are: ALL_ALLOWED, RESTRICTED, and NOT_ALLOWED.
     */
    email_invites?: string;
    /**
     * Determines whether authenticating to the Organization should be restricted to specific authentication methods.
     * The accepted values are: ALL_ALLOWED, RESTRICTED, and NOT_ALLOWED.
     */
    auth_methods?: string;
    /**
     * An array of authentication methods that Members are allowed to use to authenticate to the Organization.
     * This list is enforced when auth_methods is set to RESTRICTED.
     * The accepted values are 'sso', 'magiclink', 'password', 'google_oauth', and 'microsoft_oauth'.
     */
    allowed_auth_methods?: string[];
    /**
     * The MFA policy of the organization. If 'REQUIRED_FOR_ALL', all members (including the new one that will be created
     * through this endpoint) will be required to complete MFA when logging in to the organization. If 'OPTIONAL',
     * members will only be required to complete MFA if their mfa_enrolled field is set to true.
     * The accepted values are 'REQUIRED_FOR_ALL' and 'OPTIONAL'.
     */
    mfa_policy?: string;
};
type B2BDiscoveryOrganizationsCreateResponse = B2BAuthenticateResponseWithMFA;
type B2BDiscoveryIntermediateSessionsExchangeOptions = SessionDurationOptions & {
    /**
     * The id of the Organization that the new Member is joining.
     */
    organization_id: string;
    /**
     * The locale will be used if an OTP code is sent to the member's phone number as part of a
     * secondary authentication requirement.
     */
    locale?: locale;
};
type B2BDiscoveryIntermediateSessionsExchangeResponse = B2BAuthenticateResponseWithMFA;
interface IHeadlessB2BDiscoveryClient {
    organizations: {
        /**
         * The organizations method wraps the {@link https://stytch.com/docs/b2b/api/list-discovered-organizations list Organizations} API endpoint.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/discovery#list-discovered-organizations Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.discovery.organizations.list({
         *   intermediate_session_token: 'token',
         * });
         *
         * @param data - {@link B2BDiscoveryOrganizationsOptions}
         * This endpoint requires only one of intermediate_session_token, session_token, or session_jwt to be passed in.
         * It will return an error if multiple are present.
         *
         * @returns A {@link B2BDiscoveryOrganizationsResponse} containing the email address associated with the session
         * factor passed in, and a list of discovered organizations associated with the email.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        list(): Promise<B2BDiscoveryOrganizationsResponse>;
        /**
         * The create method wraps the {@link https://stytch.com/docs/b2b/api/create-organization-via-discovery discovery organizations create} API endpoint.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/discovery#create-organization-via-discovery Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.discovery.organizations.create({
         *   intermediate_session_token: 'token',
         *   organization_name: 'my-great-organization',
         *   organization_slug: 'my-great-organization',
         *   sso_jit_provisioning: 'ALL_ALLOWED',
         * });
         *
         * @param data - {@link B2BDiscoveryOrganizationsCreateOptions}
         *
         * @returns A {@link B2BDiscoveryOrganizationsCreateResponse} indicating that the intermediate session token
         * has been authenticated, a new Organization has been created, and the Member has been created and is logged in
         * to the new Organization
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        create(data: B2BDiscoveryOrganizationsCreateOptions): Promise<B2BDiscoveryOrganizationsCreateResponse>;
    };
    intermediateSessions: {
        /**
         * The intermediate sessions exchange method wraps the {@link https://stytch.com/docs/b2b/api/exchange-intermediate-session intermediate sessions exchange} API endpoint.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/discovery#exchange-intermediate-session Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.discovery.intermediateSessions.exchange({
         *   intermediate_session_token: 'token',
         *   organization_id: 'organization-test-123',
         * });
         *
         * @param data - {@link B2BDiscoveryIntermediateSessionsExchangeOptions}
         *
         * @returns A {@link B2BDiscoveryIntermediateSessionsExchangeResponse} indicating that the intermediate session token
         * has been authenticated and the member is now logged in.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        exchange(data: B2BDiscoveryIntermediateSessionsExchangeOptions): Promise<B2BDiscoveryIntermediateSessionsExchangeResponse>;
    };
}
type B2BDiscoveryAuthenticateResponse = ResponseCommon & {
    /**
     * The intermediate session token. This token does not belong to a specific instance of a member,
     * but may be exchanged for a member session or used to create a new organization.
     */
    intermediate_session_token: string;
    /**
     * The email of the end user who is logging in
     */
    email_address: string;
    discovered_organizations: DiscoveredOrganization[];
};
type B2BMagicLinksInviteOptions = {
    /**
     * The email of the member logging in or signing up
     */
    email_address: string;
    /**
     * The URL that the Member clicks from the invite Email Magic Link.
     * This URL should be an endpoint in the backend server that verifies the request by querying
     * Stytch's authenticate endpoint and finishes the invite flow.
     * If this value is not passed, the default `invite_redirect_url` that you set in your Dashboard is used.
     * If you have not set a default `invite_redirect_url`, an error is returned.
     */
    invite_redirect_url?: string;
    /**
     * Use a custom template for invite emails.
     * By default, it will use your default email template.
     * The template must be a template using our built-in customizations or a custom HTML email for Magic Links - Invite.
     */
    invite_template_id?: string;
    /**
     * The name of the Member.
     */
    name?: string;
    /**
     * A JSON object containing application-specific metadata.
     * Use it to store fields that a member can be allowed to edit directly without backend validation - such as `display_theme` or `preferred_locale`.
     * See our {@link https://stytch.com/docs/api/metadata metadata reference} for complete details.
     */
    untrusted_metadata?: Record<string, unknown>;
    /**
     * The locale is used to determine which language to use in the email. Parameter is a {@link https://www.w3.org/International/articles/language-tags/ IETF BCP 47 language tag}, e.g. "en".
     * Currently supported languages are English ("en"), Spanish ("es"), and Brazilian Portuguese ("pt-br"); if no value is provided, the copy defaults to English.
     */
    locale?: locale;
    /**
     * Roles to explicitly assign to this Member.
     * See our {@link https://stytch.com/docs/b2b/guides/rbac/role-assignment RBAC guide} for more information about
     * role assignment.
     */
    roles?: string[];
};
type B2BMagicLinksInviteResponse = MemberResponseCommon;
type B2BMagicLinkLoginOrSignupOptions = {
    /**
     * The email of the member logging in or signing up
     */
    email_address: string;
    /**
     * The id of the organization the member belongs to
     */
    organization_id: string;
    /**
     * The url the user clicks from the login email magic link.
     * This should be a url that your app receives and parses and subsequently send an API request to authenticate the magic link and log in the member.
     * If this value is not passed, the default login redirect URL that you set in your Dashboard is used.
     * If you have not set a default login redirect URL, an error is returned.
     */
    login_redirect_url?: string;
    /**
     * The url the user clicks from the sign-up email magic link.
     * This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and sign-up the user.
     * If this value is not passed, the default sign-up redirect URL that you set in your Dashboard is used.
     * If you have not set a default sign-up redirect URL, an error is returned.
     */
    signup_redirect_url?: string;
    /**
     * The email template ID to use for login emails.
     * If not provided, your default email template will be sent. If providing a template ID, it must be either a template using Stytch's customizations,
     * or a Magic link Login custom HTML template.
     */
    login_template_id?: string;
    /**
     * The email template ID to use for sign-up emails.
     * If not provided, your default email template will be sent. If providing a template ID, it must be either a template using Stytch's customizations,
     * or a Magic link Sign-up custom HTML template.
     */
    signup_template_id?: string;
    /**
     * The locale is used to determine which language to use in the email. Parameter is a {@link https://www.w3.org/International/articles/language-tags/ IETF BCP 47 language tag}, e.g. "en".
     * Currently supported languages are English ("en"), Spanish ("es"), and Brazilian Portuguese ("pt-br"); if no value is provided, the copy defaults to English.
     */
    locale?: locale;
};
type B2BMagicLinkLoginOrSignupResponse = ResponseCommon;
type B2BMagicLinksAuthenticateOptions = SessionDurationOptions & {
    /**
     *  The magic link token used to authenticate a member
     */
    magic_links_token: string;
    /**
     * The locale will be used if an OTP code is sent to the member's phone number as part of a
     * secondary authentication requirement.
     */
    locale?: locale;
};
type B2BMagicLinksAuthenticateResponse = B2BAuthenticateResponseWithMFA & {
    /**
     * The ID of the method used to send a magic link.
     */
    method_id: string;
};
type B2BMagicLinksEmailDiscoverySendOptions = {
    /**
     * The email of the member logging in
     */
    email_address: string;
    /**
     * The url the user clicks from the login email magic link.
     * This should be a url that your app receives and parses and subsequently send an API request to authenticate the magic link and log in the member.
     * If this value is not passed, the default discovery redirect URL that you set in your Dashboard is used.
     * If you have not set a default discovery redirect URL, an error is returned.
     */
    discovery_redirect_url?: string;
    /**
     * The email template ID to use for login emails.
     * If not provided, your default email template will be sent. If providing a template ID, it must be either a template using Stytch's customizations,
     * or a Magic link Login custom HTML template.
     */
    login_template_id?: string;
    /**
     * The locale is used to determine which language to use in the email. Parameter is a {@link https://www.w3.org/International/articles/language-tags/ IETF BCP 47 language tag}, e.g. "en".
     * Currently supported languages are English ("en"), Spanish ("es"), and Brazilian Portuguese ("pt-br"); if no value is provided, the copy defaults to English.
     */
    locale?: locale;
};
type B2BMagicLinksEmailDiscoverySendResponse = ResponseCommon;
type B2BMagicLinksDiscoveryAuthenticateResponse = B2BDiscoveryAuthenticateResponse;
type B2BMagicLinksDiscoveryAuthenticateOptions = {
    /**
     *  The discovery magic link token used to authenticate an end user
     */
    discovery_magic_links_token: string;
};
interface IHeadlessB2BMagicLinksClient {
    email: {
        /**
         * The invite method wraps the {@link https://stytch.com/docs/b2b/api/send-invite-email send invite} API endpoint.
         * It invites the specified email to the caller's active organization, creating a new Member if necessary.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/email-magic-links#invite Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.magicLinks.email.invite({
         *   email_address: 'sandbox@stytch.com',
         * });
         *
         * @param data - {@link B2BMagicLinksInviteOptions}
         *
         * @returns A {@link B2BMagicLinksInviteResponse} indicating that the email has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        invite(data: B2BMagicLinksInviteOptions): Promise<B2BMagicLinksInviteResponse>;
        /**
         * The loginOrSignup method wraps the {@link https://stytch.com/docs/b2b/api/send-login-signup-email login_or_signup} Email magic link API endpoint.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/email-magic-links#login-or-signup Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.magicLinks.email.loginOrCreate({
         *   email_address: 'sandbox@stytch.com',
         *   organization_id: 'organization-test-123',
         * });
         *
         * @param data - {@link B2BMagicLinkLoginOrSignupOptions}
         *
         * @returns A {@link B2BMagicLinkLoginOrSignupResponse} indicating that the email has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        loginOrSignup(data: B2BMagicLinkLoginOrSignupOptions): Promise<B2BMagicLinkLoginOrSignupResponse>;
        discovery: {
            /**
             * The send method wraps the {@link https://stytch.com/docs/b2b/api/send-discovery-email discovery} Email magic link API endpoint.
             *
             * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/email-magic-links#send-discovery-email Stytch Docs} for a complete reference.
             *
             * @example
             * stytch.magicLinks.email.discovery.send({
             *   email_address: 'sandbox@stytch.com',
             * });
             *
             * @param data - {@link B2BMagicLinksEmailDiscoverySendOptions}
             *
             * @returns A {@link B2BMagicLinksEmailDiscoverySendResponse} indicating that the email has been sent.
             *
             * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
             * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
             * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
             */
            send(data: B2BMagicLinksEmailDiscoverySendOptions): Promise<B2BMagicLinksEmailDiscoverySendResponse>;
        };
    };
    /**
     * The authenticate method wraps the {@link https://stytch.com/docs/b2b/api/authenticate-magic-link authenticate} Email magic link API endpoint.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/email-magic-links#authenticate Stytch Docs} for a complete reference.
     *
     * @example
     * stytch.magicLinks.authenticate({
     *   magic_link_token: 'token',
     *   session_duration_minutes: 60,
     * });
     *
     * @param data - {@link B2BMagicLinksAuthenticateOptions}
     *
     * @returns A {@link B2BMagicLinksAuthenticateResponse} indicating that magic link has been authenticated and the member is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    authenticate(data: B2BMagicLinksAuthenticateOptions): Promise<B2BMagicLinksAuthenticateResponse>;
    /**
     * The authenticate method wraps the {@link https://stytch.com/docs/b2b/api/authenticate-discovery-magic-link authenticate} discovery magic link API endpoint.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/email-magic-links#authenticate-discovery-magic-link Stytch Docs} for a complete reference.
     *
     * @example
     * stytch.magicLinks.discovery.authenticate({
     *   discovery_magic_link_token: 'token',
     * });
     *
     * @param data - {@link B2BMagicLinksDiscoveryAuthenticateOptions}
     *
     * @returns A {@link B2BMagicLinksDiscoveryAuthenticateResponse} indicating that the magic link has been authenticated.
     * The response will contain the intermediate_session_token, the email address that the magic link was sent to,
     * and a list of discovered organizations that are associated with the email address.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    discovery: {
        authenticate(data: B2BMagicLinksDiscoveryAuthenticateOptions): Promise<B2BMagicLinksDiscoveryAuthenticateResponse>;
    };
}
type B2BMemberOnChangeCallback = (member: Member | null) => void;
type B2BMemberUpdateOptions = {
    /**
     * The name of the Member. Replaces the existing name, if it exists.
     */
    name?: string;
    /**
     * A JSON object containing application-specific metadata.
     * Use it to store fields that a Member can be allowed to edit directly without backend validation - such as `display_theme` or `preferred_locale`.
     * See our {@link https://stytch.com/docs/api/metadata metadata reference} for complete details.
     */
    untrusted_metadata?: Record<string, unknown>;
    /**
     * Sets whether the Member is enrolled in MFA.
     * If true, the Member must complete an MFA step whenever they wish to log in to their Organization.
     * If false, the Member only needs to complete an MFA step if the Organization's MFA policy is set to REQUIRED_FOR_ALL.
     */
    mfa_enrolled?: boolean;
    /**
     * Sets the Member's phone number. Throws an error if the Member already has a phone number.
     */
    mfa_phone_number?: string;
};
type B2BMemberUpdateResponse = MemberResponseCommon;
type B2BMemberDeleteMFAPhoneNumberResponse = MemberResponseCommon;
type B2BMemberDeletePasswordResponse = MemberResponseCommon;
interface IHeadlessB2BSelfClient {
    /**
     * The asynchronous method for getting the current active member. This wraps the {@link https://stytch.com/docs/b2b/api/search-members search} member endpoint.
     * It fetches the member's data and refreshes the cached object if changes are detected.
     * The Stytch SDK will invoke this method automatically in the background, so you probably won't need to call this method directly.
     *
     * @returns A {@link Member} object, or null if no member exists.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    get(): Promise<Member | null>;
    /**
     * The synchronous method for getting a member. This is the recommended approach. You can listen to changes with the {@link onMemberChange onMemberChange} method.
     * If logged in, this returns the cached member object, otherwise it returns null. This method does not refresh the member's data.
     * The `@stytch/react` library provides the `useStytchMember` hook that implements these methods for you to easily access the member and listen for changes.
     *
     * @returns A {@link Member} object, or null if no user exists.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    getSync(): Member | null;
    /**
     * Allows listening to changes in the member object when using {@link getMemberSync getMemberSync()}.
     *
     * @param callback - Gets called whenever the member object changes. See {@link B2BMemberOnChangeCallback}.
     *
     * @returns An {@link UnsubscribeFunction} for you to call when you no longer want to listen for changes in the member object.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    onChange(callback: B2BMemberOnChangeCallback): UnsubscribeFunction;
    /**
     * The update method wraps the {@link https://stytch.com/docs/b2b/api/update-member member update} API endpoint.
     * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#update-self Stytch Docs} for a complete reference.
     *
     * @example
     * stytch.self.update({
     *   mfa_enrolled: true,
     *   phone_number: '+12025550162',
     * });
     *
     * @param data - {@link B2BMemberUpdateOptions}
     *
     * @returns A {@link B2BMemberUpdateResponse} indicating that the member has been updated.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    update(data: B2BMemberUpdateOptions): Promise<B2BMemberUpdateResponse>;
    /**
     * The delete MFA phone number method wraps the {@link https://stytch.com/docs/b2b/api/delete-member-mfa-phone-number delete phone number} API endpoint.
     * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#delete-self-mfa-phone-number Stytch Docs} for a complete reference.
     *
     * @returns A {@link B2BMemberDeleteMFAPhoneNumberResponse} indicating that the member's phone number has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deleteMFAPhoneNumber(): Promise<B2BMemberDeleteMFAPhoneNumberResponse>;
    /**
     * The delete password method wraps the {@link https://stytch.com/docs/b2b/api/delete-member-password delete password} API endpoint.
     * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#delete-self-password Stytch Docs} for a complete reference.
     *
     * @returns A {@link B2BMemberDeletePasswordResponse} indicating that the member's phone number has been deleted.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    deletePassword(passwordId: string): Promise<B2BMemberDeletePasswordResponse>;
}
type B2BOrganizationsUpdateOptions = {
    /**
     * The name of the organization
     */
    organization_name?: string;
    /**
     * The unique URL slug of the Organization. A minimum of two characters is required.
     * The slug only accepts alphanumeric characters and the following reserved characters: - . _ ~.
     */
    organization_slug?: string;
    /**
     * The image URL of the Organization logo.
     */
    organization_logo_url?: string;
    /**
     * The default connection used for SSO when there are multiple active connections.
     */
    sso_default_connection_id?: string;
    /**
     * The authentication setting that controls the JIT provisioning of Members when authenticating via SSO.
     * The accepted values are:
     *   ALL_ALLOWED  new Members will be automatically provisioned upon successful authentication via any of the Organization's sso_active_connections.
     *   RESTRICTED  only new Members with SSO logins that comply with sso_jit_provisioning_allowed_connections can be provisioned upon authentication.
     *   NOT_ALLOWED  disable JIT provisioning via SSO.
     */
    sso_jit_provisioning?: string;
    /**
     * An array of connection_ids that reference SAML Connection objects.
     * Only these connections will be allowed to JIT provision Members via SSO when sso_jit_provisioning is set to RESTRICTED.
     */
    sso_jit_provisioning_allowed_connections?: string[];
    /**
     * An array of email domains that allow invites or JIT provisioning for new Members.
     * This list is enforced when either email_invites or email_jit_provisioning is set to RESTRICTED.
     * Common domains such as gmail.com are not allowed.
     */
    email_allowed_domains?: string[];
    /**
     * The authentication setting that controls how a new Member can be provisioned by authenticating via Email Magic Link.
     * The accepted values are:
     *   RESTRICTED  only new Members with verified emails that comply with email_allowed_domains can be provisioned upon authentication via Email Magic Link.
     *   NOT_ALLOWED  disable JIT provisioning via Email Magic Link.
     */
    email_jit_provisioning?: "RESTRICTED" | "NOT_ALLOWED";
    /**
     * The authentication setting that controls how a new Member can be invited to an organization by email.
     * The accepted values are:
     *   ALL_ALLOWED  any new Member can be invited to join via email.
     *   RESTRICTED  only new Members with verified emails that comply with email_allowed_domains can be invited via email.
     *   NOT_ALLOWED  disable email invites.
     */
    email_invites?: "ALL_ALLOWED" | "RESTRICTED" | "NOT_ALLOWED";
    /**
     * The setting that controls which authentication methods can be used by Members of an Organization.
     * The accepted values are:
     *   ALL_ALLOWED  the default setting which allows all authentication methods to be used.
     *   RESTRICTED  only methods that comply with allowed_auth_methods can be used for authentication. This setting does not apply to Members with is_breakglass set to true.
     */
    auth_methods?: string;
    /**
     * An array of allowed authentication methods.
     * This list is enforced when auth_methods is set to RESTRICTED.
     * The list's accepted values are: sso, magic_link, password, google_oauth, and microsoft_oauth.
     */
    allowed_auth_methods?: ("sso" | "magic_link" | "password" | "google_oauth" | "microsoft_oauth")[];
    /**
     * The setting that controls the MFA policy for all Members in the Organization. The accepted values are:
     *   REQUIRED_FOR_ALL  All Members within the Organization will be required to complete MFA every time they wish to log in.
     *   OPTIONAL  The default value. The Organization does not require MFA by default for all Members. Members will be required to complete MFA only if their mfa_enrolled status is set to true
     */
    mfa_policy?: string;
    /**
     * An array of implicit role assignments granted to members in this organization whose emails match the domain.
     * See our {@link https://stytch.com/docs/b2b/guides/rbac/role-assignment RBAC guide} for more information about
     * role assignment.
     */
    rbac_email_implicit_role_assignments?: {
        role_id: string;
        domain: string;
    }[];
};
type B2BOrganizationsUpdateResponse = ResponseCommon & {
    /**
     * The Organization object.
     * See {@link Organization} for details.
     */
    organization: Organization;
};
type B2BOrganizationsDeleteResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific Organization.
     */
    organization_id: string;
};
type B2BOrganizationsMembersCreateOptions = {
    /**
     * The email address of the Member.
     */
    email_address: string;
    /**
     * The name of the Member.
     */
    name?: string;
    /**
     * An arbitrary JSON object of application-specific data.
     * These fields can be edited directly by the frontend SDK, and should not be used to store critical information.
     */
    untrusted_metadata?: Record<string, unknown>;
    /**
     * Flag for whether or not to save a Member as pending or active in Stytch. It defaults to false.
     * If true, new Members will be created with status pending in Stytch's backend.
     * Their status will remain pending and they will continue to receive signup email templates for every Email Magic Link until that Member authenticates and becomes active.
     * If false, new Members will be created with status active.
     */
    create_member_as_pending?: boolean;
    /**
     * Identifies the Member as a break glass user - someone who has permissions to authenticate into an Organization by bypassing the Organization's settings.
     * A break glass account is typically used for emergency purposes to gain access outside of normal authentication procedures.
     */
    is_breakglass?: boolean;
    /**
     * The Member's phone number. A Member may only have one phone number.
     */
    mfa_phone_number?: string;
    /**
     * Sets whether the Member is enrolled in MFA.
     * If true, the Member must complete an MFA step whenever they wish to log in to their Organization.
     * If false, the Member only needs to complete an MFA step if the Organization's MFA policy is set to REQUIRED_FOR_ALL.
     */
    mfa_enrolled?: boolean;
    /**
     * Roles to explicitly assign to this Member.
     * See our {@link https://stytch.com/docs/b2b/guides/rbac/role-assignment RBAC guide} for more information about
     * role assignment.
     */
    roles?: string[];
};
type B2BOrganizationsMembersCreateResponse = MemberResponseCommon;
type B2BOrganizationsMembersUpdateOptions = {
    /**
     * Globally unique UUID that identifies a specific Member.
     */
    member_id: string;
    /**
     * The name of the Member.
     */
    name?: string;
    /**
     * An arbitrary JSON object of application-specific data.
     * These fields can be edited directly by the frontend SDK, and should not be used to store critical information.
     */
    untrusted_metadata?: Record<string, unknown>;
    /**
     * Identifies the Member as a break glass user - someone who has permissions to authenticate into an Organization by bypassing the Organization's settings.
     * A break glass account is typically used for emergency purposes to gain access outside of normal authentication procedures.
     */
    is_breakglass?: boolean;
    /**
     * The Member's phone number. A Member may only have one phone number.
     */
    mfa_phone_number?: string;
    /**
     * Sets whether the Member is enrolled in MFA.
     * If true, the Member must complete an MFA step whenever they wish to log in to their Organization.
     * If false, the Member only needs to complete an MFA step if the Organization's MFA policy is set to REQUIRED_FOR_ALL.
     */
    mfa_enrolled?: boolean;
    /**
     * Roles to explicitly assign to this Member. Will completely replace any existing explicitly assigned roles.
     * If a Role is removed from a Member, and the Member is also implicitly assigned this Role from an SSO connection
     * or an SSO group, we will by default revoke any existing sessions for the Member that contain any SSO authentication
     * factors with the affected connection ID. You can preserve these sessions by passing in the
     * preserve_existing_sessions parameter with a value of true.
     * See our {@link https://stytch.com/docs/b2b/guides/rbac/role-assignment RBAC guide} for more information about
     * role assignment.
     */
    roles?: string[];
    /**
     * Whether to preserve existing sessions when explicit Roles that are revoked are also implicitly assigned by SSO
     * connection or SSO group. Defaults to false - that is, existing Member Sessions that contain SSO authentication
     * factors with the affected SSO connection IDs will be revoked.
     */
    preserve_existing_sessions?: boolean;
};
type B2BOrganizationsMembersUpdateResponse = MemberResponseCommon;
type SearchQueryOperand = {
    filter_name: "member_ids";
    filter_value: string[];
} | {
    filter_name: "member_emails";
    filter_value: string[];
} | {
    filter_name: "member_email_fuzzy";
    filter_value: string;
} | {
    filter_name: "member_is_breakglass";
    filter_value: boolean;
} | {
    filter_name: "statuses";
    filter_value: string[];
} | {
    filter_name: "member_mfa_phone_numbers";
    filter_value: string[];
} | {
    filter_name: "member_mfa_phone_number_fuzzy";
    filter_value: string;
} | {
    filter_name: "member_password_exists";
    filter_value: boolean;
} | {
    filter_name: "member_roles";
    filter_value: string[];
} | {
    filter_name: string;
    [key: string]: unknown;
};
type B2BOrganizationsMembersSearchOptions = {
    /**
     * The cursor field allows you to paginate through your results.
     * Each result array is limited to 1000 results.
     * If your query returns more than 1000 results, you will need to paginate the responses using the cursor.
     * If you receive a response that includes a non-null next_cursor in the results_metadata object, repeat the search call with the next_cursor value set to the cursor field to retrieve the next page of results.
     * Continue to make search calls until the next_cursor in the response is null.
     */
    cursor?: string;
    /**
     * The number of search results to return per page.
     * The default limit is 100. A maximum of 1000 results can be returned by a single search request.
     * If the total size of your result set is greater than one page size, you must paginate the response.
     * See the cursor field.
     */
    limit?: number;
    /**
     * The optional query object contains the operator, i.e. AND or OR, and the operands that will filter your results.
     * Only an operator is required. If you include no operands, no filtering will be applied.
     * If you include no query object, it will return all Members with no filtering applied.
     */
    query?: {
        /**
         * The action to perform on the operands. The accepted value are:
         *
         *   `AND`  all the operand values provided must match.
         *
         *   `OR`  the operator will return any matches to at least one of the operand values you supply.
         */
        operator: "OR" | "AND" | string;
        /**
         * An array of operand objects that contains all of the filters and values to apply to your search query.
         */
        operands: SearchQueryOperand[];
    };
};
type B2BOrganizationsMembersSearchResponse = ResponseCommon & {
    members: Member[];
    /**
     * The search `results_metadata` object contains metadata relevant to your specific query like `total` and
     * `next_cursor`.
     */
    results_metadata: {
        total: number;
        /**
         * The `next_cursor` string is returned when your search result contains more than one page of results.
         * This value is passed into your next search call in the `cursor` field.
         */
        next_cursor?: string;
    };
    /**
     * A map from `organization_id` to
     * [Organization object](https://stytch.com/docs/b2b/api/organization-object). The map only contains the
     * Organizations that the Members belongs to.
     */
    organizations: Record<string, Organization>;
};
type B2BOrganizationsMembersDeleteResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific Member.
     */
    member_id: string;
};
type B2BOrganizationsMembersReactivateResponse = MemberResponseCommon;
type B2BOrganizationsMemberDeletePasswordResponse = MemberResponseCommon;
type B2BOrganizationsMemberDeleteMFAPhoneNumberResponse = MemberResponseCommon;
interface IHeadlessB2BOrganizationClient {
    /**
     * The asynchronous method for getting the current active organization. This wraps the {@link https://stytch.com/docs/b2b/api/get-organization get} organization endpoint.
     * It fetches the organization's data.
     *
     * @returns A {@link Organization} object.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    get(): Promise<Organization | null>;
    /**
     * Updates the Organization of the logged-in member.
     * The member must have permission to call this endpoint via the project's RBAC policy & their role assignments.
     * An Organization must always have at least one auth setting set to either RESTRICTED or ALL_ALLOWED in order to provision new Members.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/organizations#update-organization Stytch Docs} for a complete reference.
     *
     * @param data - {@link B2BOrganizationsUpdateOptions}
     *
     * @returns A {@link B2BOrganizationsUpdateResponse} response.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    update(data: B2BOrganizationsUpdateOptions): Promise<B2BOrganizationsUpdateResponse>;
    /**
     * Deletes the Organization of the logged-in member. All Members of the Organization will also be deleted.
     * The member must have permission to call this endpoint via the project's RBAC policy & their role assignments.
     *
     * Note: This endpoint will log out the current member, as they will also be deleted.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/organizations#delete-organization Stytch Docs} for a complete reference.
     *
     * @returns A {@link B2BOrganizationsDeleteResponse} response.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     */
    delete(): Promise<B2BOrganizationsDeleteResponse>;
    members: {
        /**
         * Creates a Member.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#create-member Stytch Docs} for a complete reference.
         *
         * @param data - {@link B2BOrganizationsMembersCreateOptions}
         *
         * @returns A {@link B2BOrganizationsMembersCreateResponse} response.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         */
        create(data: B2BOrganizationsMembersCreateOptions): Promise<B2BOrganizationsMembersCreateResponse>;
        /**
         * Search for Members from the caller's organization. Submitting an empty query returns all non-deleted Members.
         *  *All fuzzy search filters require a minimum of three characters.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#search-members Stytch Docs} for a complete reference.
         *
         * @param data - {@link B2BOrganizationsMembersSearchOptions}
         *
         * @returns A {@link B2BOrganizationsMembersSearchResponse} response.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         */
        search(data: B2BOrganizationsMembersSearchOptions): Promise<B2BOrganizationsMembersSearchResponse>;
        /**
         * Updates a Member.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#update-member Stytch Docs} for a complete reference.
         *
         * @param data - {@link B2BOrganizationsMembersUpdateOptions}
         *
         * @returns A {@link B2BOrganizationsMembersUpdateResponse} response.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         */
        update(data: B2BOrganizationsMembersUpdateOptions): Promise<B2BOrganizationsMembersUpdateResponse>;
        /**
         * Delete a Member's password.
         * The delete password method wraps the {@link https://stytch.com/docs/b2b/api/delete-member-password delete password} API endpoint.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#delete-member-password Stytch Docs} for a complete reference.
         *
         * @param passwordId - The ID of the password to be deleted
         *
         * @returns A {@link B2BOrganizationsMemberDeletePasswordResponse} response.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         */
        deletePassword(passwordId: string): Promise<B2BOrganizationsMemberDeletePasswordResponse>;
        /**
         * Delete a Member's MFA phone number.
         * To change a Member's phone number, you must first call this endpoint to delete the existing phone number.
         * Existing Member Sessions that include a phone number authentication factor will not be revoked if the phone number is deleted,
         * and MFA will not be enforced until the Member logs in again. If you wish to enforce MFA immediately after a phone number is deleted,
         * you can do so by prompting the Member to enter a new phone number and calling the OTP SMS send endpoint,
         * then calling the OTP SMS Authenticate endpoint.
         *
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#delete-member-mfa-phone-number Stytch Docs} for a complete reference.
         *
         * @param memberId - The ID of the member
         *
         * @returns A {@link B2BOrganizationsMemberDeleteMFAPhoneNumberResponse} response.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         */
        deleteMFAPhoneNumber(memberId: string): Promise<B2BOrganizationsMemberDeleteMFAPhoneNumberResponse>;
        /**
         * Deletes a Member.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#delete-member Stytch Docs} for a complete reference.
         *
         * @param memberId - The ID of the member to be deleted
         *
         * @returns A {@link B2BOrganizationsMembersDeleteResponse} response.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         */
        delete(memberId: string): Promise<B2BOrganizationsMembersDeleteResponse>;
        /**
         * Reactivates a deleted Member's status and its associated email status (if applicable) to active.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/members#reactivate-member Stytch Docs} for a complete reference.
         *
         * @param memberId - The ID of the member to be reactivated
         *
         * @returns A {@link B2BOrganizationsMembersReactivateResponse} response.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         */
        reactivate(memberId: string): Promise<B2BOrganizationsMembersReactivateResponse>;
    };
}
type OAuthOrgSelectorOptions = {
    /**
     * The id of the organization the member belongs to.
     */
    organization_id: string;
    /**
     * The slug of the organization the member belongs to.
     */
    organization_slug?: never;
} | {
    organization_slug: string;
    organization_id?: never;
};
type OAuthStartOptions = OAuthOrgSelectorOptions & {
    /**
     * The URL that Stytch redirects to after the OAuth flow is completed for a member that already exists.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /oauth/authenticate endpoint and finishes the login.
     * The URL should be configured as a Login URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    login_redirect_url?: string;
    /**
     * The URL that Stytch redirects to after the OAuth flow is completed for a member that does not yet exist.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /oauth/authenticate endpoint and finishes the login.
     * The URL should be configured as a Sign Up URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    signup_redirect_url?: string;
    /**
     * An optional list of custom scopes that you'd like to request from the member in addition to the ones Stytch requests by default.
     * @example Google Custom Scopes
     * ['https://www.googleapis.com/auth/gmail.compose', 'https://www.googleapis.com/auth/firebase']
     */
    custom_scopes?: string[];
    /**
     * An optional mapping of provider specific values to pass through as query params to the OAuth provider
     * @example Google authorization parameters
     * {"prompt": "select_account", "login_hint": "example@stytch.com"}
     */
    provider_params?: Record<string, string>;
};
type B2BOAuthDiscoveryStartOptions = {
    /**
     * The URL that Stytch redirects to after the OAuth flow is completed for the member to perform discovery actions.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /oauth/discovery/authenticate endpoint and finishes the login.
     * The URL should be configured as a Discovery URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    discovery_redirect_url?: string;
    /**
     * An optional list of custom scopes that you'd like to request from the member in addition to the ones Stytch requests by default.
     * @example Google Custom Scopes
     * ['https://www.googleapis.com/auth/gmail.compose', 'https://www.googleapis.com/auth/firebase']
     */
    custom_scopes?: string[];
    /**
     * An optional mapping of provider specific values to pass through to the OAuth provider
     * @example Google authorization parameters
     * {"prompt": "select_account", "login_hint": "example@stytch.com"}
     */
    provider_params?: Record<string, string>;
};
type B2BOAuthAuthenticateOptions = SessionDurationOptions & {
    /**
     *  The oauth token used to authenticate a member
     */
    oauth_token: string;
    /**
     * The locale will be used if an OTP code is sent to the member's phone number as part of a
     * secondary authentication requirement.
     */
    locale?: locale;
};
type OAuthDiscoveryAuthenticateOptions = {
    /**
     *  The oauth token used to finish the discovery flow
     */
    discovery_oauth_token: string;
};
type B2BOAuthDiscoveryAuthenticateResponse = B2BDiscoveryAuthenticateResponse;
type B2BOAuthAuthenticateResponse = B2BAuthenticateResponseWithMFA & {
    /**
     * The `provider_values` object lists relevant identifiers, values, and scopes for a given OAuth provider.
     * For example this object will include a provider's `access_token` that you can use to access the provider's API for a given member.
     * Note that these values will vary based on the OAuth provider in question, e.g. `id_token` may not be returned by all providers.
     */
    provider_values: {
        /**
         * The `access_token` that you may use to access the member's data in the provider's API.
         */
        access_token: string;
        /**
         * The `id_token` returned by the OAuth provider.
         * ID Tokens are JWTs that contain structured information about a user.
         * The exact content of each ID Token varies from provider to provider.
         * ID Tokens are returned from OAuth providers that conform to the {@link https://openid.net/foundation/ OpenID Connect} specification, which is based on OAuth.
         */
        id_token: string;
        /**
         * The `refresh_token` that you may use to refresh a member's session within the provider's API.
         */
        refresh_token: string;
        /**
         * The OAuth scopes included for a given provider.
         * See each provider's section above to see which scopes are included by default and how to add custom scopes.
         */
        scopes: string[];
    };
};
/**
 * Methods for interacting with an individual OAuth provider.
 */
interface IOAuthProvider$0 {
    /**
     * Start an OAuth flow by redirecting the browser to one of Stytch's {@link https://stytch.com/docs/b2b/api/oauth-google-start oauth start} endpoints.
     * If enabled, this method will also generate a PKCE code_verifier and store it in localstorage on the device (See the {@link https://stytch.com/docs/oauth#guides_pkce PKCE OAuth guide} for details).
     * If your application is configured to use a custom subdomain with Stytch, it will be used automatically.
     * @example
     * const loginWithGoogle = useCallback(()=> {
     *   stytch.oauth.google.start({
     *     login_redirect_url: 'https://example.com/oauth/callback',
     *     signup_redirect_url: 'https://example.com/oauth/callback',
     *     organization_id: 'organization-test-123',
     *     custom_scopes: ['https://www.googleapis.com/auth/gmail.compose']
     *   })
     * }, [stytch]);
     * return (
     *   <Button onClick={loginWithGoogle}> Log in with OAuth Provider </Button>
     * );
     *
     * @param options - An {@link OAuthStartOptions} object
     *
     * @returns void - the browser is redirected during this function call. You should not attempt to run any code after calling this function.
     *
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    start(data: OAuthStartOptions): Promise<void>;
    discovery: {
        /**
         * Start a discovery OAuth login flow by redirecting the browser to Stytch's {@link https://stytch.com/docs/b2b/api/oauth-google-discovery-start OAuth discovery start} endpoint.
         * If enabled, this method will also generate a pkce_code_verifier and store it in localstorage on the device.
         * @example
         * const loginWithGoogle = useCallback(()=> {
         *   stytch.oauth.discovery.start({
         *     discovery_redirect_url: 'https://example.com/oauth/login',
         *     custom_scopes: 'profile avatar',
         *   })
         * }, [stytch]);
         * return (
         *   <Button onClick={loginWithGoogle}> Log in with IDP </Button>
         * );
         *
         * @param data - An {@link B2BOAuthDiscoveryStartOptions} object
         *
         * @returns void - the browser is redirected during this function call. You should not attempt to run any code after calling this function.
         *
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        start(data: B2BOAuthDiscoveryStartOptions): Promise<void>;
    };
}
interface IHeadlessB2BOAuthClient {
    google: IOAuthProvider$0;
    microsoft: IOAuthProvider$0;
    /**
     * Start an OAuth Login flow by redirecting the browser to Stytch's {@link https://stytch.com/docs/b2b/api/oauth-google-start OAuth start} endpoint.
     * If enabled, this method will also generate a pkce_code_verifier and store it in localstorage on the device.
     * If your application is configured to use a custom subdomain with Stytch, it will be used automatically.
     * @example
     * const loginWithGoogle = useCallback(()=> {
     *   stytch.oauth.start({
     *     login_redirect_url: 'https://example.com/oauth/login',
     *     signup_redirect_url: 'https://example.com/oauth/signup',
     *     organization_id: 'organization-test-123',
     *   })
     * }, [stytch]);
     * return (
     *   <Button onClick={loginWithGoogle}> Log in with IDP </Button>
     * );
     *
     * @param data - An {@link OAuthStartOptions} object
     *
     * @returns void - the browser is redirected during this function call. You should not attempt to run any code after calling this function.
     *
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    authenticate(data: B2BOAuthAuthenticateOptions): Promise<B2BOAuthAuthenticateResponse>;
    discovery: {
        /**
         * The authenticate method wraps the {@link https://stytch.com/docs/b2b/api/authenticate-discovery-oauth OAuth Discovery Authenticate} API endpoint.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/oauth#discovery-authenticate Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.oauth.discovery.authenticate({
         *   discovery_oauth_token: 'token',
         * });
         *
         * @param data - {@link OAuthDiscoveryAuthenticateOptions}
         *
         * @returns A {@link B2BOAuthDiscoveryAuthenticateResponse} indicating that the OAuth flow has been authenticated.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        authenticate(data: OAuthDiscoveryAuthenticateOptions): Promise<B2BOAuthDiscoveryAuthenticateResponse>;
    };
}
type SSOStartOptions = {
    /**
     * The ID of the SSO Connection to use for the login flow
     *
     * @example "saml-connection-test-51861cbc-d3b9-428b-9761-227f5fb12be9"
     */
    connection_id: string;
    /**
     * The URL that Stytch redirects to after the SSO flow is completed for a user that already exists.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /sso/authenticate endpoint and finishes the login.
     * The URL should be configured as a Login URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    login_redirect_url?: string;
    /**
     * The URL that Stytch redirects to after the SSO flow is completed for a user that does not yet exist.
     * This URL should be an endpoint in the backend server that verifies the request by querying Stytch's /sso/authenticate endpoint and finishes the login.
     * The URL should be configured as a Sign Up URL in the Stytch Dashboard's Redirect URL page.
     * If the field is not specified, the default in the Dashboard is used.
     */
    signup_redirect_url?: string;
};
type SSOAuthenticateOptions = SessionDurationOptions & {
    /**
     *  The sso token used to authenticate a member
     */
    sso_token: string;
    /**
     * The locale will be used if an OTP code is sent to the member's phone number as part of a
     * secondary authentication requirement.
     */
    locale?: locale;
};
type SSOAuthenticateResponse = B2BAuthenticateResponseWithMFA;
type B2BSSOSAMLCreateConnectionOptions = {
    /**
     * A human-readable display name for the connection.
     */
    display_name?: string;
};
type B2BSSOSAMLCreateConnectionResponse = ResponseCommon & {
    /**
     * The SAML Connection object affected by this API call.
     */
    connection: SAMLConnection;
};
type B2BSSOSAMLUpdateConnectionOptions = {
    /**
     * Globally unique UUID that identifies a specific SAML Connection.
     */
    connection_id: string;
    /**
     * A globally unique name for the IdP. This will be provided by the IdP.
     */
    idp_entity_id?: string;
    /**
     * A human-readable display name for the connection.
     */
    display_name?: string;
    /**
     * An object that represents the attributes used to identify a Member.
     * This object will map the IdP-defined User attributes to Stytch-specific values.
     * Required attributes: `email` and one of `full_name` or `first_name` and `last_name`.
     */
    attribute_mapping?: Record<string, string>;
    /**
     * The URL for which assertions for login requests will be sent. This will be provided by the IdP.
     */
    idp_sso_url?: string;
    /**
     * A certificate that Stytch will use to verify the sign-in assertion sent by the IdP,
     * in {@link https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail PEM} format.
     * See our {@link https://stytch.com/docs/b2b/api/saml-certificates X509 guide} for more info.
     */
    x509_certificate?: string;
    /**
     * An array of implicit role assignments granted to members in this organization who log in with this SAML connection.
     * See our {@link https://stytch.com/docs/b2b/guides/rbac/role-assignment RBAC guide} for more information about
     * role assignment.
     */
    saml_connection_implicit_role_assignments?: {
        role_id: string;
    }[];
    /**
     * An array of implicit role assignments granted to members in this organization who log in with this SAML connection
     * and belong to the specified group.
     * Before adding any group implicit role assignments, you must add a "groups" key to your SAML connection's
     * attribute_mapping. Make sure that your IdP is configured to correctly send the group information.
     * See our {@link https://stytch.com/docs/b2b/guides/rbac/role-assignment RBAC guide} for more information about
     * role assignment.
     */
    saml_group_implicit_role_assignments?: {
        role_id: string;
        group: string;
    }[];
};
type B2BSSOSAMLUpdateConnectionResponse = ResponseCommon & {
    /**
     * The SAML Connection object affected by this API call.
     */
    connection: SAMLConnection;
};
type B2BSSOSAMLUpdateConnectionByURLOptions = {
    /**
     * Globally unique UUID that identifies a specific SAML Connection.
     */
    connection_id: string;
    /**
     * A URL that points to the IdP metadata. This will be provided by the IdP.
     */
    metadata_url: string;
};
type B2BSSOSAMLUpdateConnectionByURLResponse = ResponseCommon & {
    /**
     * The SAML Connection object affected by this API call.
     */
    connection: SAMLConnection;
};
type B2BSSOSAMLDeleteVerificationCertificateOptions = {
    /**
     * Globally unique UUID that identifies a specific SAML Connection.
     */
    connection_id: string;
    /**
     * The ID of the certificate to be deleted.
     */
    certificate_id: string;
};
type B2BSSOSAMLDeleteVerificationCertificateResponse = ResponseCommon & {
    /**
     * The ID of the certificate that was deleted.
     */
    certificate_id: string;
};
type B2BSSOOIDCCreateConnectionOptions = {
    /**
     * A human-readable display name for the connection.
     */
    display_name?: string;
};
type B2BSSOOIDCCreateConnectionResponse = ResponseCommon & {
    /**
     * The OIDC Connection object affected by this API call.
     */
    connection: OIDCConnection;
};
type B2BSSOOIDCUpdateConnectionOptions = {
    /**
     * Globally unique UUID that identifies a specific OIDC Connection.
     */
    connection_id: string;
    /**
     * A human-readable display name for the connection.
     */
    display_name?: string;
    /**
     * A case-sensitive `https://` URL that uniquely identifies the IdP. This will be provided by the IdP.
     */
    issuer?: string;
    /**
     * The OAuth2.0 client ID used to authenticate login attempts. This will be provided by the IdP.
     */
    client_id?: string;
    /**
     * The secret belonging to the OAuth2.0 client used to authenticate login attempts. This will be provided by the IdP.
     */
    client_secret?: string;
    /**
     * The location of the URL that starts an OAuth login at the IdP. This will be provided by the IdP.
     */
    authorization_url?: string;
    /**
     * The location of the URL that issues OAuth2.0 access tokens and OIDC ID tokens. This will be provided by the IdP.
     */
    token_url?: string;
    /**
     * The location of the IDP's UserInfo Endpoint. This will be provided by the IdP.
     */
    userinfo_url?: string;
    /**
     * The location of the IdP's JSON Web Key Set, used to verify credentials issued by the IdP. This will be provided by the IdP.
     */
    jwks_url?: string;
};
type B2BSSOOIDCUpdateConnectionResponse = ResponseCommon & {
    /**
     * The OIDC Connection object affected by this API call.
     */
    connection: OIDCConnection;
    /**
     * If it is not possible to resolve the well-known metadata document from the OIDC issuer, this field will explain what went wrong if the request is successful otherwise.
     * In other words, even if the overall request succeeds, there could be relevant warnings related to the connection update.
     */
    warning: string;
};
type B2BSSOGetConnectionsResponse = ResponseCommon & {
    /**
     * The list of SAML Connections owned by this organization.
     */
    saml_connections: SAMLConnection[];
    /**
     * The list of OIDC Connections owned by this organization.
     */
    oidc_connections: OIDCConnection[];
};
type B2BSSODeleteConnectionResponse = ResponseCommon & {
    /**
     * Globally unique UUID that identifies a specific SSO Connection.
     */
    connection_id: string;
};
interface IHeadlessB2BSSOClient {
    /**
     * Start an SSO Login flow by redirecting the browser to Stytch's {@link https://stytch.com/docs/b2b/api/sso-authenticate-start SSO start} endpoint.
     * If enabled, this method will also generate a PKCE code_verifier and store it in localstorage on the device.
     * @example
     * const loginWithOkta = useCallback(()=> {
     *   stytch.sso.start({
     *     connection_id: 'saml-connection-test-51861cbc-d3b9-428b-9761-227f5fb12be9',
     *     login_redirect_url: 'https://example.com/oauth/callback',
     *     signup_redirect_url: 'https://example.com/oauth/callback',
     *   })
     * }, [stytch]);
     * return (
     *   <Button onClick={loginWithOkta}> Log in with IDP </Button>
     * );
     *
     * @param data - An {@link SSOStartOptions} object
     *
     * @returns void - the browser is redirected during this function call. You should not attempt to run any code after calling this function.
     *
     * @throws A {@link StytchSDKUsageError} when called with invalid input.
     */
    start(data: SSOStartOptions): Promise<void>;
    /**
     * The authenticate method wraps the {@link https://stytch.com/docs/b2b/api/sso-authenticate SSO Authenticate} API endpoint.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/sso#authenticate Stytch Docs} for a complete reference.
     *
     * @example
     * stytch.sso.authenticate({
     *   sso_token: 'token',
     *   session_duration_minutes: 60,
     * });
     *
     * @param data - {@link SSOAuthenticateOptions}
     *
     * @returns A {@link SSOAuthenticateResponse} indicating that the SSO flow has been authenticated and the member is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    authenticate(data: SSOAuthenticateOptions): Promise<SSOAuthenticateResponse>;
    /**
     * Get all SSO Connections owned by the organization.
     * This method wraps the {@link https://stytch.com/docs/b2b/api/get-sso-connections Get SSO Connections} API endpoint.
     * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/sso#get-connections Stytch Docs} for a complete reference.
     *
     * @example
     * stytch.sso.getConnections();
     *
     * @returns A {@link B2BSSOGetConnectionsResponse} containing the organization's SSO connections
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    getConnections(): Promise<B2BSSOGetConnectionsResponse>;
    /**
     * Delete an existing SSO connection.
     * This method wraps the {@link https://stytch.com/docs/b2b/api/delete-sso-connection Delete SSO Connection} API endpoint.
     * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
     *
     * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/sso#delete-connection Stytch Docs} for a complete reference.
     *
     * @example
     * stytch.sso.deleteConnection('saml-connection-test-51861cbc-d3b9-428b-9761-227f5fb12be9');
     *
     * @param connectionId - The ID of the connection to delete
     *
     * @returns A {@link B2BSSODeleteConnectionResponse} indicating that the SSO connection has been created.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    deleteConnection(connectionId: string): Promise<B2BSSODeleteConnectionResponse>;
    saml: {
        /**
         * Create a new SAML Connection.
         * This method wraps the {@link https://stytch.com/docs/b2b/api/create-saml-connection Create SAML Connection} API endpoint.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/sso#create-saml-connection Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.sso.saml.createConnection({
         *   display_name: 'OneLogin SAML Connection',
         * });
         *
         * @param data - {@link B2BSSOSAMLCreateConnectionOptions}
         *
         * @returns A {@link B2BSSOSAMLCreateConnectionResponse} indicating that the SSO connection has been created.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        createConnection(data: B2BSSOSAMLCreateConnectionOptions): Promise<B2BSSOSAMLCreateConnectionResponse>;
        /**
         * Updates an existing SAML connection.
         * Note that a newly created connection will not become active until all of the following are provided:
         * - `idp_sso_url`
         * - `attribute_mapping`
         * - `idp_entity_id`
         * - `x509_certificate`
         *
         * This method wraps the {@link https://stytch.com/docs/b2b/api/update-saml-connection Update SAML Connection} API endpoint.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/sso#update-saml-connection Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.sso.saml.updateConnection({
         *   connection_id: 'saml-connection-test-51861cbc-d3b9-428b-9761-227f5fb12be9',
         *   x509_certificate: '-----BEGIN CERTIFICATE----...',
         * });
         *
         * @param data - {@link B2BSSOSAMLUpdateConnectionOptions}
         *
         * @returns A {@link B2BSSOSAMLUpdateConnectionResponse} indicating that the SSO connection has been updated.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        updateConnection(data: B2BSSOSAMLUpdateConnectionOptions): Promise<B2BSSOSAMLUpdateConnectionResponse>;
        /**
         * Updates an existing SAML connection using an IDP metadata URL.
         * Note that a newly created connection will not become active until all of the following are provided:
         * - `idp_sso_url`
         * - `attribute_mapping`
         * - `idp_entity_id`
         * - `x509_certificate`
         *
         * This method wraps the {@link https://stytch.com/docs/b2b/api/update-saml-connection-url Update SAML Connection by Metadata URL} API endpoint.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/sso#update-saml-connection-url Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.sso.saml.updateConnectionByURL({
         *   connection_id: 'saml-connection-test-51861cbc-d3b9-428b-9761-227f5fb12be9',
         *   metadata_url: 'https://idp.example.com/app/51861cbc-d3b9-428b-9761-227f5fb12be9/sso/saml/metadata',
         * });
         *
         * @param data - {@link B2BSSOSAMLUpdateConnectionByURLOptions}
         *
         * @returns A {@link B2BSSOSAMLUpdateConnectionByURLResponse} indicating that the SSO connection has been updated.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        updateConnectionByURL(data: B2BSSOSAMLUpdateConnectionByURLOptions): Promise<B2BSSOSAMLUpdateConnectionByURLResponse>;
        /**
         * Delete a SAML verification certificate.
         * You may need to do this when rotating certificates from your IdP, since Stytch allows a maximum of 5 certificates per connection.
         * There must always be at least one certificate per active connection.
         *
         * This method wraps the {@link https://stytch.com/docs/b2b/api/delete-verification-certificate Delete Verification Certificate} API endpoint.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/sso#delete-verification-certificate Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.sso.saml.deleteVerificationCertificate({
         *   connection_id: 'saml-connection-test-51861cbc-d3b9-428b-9761-227f5fb12be9',
         *   certificate_id: 'saml-verification-key-test-5ccbc642-9373-42b8-928f-c1646c868701',
         * });
         *
         * @param data - {@link B2BSSOSAMLDeleteVerificationCertificateOptions}
         *
         * @returns A {@link B2BSSOSAMLDeleteVerificationCertificateResponse} indicating that the Verification Certificate has been deleted.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        deleteVerificationCertificate(data: B2BSSOSAMLDeleteVerificationCertificateOptions): Promise<B2BSSOSAMLDeleteVerificationCertificateResponse>;
    };
    oidc: {
        /**
         * Create a new OIDC Connection.
         * This method wraps the {@link https://stytch.com/docs/b2b/api/create-oidc-connection Create OIDC Connection} API endpoint.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/sso#create-oidc-connection Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.sso.oidc.createConnection({
         *   display_name: 'OneLogin OIDC Connection',
         * });
         *
         * @param data - {@link B2BSSOOIDCCreateConnectionOptions}
         *
         * @returns A {@link B2BSSOOIDCCreateConnectionResponse} indicating that the SSO connection has been created.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        createConnection(data: B2BSSOOIDCCreateConnectionOptions): Promise<B2BSSOOIDCCreateConnectionResponse>;
        /**
         * Updates an existing OIDC connection.
         * When the value of issuer changes, Stytch will attempt to retrieve the OpenID Provider Metadata document found at `${issuer}/.well-known/openid-configuration`.
         * If the metadata document can be retrieved successfully, Stytch will use it to infer the values of `authorization_url`, `token_url`, `jwks_url`, and `userinfo_url`.
         * The `client_id` and `client_secret` values cannot be inferred from the metadata document, and must be passed in explicitly.
         *
         * If the metadata document cannot be retrieved, Stytch will still update the connection using values from the request body.
         *
         * If the metadata document can be retrieved, and values are passed in the request body, the explicit values passed in from the request body will take precedence over the values inferred from the metadata document.
         *
         * Note that a newly created connection will not become active until all of the following fields are provided:
         * - `issuer`
         * - `client_id`
         * - `client_secret`
         * - `authorization_url`
         * - `token_url`
         * - `userinfo_url`
         * - `jwks_url`
         *
         * This method wraps the {@link https://stytch.com/docs/b2b/api/update-saml-connection Update SAML Connection} API endpoint.
         * The caller must have permission to call this endpoint via the project's RBAC policy & their role assignments.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/sso#update-oidc-connection Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.sso.oidc.updateConnection({
         *   connection_id: 'oidc-connection-test-b6c714c2-7413-4b92-a0f1-97aa1085aeff',
         *   client_id: "s6BhdRkqt3",
         *   client_secret: "SeiGwdj5lKkrEVgcEY3QNJXt6srxS3IK2Nwkar6mXD4="
         * });
         *
         * @param data - {@link B2BSSOOIDCUpdateConnectionOptions}
         *
         * @returns A {@link B2BSSOOIDCUpdateConnectionResponse} indicating that the SSO connection has been updated.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
         */
        updateConnection(data: B2BSSOOIDCUpdateConnectionOptions): Promise<B2BSSOOIDCUpdateConnectionResponse>;
    };
}
/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `sso`, `passwords`, and `oauth`.
 */
declare enum B2BProducts {
    emailMagicLinks = "emailMagicLinks",
    sso = "sso",
    passwords = "passwords",
    oauth = "oauth"
}
declare enum AuthFlowType {
    Discovery = "Discovery",
    Organization = "Organization",
    PasswordReset = "PasswordReset"
}
/**
 * The options for email magic links. This is required if you've enabled the `emailMagicLinks` product
 * in your configuration.
 */
type B2BEmailMagicLinksOptions = {
    loginRedirectURL?: string;
    signupRedirectURL?: string;
    discoveryRedirectURL?: string;
    loginTemplateId?: string;
    signupTemplateId?: string;
    /**
     * @param domainHint - An optional hint indicating what domain the email will be sent from.
     * This field is only required if your project uses more than one custom domain to send emails.
     */
    domainHint?: string;
};
/**
 * The options for SSO. This is required if you've enabled the `sso` product
 * in your configuration.
 */
type B2BSSOOptions = {
    loginRedirectURL?: string;
    signupRedirectURL?: string;
};
/**
 * The options for OAuth. This is required if you've enabled the `oauth` product
 * in your configuration.
 */
type B2BOAuthOptions = {
    loginRedirectURL?: string;
    signupRedirectURL?: string;
    discoveryRedirectURL?: string;
    customScopes?: string[];
    providers: B2BOAuthProviders[];
    providerParams?: Record<string, string>;
};
/**
 * The options for Passwords. This is required if you've enabled the `passwords` product
 * in your configuration.
 */
type B2BPasswordOptions = {
    loginRedirectURL: string;
    resetPasswordRedirectURL: string;
    resetPasswordExpirationMinutes?: number;
    resetPasswordTemplateId?: string;
};
type DirectLoginForSingleMembershipConfig = {
    /**
     * Whether or not direct login for single membership is enabled.
     */
    status: boolean;
    /**
     * If enabled, logs user in directly even if they have pending invite to a different organization
     */
    ignoreInvites: boolean;
    /**
     * If enabled, logs user in directly even if they have organizations they could join via JIT provisioning
     */
    ignoreJitProvisioning: boolean;
};
type StytchB2BUIConfig = {
    /**
     * The products array allows you to specify the authentication methods that you would like to
     * expose to your users. The order of the products that you include here will also be the order
     * in which they appear in the login form,
     */
    products: B2BProducts[];
    authFlowType: AuthFlowType;
    sessionOptions: SessionOptions;
    emailMagicLinksOptions?: B2BEmailMagicLinksOptions;
    ssoOptions?: B2BSSOOptions;
    passwordOptions?: B2BPasswordOptions;
    oauthOptions?: B2BOAuthOptions;
    /**
     * An optional config that allows you to skip the discover flow and log a member
     * in directly only if they are a member of a single organization.
     */
    directLoginForSingleMembership?: DirectLoginForSingleMembershipConfig;
};
/**
 * The OAuth providers we support in our B2B OAuth product.
 * Currently we support `google`, and `microsoft`.
 */
declare enum B2BOAuthProviders {
    Google = "google",
    Microsoft = "microsoft"
}
type B2BPasswordAuthenticateOptions = SessionDurationOptions & {
    /**
     * The id of the Organization under which the Member and password belong
     */
    organization_id: string;
    /**
     * The email of the Member.
     */
    email_address: string;
    /**
     * The password for the Member.
     */
    password: string;
    /**
     * The locale will be used if an OTP code is sent to the member's phone number as part of a
     * secondary authentication requirement.
     */
    locale?: locale;
};
type B2BPasswordAuthenticateResponse = B2BAuthenticateResponseWithMFA;
type B2BPasswordResetByEmailStartOptions = {
    /**
     * The id of the Organization under which the Member and password belong
     */
    organization_id: string;
    /**
     * The email of the Member that requested the password reset.
     */
    email_address: string;
    /**
     * The url that the Member clicks from the password reset email to skip resetting their password and directly login.
     * This should be a url that your app receives, parses, and subsequently sends an API request to the magic link authenticate endpoint to complete the login process without reseting their password.
     * If this value is not passed, the login redirect URL that you set in your Dashboard is used.
     * If you have not set a default login redirect URL, an error is returned.
     */
    login_redirect_url?: string;
    /**
     * The url that the Member clicks from the password reset email to finish the reset password flow.
     * This should be a url that your app receives and parses before showing your app's reset password page.
     * After the Member submits a new password to your app, it should send an API request to complete the password reset process.
     * If this value is not passed, the default reset password redirect URL that you set in your Dashboard is used.
     * If you have not set a default reset password redirect URL, an error is returned.
     */
    reset_password_redirect_url?: string;
    /**
     * Set the expiration for the password reset, in minutes.
     * By default, it expires in 30 minutes.
     * The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     */
    reset_password_expiration_minutes?: number;
    /**
     * The email template ID to use for password reset.
     * If not provided, your default email template will be sent. If providing a template ID, it must be either a template using Stytch's customizations,
     * or a Passwords reset custom HTML template.
     */
    reset_password_template_id?: string;
};
type B2BPasswordResetByEmailStartResponse = MemberResponseCommon;
type B2BPasswordResetByEmailOptions = SessionDurationOptions & {
    /**
     * The token to authenticate.
     */
    password_reset_token: string;
    /**
     * The new password for the Member.
     */
    password: string;
    /**
     * The locale will be used if an OTP code is sent to the member's phone number as part of a
     * secondary authentication requirement.
     */
    locale?: locale;
};
type B2BPasswordResetByEmailResponse = B2BAuthenticateResponseWithMFA;
type B2BPasswordResetByExistingPasswordOptions = SessionDurationOptions & {
    /**
     * The id of the Organization under which the Member and password belong
     */
    organization_id: string;
    /**
     * The Member's email.
     */
    email_address: string;
    /**
     * The Member's existing password.
     */
    existing_password: string;
    /**
     * The new password for the Member.
     */
    new_password: string;
    /**
     * The locale will be used if an OTP code is sent to the member's phone number as part of a
     * secondary authentication requirement.
     */
    locale?: locale;
};
type B2BPasswordResetByExistingPasswordResponse = B2BAuthenticateResponseWithMFA;
type B2BPasswordResetBySessionOptions = {
    /**
     * The new password for the Member.
     */
    password: string;
};
type B2BPasswordResetBySessionResponse = B2BAuthenticateResponseWithMFA;
type B2BPasswordStrengthCheckOptions = {
    /**
     * The email associated with the password. Provide this for a more accurate strength check.
     */
    email_address?: string;
    /**
     * The password to strength check.
     */
    password: string;
};
type B2BPasswordStrengthCheckResponse = MemberResponseCommon & {
    /**
     * Whether the password is considered valid and secure.
     * Read more about password validity {@link https://stytch.com/docs/api/password-strength-check in our docs}.
     */
    valid_password: boolean;
    /**
     * The score of the password as determined by {@link https://github.com/dropbox/zxcvbn zxcvbn}.
     */
    score: number;
    /**
     * Determines if the password has been breached using {@link https://haveibeenpwned.com/ HaveIBeenPwned}.
     */
    breached_password: boolean;
    /**
     * Will return true if breach detection will be evaluated. By default this option is enabled.
     * This option can be disabled by contacting support@stytch.com. If this value is false then
     * breached_password will always be false as well.
     */
    breach_detection_on_create: boolean;
    /**
     * The strength policy type enforced, either `zxcvbn` or `luds`.
     */
    strength_policy: "luds" | "zxcvbn";
    /**
     * Feedback for how to improve the password's strength using {@link https://github.com/dropbox/zxcvbn zxcvbn}.
     */
    zxcvbn_feedback: {
        suggestions: string[];
        warning: string;
    };
    /**
     * Feedback for how to improve the password's strength using Lowercase Uppercase Digits Special Characters
     */
    luds_feedback: {
        has_lower_case: boolean;
        has_upper_case: boolean;
        has_digit: boolean;
        has_symbol: boolean;
        missing_complexity: number;
        missing_characters: number;
    };
};
interface IHeadlessB2BPasswordClient {
    /**
     * The Authenticate method wraps the {@link https://stytch.com/docs/b2b/api/passwords-authenticate Authenticate} Password API endpoint.
     * This endpoint verifies that the Member has a password currently set, and that the entered password is correct.
     *
     * There are cases where this endpoint will return a `reset_password` error even if the password entered is correct.
     * View our {@link https://stytch.com/docs/api/password-authenticate API Docs} for complete details.
     *
     * If this method succeeds, the Member will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * stytch.passwords.authenticate({
     *   email_address: 'sandbox@stytch.com',
     *   password: 'aVerySecurePassword',
     *   session_duration_minutes: 60
     * });
     *
     * @param options - {@link B2BPasswordAuthenticateOptions}
     *
     * @returns A {@link B2BPasswordAuthenticateResponse} indicating the password is valid and that the Member is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    authenticate(options: B2BPasswordAuthenticateOptions): Promise<B2BPasswordAuthenticateResponse>;
    /**
     * The resetByEmailStart method wraps the {@link https://stytch.com/docs/b2b/api/email-reset-start Reset By Email Start} Password API endpoint.
     * This endpoint initiates a password reset for the email address provided.
     * This will trigger an email to be sent to the address, containing a magic link that will allow them to set a new password and authenticate.
     *
     * @example
     * stytch.passwords.resetByEmailStart({
     *   email_address: 'sandbox@stytch.com',
     *   reset_password_redirect_url: 'https://example.com/login/reset',
     *   reset_password_expiration_minutes: 10,
     *   login_redirect_url: 'https://example.com/login/authenticate',
     * });
     *
     * @param options - {@link B2BPasswordResetByEmailStartOptions}
     *
     * @returns A {@link B2BPasswordResetByEmailStartResponse} indicating the password is valid and that the Member is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByEmailStart(options: B2BPasswordResetByEmailStartOptions): Promise<B2BPasswordResetByEmailStartResponse>;
    /**
     * The resetByEmail method wraps the {@link https://stytch.com/docs/b2b/api/email-reset Reset By Email} Password API endpoint.
     * This endpoint the Members password and authenticate them.
     * This endpoint checks that the magic link token is valid, hasn't expired, or already been used.
     * The provided password needs to meet our password strength requirements, which can be checked in advance with the {@link IHeadlessB2BPasswordClient#strengthCheck password strength} endpoint.
     *
     * If this method succeeds, the Member will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     *
     * @example
     * const currentLocation = new URL(window.location.href);
     * const token = currentLocation.searchParams.get('token');
     * stytch.passwords.resetByEmail({
     *   token,
     *   email_address: 'sandbox@stytch.com',
     *   password: 'aVerySecurePassword',
     *   session_duration_minutes: 60
     * });
     *
     * @param options - {@link B2BPasswordResetByEmailOptions}
     *
     * @returns A {@link B2BPasswordResetByEmailResponse} indicating the password is valid and that the Member is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByEmail(options: B2BPasswordResetByEmailOptions): Promise<B2BPasswordResetByEmailResponse>;
    /**
     * The strengthCheck method wraps the {@link https://stytch.com/docs/b2b/api/strength-check Strength Check} Password API endpoint.
     * This endpoint allows you to check whether or not the Members provided password is valid,
     * and to provide feedback to the Member on how to increase the strength of their password.
     *
     * @example
     * const {valid_password, feedback} = await stytch.passwords.strengthCheck({ email, password });
     * if (!valid_password) {
     *   throw new Error('Password is not strong enough: ' + feedback.warning);
     * }
     *
     * @param options - {@link B2BPasswordStrengthCheckOptions}
     *
     * @returns A {@link B2BPasswordStrengthCheckResponse} containing password strength feedback.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    strengthCheck(options: B2BPasswordStrengthCheckOptions): Promise<B2BPasswordStrengthCheckResponse>;
    /**
     * The resetByExistingPassword method wraps the {@link https://stytch.com/docs/b2b/api/existing-reset Reset By Existing Password} API endpoint.
     * If this method succeeds, the Member will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * stytch.passwords.resetByExistingPassword({
     *   email_address: 'sandbox@stytch.com',
     *   existing_password: 'aVerySecurePassword',
     *   new_password: 'aVerySecureNewPassword'
     * });
     *
     * @param options - {@link B2BPasswordResetByExistingPasswordOptions}
     *
     * @returns A {@link B2BPasswordResetByExistingPasswordResponse} indicating the password is valid and that the Member is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetByExistingPassword(options: B2BPasswordResetByExistingPasswordOptions): Promise<B2BPasswordResetByExistingPasswordResponse>;
    /**
     * The resetBySession method wraps the {@link https://stytch.com/docs/b2b/api/session-reset Reset By Session} API endpoint.
     * If this method succeeds, the Member will be logged in, granted an active session, and the
     * {@link https://stytch.com/docs/sdks/javascript-sdk/resources/cookies-and-session-management session cookies} will be minted and stored in the browser.
     * You can listen for successful login events anywhere in the codebase with the `stytch.session.onChange()` method or `useStytchSession` hook if you are using React.
     *
     * @example
     * stytch.passwords.resetBySession({
     *   password: 'aVerySecurePassword'
     * });
     *
     * @param options - {@link B2BPasswordResetBySessionOptions}
     *
     * @returns A {@link B2BPasswordResetBySessionResponse} indicating the password is valid and that the Member is now logged in.
     *
     * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
     * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
     * @throws A {@link StytchSDKUsageError} when called with invalid input (invalid email, invalid options, etc.)
     */
    resetBySession(options: B2BPasswordResetBySessionOptions): Promise<B2BPasswordResetBySessionResponse>;
}
type B2BSMSSendOptions = {
    /**
     * The ID of the organization the member belongs to
     */
    organization_id: string;
    /**
     * The ID of the member to send the OTP to
     */
    member_id: string;
    /**
     * The phone number to send the OTP to. If the member already has a phone number, this argument is not needed.
     * If the member does not have a phone number and this argument is not provided, an error will be thrown.
     */
    mfa_phone_number?: string;
    /**
     * The locale is used to determine which language to use in the email. Parameter is a {@link https://www.w3.org/International/articles/language-tags/ IETF BCP 47 language tag}, e.g. "en".
     * Currently supported languages are English ("en"), Spanish ("es"), and Brazilian Portuguese ("pt-br"); if no value is provided, the copy defaults to English.
     */
    locale?: locale;
};
type B2BSMSSendResponse = ResponseCommon;
type B2BSMSAuthenticateOptions = SessionDurationOptions & {
    /**
     * The ID of the organization the member belongs to
     */
    organization_id: string;
    /**
     * The ID of the member to authenticate
     */
    member_id: string;
    /**
     * The OTP to authenticate
     */
    code: string;
    /**
     * If set to 'enroll', enrolls the member in MFA by setting the "mfa_enrolled" boolean to true.
     * If set to 'unenroll', unenrolls the member in MFA by setting the "mfa_enrolled" boolean to false.
     * If not set, does not affect the member's MFA enrollment.
     */
    set_mfa_enrollment?: "enroll" | "unenroll";
};
type B2BSMSAuthenticateResponse = B2BAuthenticateResponse;
interface IHeadlessB2BOTPsClient {
    sms: {
        /**
         * The send method wraps the {@link https://stytch.com/docs/b2b/api/otp-sms-send SMS send} API endpoint.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/otps#otps-sms-send Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.otps.sms.send({
         *   organization_id: 'organization-test-123',
         *   member_id: 'member-id-123',
         *   phone_number: '+12025550162',
         * });
         *
         * @param data - {@link B2BSMSSendOptions}
         *
         * @returns A {@link B2BSMSSendResponse} indicating that the SMS has been sent.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        send(data: B2BSMSSendOptions): Promise<B2BSMSSendResponse>;
        /**
         * The authenticate method wraps the {@link https://stytch.com/docs/b2b/api/authenticate-otp-sms SMS authenticate} API endpoint.
         *
         * See the {@link https://stytch.com/docs/b2b/sdks/javascript-sdk/otps#otps-sms-authenticate Stytch Docs} for a complete reference.
         *
         * @example
         * stytch.otps.sms.authenticate({
         *   organization_id: 'organization-test-123',
         *   member_id: 'member-id-123',
         *   code: '1234',
         *   intermediate_session_token: 'token',
         * });
         *
         * @param data - {@link B2BSMSAuthenticateOptions}
         *
         * @returns A {@link B2BSMSAuthenticateResponse} indicating that the SMS OTP factor has been authenticated
         * and added to the member's session.
         *
         * @throws A {@link StytchSDKAPIError} when the Stytch API returns an error.
         * @throws A {@link SDKAPIUnreachableError} when the SDK cannot contact the Stytch API.
         * @throws A {@link StytchSDKUsageError} when called with invalid input.
         */
        authenticate(data: B2BSMSAuthenticateOptions): Promise<B2BSMSAuthenticateResponse>;
    };
}
type Actions<Actions extends string> = {
    [Action in Actions]: boolean;
};
type PermissionsMap<Permissions extends Record<string, string>> = {
    [ResourceID in keyof Permissions]: Actions<Permissions[ResourceID]>;
};
interface IHeadlessB2BRBACClient {
    /**
     * Determines whether the logged-in member is allowed to perform the specified action on the specified resource.
     * Returns `true` if the member can perform the action, `false` otherwise.
     *
     * This method uses a locally-cached instance of the member and the configured RBAC policy.
     * If the member is not logged in, or the RBAC policy has not been loaded, this method will always return false.
     * If the resource or action provided are not valid for the configured RBAC policy, this method will return false.
     *
     * To check authorization using guaranteed-fresh data, use {@link isAuthorized}.
     * Remember - authorization checks for sensitive actions should always occur on the backend as well.
     * @example
     * const isAuthorized = stytch.rbac.isAuthorizedSync<Permissions>('document', 'image');
     */
    isAuthorizedSync(resourceId: string, action: string): boolean;
    /**
     * Determines whether the logged-in member is allowed to perform the specified action on the specified resource.
     * Returns `true` if the member can perform the action, `false` otherwise.
     *
     * If the member is not logged in, this method will always return false.
     * If the resource or action provided are not valid for the configured RBAC policy, this method will return false.
     *
     * To check authorization using cached data, use {@link isAuthorizedSync}.
     * Remember - authorization checks for sensitive actions should always occur on the backend as well.
     * @example
     * const isAuthorized = await stytch.rbac.isAuthorizedSync<Permissions>('document', 'image');
     */
    isAuthorized(resourceId: string, action: string): Promise<boolean>;
    /**
     * Evaluates all permissions granted to the logged-in member.
     * Returns a Record<RoleId, Record<Action, boolean>> response indicating the member's permissions.
     * Each boolean will be `true` if the member can perform the action, `false` otherwise.
     *
     * If the member is not logged in, all values will be false.
     *
     * Remember - authorization checks for sensitive actions should always occur on the backend as well.
     * @example
     * type Permissions = {
     *   document: 'create' | 'read' | 'write
     *   image: 'create' | 'read'
     * }
     * const permissions = await stytch.rbac.allPermissions<Permissions>();
     * console.log(permissions.document.create) // true
     * console.log(permissions.image.create) // false
     * @returns A {@link PermissionsMap} for the active member
     */
    allPermissions<Permissions extends Record<string, string>>(): Promise<PermissionsMap<Permissions>>;
}
/**
 * The authentication methods we support through our UI.
 * Currently we support `emailMagicLinks`, `oauth`, `otp`, `crypto` and `passwords`.
 */
declare enum Products {
    emailMagicLinks = "emailMagicLinks",
    oauth = "oauth",
    otp = "otp",
    crypto = "crypto",
    passwords = "passwords",
    passkeys = "passkeys"
}
/**
 * The options for email magic links. This is required if you've enabled the `emailMagicLinks` product
 * in your configuration.
 */
type EmailMagicLinksOptions = {
    loginRedirectURL: string;
    loginExpirationMinutes?: number;
    signupRedirectURL: string;
    signupExpirationMinutes?: number;
    loginTemplateId?: string;
    signupTemplateId?: string;
    createUserAsPending?: boolean;
    /**
     * @param domainHint - An optional hint indicating what domain the email will be sent from.
     * This field is only required if your project uses more than one custom domain to send emails.
     */
    domainHint?: string;
};
/**
 * The OAuth providers we support in our OAuth product.
 * Currently we support `Amazon`, `Apple`, `Bitbucket`, `Discord`, `Facebook`, `Figma`, `Google`, `GitLab`,
 * `LinkedIn`, `Microsoft`, `Salesforce`, `Slack`, `Snapchat`, `TikTok`, `Twitch`, `Twitter`, and `Yahoo`.
 */
declare enum OAuthProviders {
    Google = "google",
    Microsoft = "microsoft",
    Apple = "apple",
    Github = "github",
    GitLab = "gitlab",
    Facebook = "facebook",
    Discord = "discord",
    Salesforce = "salesforce",
    Slack = "slack",
    Amazon = "amazon",
    Bitbucket = "bitbucket",
    LinkedIn = "linkedin",
    Coinbase = "coinbase",
    Twitch = "twitch",
    Twitter = "twitter",
    TikTok = "tiktok",
    Snapchat = "snapchat",
    Figma = "figma",
    Yahoo = "yahoo"
}
/**
 * For Google One Tap, we support two different position options:
 * `embedded` will display Google One Tap within the existing JavaScript SDK login form
 * `floating` will display the One Tap prompt in the top right corner.
 */
declare enum OneTapPositions {
    embedded = "embedded",
    floating = "floating"
}
type ProviderOptions = {
    type: OAuthProviders;
    one_tap?: boolean;
    position?: OneTapPositions;
    custom_scopes?: string[];
    provider_params?: Record<string, string>;
};
/**
 * An array of OAuth providers you wish to use. Each Provider is an object with a type key that
 * determines the type of provider. Each Provider accepts an optional custom_scopes array of
 * scopes that Stytch will request for your application in addition to the base set of scopes
 * required for login. The order of the providers in the array determines the order of the
 * rendered buttons.
 */
type ProvidersOptions = ProviderOptions[];
/**
 * The options for oAuth. This is required if you've enabled the `oauth` product
 * in your configuration.
 */
type OAuthOptions = {
    loginRedirectURL?: string;
    signupRedirectURL?: string;
    providers: ProvidersOptions;
};
/**
 * The methods array allows you to specify the authentication methods that you would like to expose
 * to your users. The order of the products that you include here will also be the order in which
 * they appear in the login form, with the first product specified appearing at the top of the login
 * form. We currently support passcodes on `email`, `sms` and `whatsapp`
 */
declare enum OTPMethods {
    SMS = "sms",
    WhatsApp = "whatsapp",
    Email = "email"
}
/**
 * The options for One Time Passcodes. This is required if you've enabled the `otp` product
 * in your configuration.
 */
type OtpOptions = {
    methods: OTPMethods[];
    expirationMinutes: number;
    loginTemplateId?: string;
    signupTemplateId?: string;
};
/**
 * The options for passwords. This is required if you've enabled the `passwords` product
 * in your configuration.
 */
type PasswordOptions = {
    loginRedirectURL: string;
    loginExpirationMinutes?: number;
    resetPasswordRedirectURL: string;
    resetPasswordExpirationMinutes?: number;
    resetPasswordTemplateId?: string;
};
/**
 * The options for Session Management. If you are using the UI components,
 * we also create a session for users when they log in.
 */
type SessionOptions = {
    sessionDurationMinutes: number;
};
/**
 * The configuration object for the Stytch SDK's UI
 */
type StytchLoginConfig = {
    /**
     * The products array allows you to specify the authentication methods that you would like to
     * expose to your users. The order of the products that you include here will also be the order
     * in which they appear in the login form,
     */
    products: Products[];
    emailMagicLinksOptions?: EmailMagicLinksOptions;
    oauthOptions?: OAuthOptions;
    otpOptions?: OtpOptions;
    sessionOptions?: SessionOptions;
    passwordOptions?: PasswordOptions;
    /**
     * The `enableShadowDOM` configuration option allows developers to use the Stytch SDK in a shadow DOM. This defaults to `false`.
     */
    enableShadowDOM?: boolean;
};
declare enum EmailSentType {
    LoginOrCreateEML = "login_or_create_eml",
    LoginOrCreateOTP = "login_or_create_otp",
    ResetPassword = "reset_password"
}
type AnalyticsEvent = {
    name: "sdk_instance_instantiated";
    details: {
        event_callback_registered: boolean;
        error_callback_registered: boolean;
        success_callback_registered: boolean;
    };
} | {
    name: "b2b_sdk_instance_instantiated";
    details: {
        event_callback_registered: boolean;
        error_callback_registered: boolean;
        success_callback_registered: boolean;
    };
} | {
    name: "render_login_screen";
    details: {
        options: StytchLoginConfig;
    };
} | {
    name: "render_b2b_login_screen";
    details: {
        options: StytchB2BUIConfig;
    };
} | {
    name: "email_sent";
    details: {
        email: string;
        type: EmailSentType;
    };
} | {
    name: "email_try_again_clicked";
    details: {
        email: string;
        type: EmailSentType;
    };
} | {
    name: "start_oauth_flow";
    details: {
        provider_type: string;
        custom_scopes?: string[];
        cname_domain: string | null;
        pkce: boolean;
        provider_params?: Record<string, string>;
    };
};
type SDKRequestMethodAndBody = {
    method: "GET" | "DELETE";
    body?: null;
} | {
    method: "POST" | "PUT";
    body?: Record<string, unknown>;
};
type SDKRequestInfo = SDKRequestMethodAndBody & {
    url: string;
    errorMessage: string;
    additionalMetadata?: Record<string, string>;
};
interface SDKTelemetry {
    event_id: string;
    app_session_id: string;
    persistent_id: string;
    client_sent_at: string;
    timezone: string;
    // Logged in user data
    // Why don't we generate this from the session_token in the auth header?
    // - We don't want to tie analytics ingest to session validation. There's no need to put
    //   that kind of pressure on API, and ingest could be moved to somewhere that doesn't
    //   have the ability to validate tokens
    // - For bulk event batches, we want to keep track of whether or not a user was logged
    //   in at each event. If we have 10 events, the user logs in at event 5, then they'll have
    //   a token when they log the batch, but we want to know that they were not logged in for the
    //   first 4 events
    // Versioning
    app: {
        identifier: string;
        version?: string;
    };
    os?: {
        identifier?: string;
        version?: string;
    };
    device?: {
        model?: string;
        screen_size?: string;
    };
    sdk: {
        identifier: string;
        version: string;
    };
}
type AdditionalTelemetryData = {
    stytch_user_id?: string;
    stytch_session_id?: string;
} | {
    stytch_member_id?: string;
    stytch_member_session_id?: string;
};
interface INetworkClient {
    createTelemetryBlob(additionalMetadata?: SDKRequestInfo["additionalMetadata"]): SDKTelemetry;
    fetchSDK: <T extends ResponseCommon>(info: SDKRequestInfo) => Promise<T>;
    retriableFetchSDK: <T extends ResponseCommon>(info: RetriableSDKRequestInfo) => Promise<T>;
    logEvent<E extends AnalyticsEvent>({ name, details, error }: {
        name: E["name"];
        details: E["details"];
        error?: {
            error_code?: string;
            error_description?: string;
            http_status_code?: string;
        };
    }): void;
    // @deprecated Use the new sessions.updateSession() method instead
    updateSessionToken: (sessionToken: string | null) => void;
}
type RetriableSDKRequestInfo = SDKRequestInfo & {
    retryCallback: (e: RetriableError, info: SDKBaseRequestInfo) => Promise<SDKBaseRequestInfo>;
};
type RetriableSDKBaseRequestInfo = SDKBaseRequestInfo & {
    retryCallback: (e: RetriableError, info: SDKBaseRequestInfo) => Promise<SDKBaseRequestInfo>;
};
declare enum RetriableErrorType {
    RequiredCatcha = "Catcha Required"
}
declare class RetriableError extends Error {
    type: RetriableErrorType;
    constructor(type: RetriableErrorType);
}
declare function retriableFetchSDK<T extends ResponseCommon>({ method, errorMessage, finalURL, basicAuthHeader, xSDKClientHeader, xSDKParentHostHeader, body, retryCallback }: RetriableSDKBaseRequestInfo): Promise<T>;
type SDKBaseRequestInfo = {
    basicAuthHeader: string;
    xSDKClientHeader: string;
    xSDKParentHostHeader?: string;
    body: SDKRequestInfo["body"];
    method: SDKRequestInfo["method"];
    errorMessage: SDKRequestInfo["errorMessage"];
    finalURL: string;
};
declare function baseFetchSDK<T extends ResponseCommon>({ method, errorMessage, finalURL, basicAuthHeader, xSDKClientHeader, xSDKParentHostHeader, body }: SDKBaseRequestInfo): Promise<T>;
declare const WILDCARD_ACTION = "*";
type RBACPolicyRole = {
    role_id: string;
    description: string;
    permissions: {
        resource_id: string;
        actions: string[];
    }[];
};
type RBACPolicyResource = {
    resource_id: string;
    description: string;
    actions: string[];
};
type RBACPolicyRaw = {
    roles: RBACPolicyRole[];
    resources: RBACPolicyResource[];
};
/**
 * RBACPolicy represents an instance of a parsed Stytch RBAC policy object
 * It contains methods for computing outcomes for various permissions questions
 */
declare class RBACPolicy {
    roles: RBACPolicyRole[];
    resources: RBACPolicyResource[];
    private rolesByID;
    constructor(roles: RBACPolicyRole[], resources: RBACPolicyResource[]);
    static fromJSON(input: RBACPolicyRaw): RBACPolicy;
    /**
     * isAuthorized returns whether or not a user with a specific set of roles can perform a desired action
     * @example
     *  const canDoIt = policy.callerIsAuthorized(roles, 'files', 'create')
     *  console.log(canDoIt) // true
     */
    callerIsAuthorized(memberRoles: string[], resourceId: string, action: string): boolean;
    /**
     * allPermissions generates a map that allows quick lookup of all the permissions available to the user
     * @example
     *   const perms = policy.allPermissions(roles)
     *   console.log(perms.files.create) // true
     *   console.log(perms.files.delete) // false
     */
    allPermissionsForCaller(memberRoles: string[]): Record<string, Record<string, boolean>>;
}
type BootstrapData = {
    displayWatermark: boolean;
    cnameDomain: string | null;
    emailDomains: string[];
    captchaSettings: {
        enabled: false;
    } | {
        enabled: true;
        siteKey: string;
    };
    pkceRequiredForEmailMagicLinks: boolean;
    pkceRequiredForPasswordResets: boolean;
    pkceRequiredForOAuth: boolean;
    pkceRequiredForSso: boolean;
    slugPattern: string | null;
    createOrganizationEnabled: boolean;
    passwordConfig: {
        ludsComplexity: number;
        ludsMinimumCount: number;
    } | null;
    runDFPProtectedAuth: boolean;
    dfpProtectedAuthMode?: DFPProtectedAuthMode;
    rbacPolicy: RBACPolicyRaw | null;
};
type EnvironmentOptions = {
    endpoints?: {
        sdkBackendURL: string;
        liveAPIURL: string;
        testAPIURL: string;
        dfpBackendURL: string;
        clientsideServicesIframeURL: string;
    };
};
type InternalStytchClientOptions = StytchClientOptions & EnvironmentOptions;
declare global {
    // The telemetry.js script will set a global function called GetTelemetryID on the window
    // object. This interface is allows us to call that function while pleasing the TypeScript
    // compiler.
    interface Window {
        GetTelemetryID: (publicToken: string, submitURL: string) => Promise<string>;
    }
}
type DFPProtectedAuthMode = "OBSERVATION" | "DECISIONING";
type DFPProtectedAuthState = {
    publicToken: string;
    dfpBackendURL: string;
    mode?: DFPProtectedAuthMode;
    enabled: boolean;
    loaded: boolean;
    executeRecaptcha: () => Promise<string | undefined>;
};
declare class DFPProtectedAuthProvider {
    private bootstrapPromise;
    private state;
    constructor(publicToken: string, dfpBackendURL: string, bootstrapPromise: Promise<BootstrapData>, executeRecaptcha?: () => Promise<string | undefined>);
    isEnabled: () => Promise<boolean>;
    getTelemetryID: () => Promise<string | undefined>;
    getDFPTelemetryIDAndCaptcha: () => Promise<{
        dfp_telemetry_id?: string | undefined;
        captcha_token?: string | undefined;
    }>;
    retryWithCaptchaAndDFP: (e: RetriableError, req: SDKBaseRequestInfo) => Promise<SDKBaseRequestInfo>;
}
declare const DisabledDFPProtectedAuthProvider: () => {
    isEnabled: () => Promise<boolean>;
    getTelemetryID: () => Promise<undefined>;
    getDFPTelemetryIDAndCaptcha: () => Promise<{
        dfp_telemetry_id: undefined;
        captcha_token: undefined;
    }>;
    retryWithCaptchaAndDFP: () => Promise<never>;
};
interface IDFPProtectedAuthProvider {
    isEnabled(): Promise<boolean>;
    getTelemetryID(): Promise<string | undefined>;
    retryWithCaptchaAndDFP(e: RetriableError, req: SDKBaseRequestInfo): Promise<SDKBaseRequestInfo>;
    getDFPTelemetryIDAndCaptcha(): Promise<{
        dfp_telemetry_id?: string;
        captcha_token?: string;
    }>;
}
/**
 * Some errors are thrown from inside an iframe, but we can't serialize them
 * to the parent in Webkit. This class handles casting them to plain objects,
 * and restoring them on the other side. ()
 * It preserves the error instance/class constructor by inspecting err.name
 * and calling `new` on the matching constructor.
 */
declare class ErrorMarshaller {
    static marshall(error: Error): Record<string, unknown>;
    static inflate<T extends new (...any: never[]) => Error>(ErrorClass: T, ErrorData: Record<string, unknown>): Error;
    static unmarshall(error: Record<string, unknown>): Error;
}
declare const DEFAULT_MAX_BATCH_SIZE = 15;
declare const DEFAULT_INTERVAL_DURATION_MS = 800;
type EventLoggerArgs = {
    maxBatchSize: number;
    intervalDurationMs: number;
    logEventURL: string;
};
declare class EventLogger {
    private maxBatchSize;
    private logEventURL;
    private batch;
    constructor(args: EventLoggerArgs);
    logEvent(telemetry: SDKTelemetry, event: Record<string, unknown>): void;
    flush(): Promise<void>;
}
interface StorageResponse {
    success: boolean;
    message?: string;
}
interface IStorageClient {
    getData: (key: string) => Promise<string | null>;
    setData: (key: string, data: string) => Promise<StorageResponse>;
    clearData: (key: string) => Promise<StorageResponse>;
}
type SubscriberFunction<T> = (value: T | null) => void;
type Subscribers<T> = Record<string, SubscriberFunction<T>>;
declare class SubscriptionDataLayer<T> {
    private _publicToken;
    private _storageClient;
    state: T | null;
    session_token: string | null;
    session_jwt: string | null;
    intermediate_session_token: string | null;
    subscriptions: Subscribers<T>;
    constructor(_publicToken: string, _storageClient: IStorageClient);
    syncToLocalStorage(): void;
    syncFromLocalStorage: () => Promise<StateWithTokensDiff<T> | null>;
}
type StateWithTokensLoggedIn<T> = {
    state: T | null;
    session_token: string;
    session_jwt: string;
    intermediate_session_token: null;
};
// Case 2: After a logout we null everything
type StateWithTokensLoggedOut = {
    state: null;
    session_token: null;
    session_jwt: null;
    intermediate_session_token: null;
};
type StateWithIntermediateSessionToken = {
    state: null;
    session_token: null;
    session_jwt: null;
    intermediate_session_token: string;
};
type StateWithTokensDiff<T> = StateWithTokensLoggedIn<T> | StateWithTokensLoggedOut | StateWithIntermediateSessionToken;
interface ISubscriptionService<T> {
    updateStateAndTokens(diff: StateWithTokensDiff<T>): void;
    updateState(state: T): void;
    updateTokens(tokens: SessionTokensUpdate): void;
    destroyState(): void;
    getTokens(): SessionTokens | null;
    getIntermediateSessionToken(): string | null;
    subscribeToState(callback: SubscriberFunction<T | null>): UnsubscribeFunction;
    getState(): T | null;
    syncFromDeviceStorage(onCompleteCallback: () => void): void;
}
interface IConsumerSubscriptionService extends ISubscriptionService<ConsumerState> {
    updateUser(user: User): void;
    getUser(): User | null;
    getSession(): Session | null;
}
interface IB2BSubscriptionService extends ISubscriptionService<B2BState> {
    updateMember(member: Member): void;
    getMember(): Member | null;
    getSession(): MemberSession | null;
}
declare class SubscriptionService<T extends ConsumerState | B2BState> implements ISubscriptionService<T> {
    private _datalayer;
    constructor(publicToken: string, storageClient: IStorageClient);
    syncFromDeviceStorage(onCompleteCallback: () => void): void;
    getState(): T | null;
    getTokens(): SessionTokens | null;
    getIntermediateSessionToken(): string | null;
    destroyState(): void;
    _updateStateAndTokensInternal(stateDiff: StateWithTokensDiff<T>): void;
    updateStateAndTokens(stateDiff: StateWithTokensDiff<T>): void;
    updateState(state: T): void;
    updateTokens(tokens: SessionTokensUpdate): void;
    subscribeToState(callback: SubscriberFunction<T>): UnsubscribeFunction;
}
declare class ConsumerSubscriptionService extends SubscriptionService<ConsumerState> implements IConsumerSubscriptionService {
    updateUser: (user: User) => void;
    getUser: () => User | null;
    getSession: () => Session | null;
}
declare class B2BSubscriptionService extends SubscriptionService<B2BState> implements IB2BSubscriptionService {
    updateMember: (member: Member) => void;
    getMember: () => Member | null;
    getSession: () => MemberSession | null;
}
declare function loadESModule<T>(url: string, moduleFromGlobalScope: () => T): Promise<T>;
declare const checkPublicToken: (publicToken: unknown) => void;
declare const checkNotSSR: (clientName: "StytchUIClient" | "StytchHeadlessClient") => void;
declare const checkB2BNotSSR: (clientName: "StytchB2BHeadlessClient") => void;
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * An ultralightweight wrapper around console.log.
 * In the future, the logger might be passed in from the customer,
 * or the level might be configurable.
 */
declare const logger: {
    debug: (...args: any[]) => boolean;
    log: (...args: any[]) => void;
    warn: (...args: any[]) => void;
    error: (...args: any[]) => void;
};
declare const isTestPublicToken: (token: string) => boolean;
type DeepEqualOpts = {
    KEYS_TO_EXCLUDE?: string[];
};
declare const createDeepEqual: ({ KEYS_TO_EXCLUDE }?: DeepEqualOpts) => (a: any, b: any) => boolean;
/**
 * Normalizes an es5 promise with a .then(onSuccess, onFailure) signature to
 * the es6 .then().catch() signature
 */
declare const normalizePromiseLike: <T>(prom: PromiseLike<T>) => Promise<T>;
declare const createEventId: () => string;
declare const createAppSessionId: () => string;
declare const createPersistentId: () => string;
declare const validate: (methodName: string) => {
    isObject: (fieldName: string, value: object) => any;
    isOptionalObject: (fieldName: string, value: object | undefined) => any;
    isString: (fieldName: string, value: string) => any;
    isOptionalString: (fieldName: string, value: string | undefined) => any;
    isStringArray: (fieldName: string, value: string[]) => any;
    isOptionalStringArray: (fieldName: string, value: string[] | undefined) => any;
    isNumber: (fieldName: string, value: number) => any;
    isOptionalNumber: (fieldName: string, value: number | undefined) => any;
    isBoolean: (fieldName: string, value: boolean) => any;
    isOptionalBoolean: (fieldName: string, value: boolean | undefined) => any;
};
declare const isPhoneMethod: (selectionMethod: string) => boolean;
declare const isEmailMethod: (selectionMethod: string) => boolean;
declare const removeResponseCommon: <T extends ResponseCommon>({ 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
request_id, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
status_code, ...rest }: T) => Omit<T, keyof ResponseCommon>;
type WithUser<T> = T & {
    __user: User & ResponseCommon;
};
declare const omitUser: <T extends {
    __user: User & ResponseCommon;
}>(resp: T) => Omit<T, "__user">;
declare class HeadlessUserClient implements IHeadlessUserClient {
    private _networkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: IConsumerSubscriptionService);
    get: () => Promise<User>;
    getSync: () => User | null;
    update: (options: UserUpdateOptions) => Promise<Omit<WithUser<UserUpdateResponse>, "__user">>;
    deleteEmail: (emailId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    deletePhoneNumber: (phoneId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    deleteTOTP: (totpId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    deleteOAuthRegistration: (oauthUserRegistrationId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    deleteWebauthnRegistration: (webAuthnId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    deleteBiometricRegistration: (biometricRegistrationId: string) => Promise<Omit<WithUser<UpdateResponse>, "__user">>;
    onChange: (callback: UserOnChangeCallback) => UnsubscribeFunction;
}
declare class HeadlessSessionClient implements IHeadlessSessionClient {
    private _networkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: IConsumerSubscriptionService);
    getSync: () => Session | null;
    onChange: (callback: SessionOnChangeCallback) => UnsubscribeFunction;
    revoke: (options?: SessionRevokeOptions) => Promise<ResponseCommon>;
    authenticate: (options?: SessionAuthenticateOptions) => Promise<Omit<WithUser<AuthenticateResponse>, "__user">>;
    getTokens(): SessionTokens | null;
    updateSession(tokens: SessionTokensUpdate): void;
}
type ProofkeyPair = {
    code_challenge: string;
    code_verifier: string;
};
interface IPKCEManager {
    startPKCETransaction(): Promise<ProofkeyPair>;
    getPKPair(): AsyncGetPKPair | SyncGetPKPair;
    clearPKPair(): Promise<void> | void;
}
type AsyncGetPKPair = Promise<ProofkeyPair | undefined>;
type SyncGetPKPair = ProofkeyPair | undefined;
interface IAsyncPKCEManager extends IPKCEManager {
    startPKCETransaction(): Promise<ProofkeyPair>;
    getPKPair(): AsyncGetPKPair;
    clearPKPair(): Promise<void>;
}
interface ISyncPKCEManager extends IPKCEManager {
    startPKCETransaction(): Promise<ProofkeyPair>;
    getPKPair(): SyncGetPKPair;
    clearPKPair(): void;
}
type DynamicConfig = Promise<{
    pkceRequiredForEmailMagicLinks: boolean;
}>;
declare class HeadlessMagicLinksClient implements IHeadlessMagicLinksClient {
    private _networkClient;
    private _subscriptionService;
    private _pkceManager;
    private _passwordResetPKCEManager;
    private _config;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IConsumerSubscriptionService, _pkceManager: IPKCEManager, _passwordResetPKCEManager: IPKCEManager, _config?: DynamicConfig, dfpProtectedAuth?: IDFPProtectedAuthProvider);
    private getCodeChallenge;
    private handlePKCEForAuthenticate;
    email: {
        loginOrCreate: (email: string, options?: MagicLinksLoginOrCreateOptions) => Promise<ResponseCommon>;
        send: (email: string, options?: MagicLinksSendOptions) => Promise<ResponseCommon>;
    };
    authenticate: (token: string, options: MagicLinksAuthenticateOptions) => Promise<Omit<WithUser<MagicLinksAuthenticateResponse>, "__user">>;
}
declare class HeadlessOTPClient implements IHeadlessOTPsClient {
    private _networkClient;
    private _subscriptionService;
    private executeRecaptcha;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IConsumerSubscriptionService, executeRecaptcha?: () => Promise<string | undefined>, dfpProtectedAuth?: IDFPProtectedAuthProvider);
    sms: {
        loginOrCreate: (phone_number: string, options: OTPCodeOptions) => Promise<OTPsLoginOrCreateResponse>;
        send: (phone_number: string, options: OTPCodeOptions) => Promise<OTPsSendResponse>;
    };
    whatsapp: {
        loginOrCreate: (phone_number: string, options: OTPCodeOptions) => Promise<OTPsLoginOrCreateResponse>;
        send: (phone_number: string, options: OTPCodeOptions) => Promise<OTPsSendResponse>;
    };
    email: {
        loginOrCreate: (email: string, options: OTPCodeEmailOptions) => Promise<OTPsLoginOrCreateResponse>;
        send: (email: string, options: OTPCodeEmailOptions) => Promise<OTPsSendResponse>;
    };
    authenticate: (code: string, method_id: string, options: OTPAuthenticateOptions) => Promise<Omit<WithUser<OTPsAuthenticateResponse>, "__user">>;
}
type DynamicConfig$0 = Promise<{
    cnameDomain: null | string;
    pkceRequiredForOAuth: boolean;
}>;
type Config = {
    publicToken: string;
    testAPIURL: string;
    liveAPIURL: string;
};
declare class HeadlessOAuthClient implements IHeadlessOAuthClient {
    private _networkClient;
    private _subscriptionService;
    private _pkceManager;
    private _dynamicConfig;
    private _config;
    constructor(_networkClient: INetworkClient, _subscriptionService: IConsumerSubscriptionService, _pkceManager: IPKCEManager, _dynamicConfig: DynamicConfig$0, _config: Config);
    google: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    apple: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    microsoft: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    github: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    gitlab: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    facebook: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    discord: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    salesforce: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    slack: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    amazon: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    bitbucket: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    linkedin: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    coinbase: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    twitch: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    twitter: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    tiktok: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    snapchat: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    figma: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    yahoo: {
        start: ({ login_redirect_url, signup_redirect_url, custom_scopes, provider_params }?: OAuthGetURLOptions) => Promise<void>;
    };
    authenticate(token: string, options: OAuthAuthenticateOptions): Promise<Omit<WithUser<OAuthAuthenticateResponse>, "__user">>;
    private getBaseApiUrl;
    private startOAuthFlow;
}
declare class HeadlessCryptoWalletClient implements IHeadlessCryptoWalletClient {
    private _networkClient;
    private _subscriptionService;
    private executeRecaptcha;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IConsumerSubscriptionService, executeRecaptcha?: () => Promise<string | undefined>, dfpProtectedAuth?: IDFPProtectedAuthProvider);
    authenticateStart(options: CryptoWalletAuthenticateStartOptions): Promise<CryptoWalletAuthenticateStartResponse>;
    authenticate(options: CryptoWalletAuthenticateOptions): Promise<CryptoWalletAuthenticateResponse>;
}
declare class HeadlessTOTPClient implements IHeadlessTOTPClient {
    private _networkClient;
    private _subscriptionService;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IConsumerSubscriptionService, dfpProtectedAuth: IDFPProtectedAuthProvider);
    create(options: TOTPCreateOptions): Promise<TOTPCreateResponse>;
    authenticate(options: TOTPAuthenticateOptions): Promise<TOTPAuthenticateResponse>;
    recoveryCodes(): Promise<TOTPRecoveryCodesResponse>;
    recover(options: TOTPRecoverOptions): Promise<Omit<WithUser<TOTPRecoverResponse>, "__user">>;
}
declare class HeadlessWebAuthnClient implements IHeadlessWebAuthnClient {
    _networkClient: INetworkClient;
    private _subscriptionService;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IConsumerSubscriptionService, dfpProtectedAuth: IDFPProtectedAuthProvider);
    register(options?: WebAuthnRegisterStartOptions): Promise<WebAuthnRegisterResponse>;
    authenticate(options: WebAuthnAuthenticateStartOptions): Promise<WebAuthnAuthenticateResponse | null>;
    update(options: WebAuthnUpdateOptions): Promise<WebAuthnUpdateResponse>;
    browserSupportsAutofill(): Promise<boolean>;
    private checkEligibleInputs;
}
type DynamicConfig$1 = Promise<{
    pkceRequiredForPasswordResets: boolean;
}>;
declare class HeadlessPasswordClient implements IHeadlessPasswordClient {
    private _networkClient;
    private _subscriptionService;
    private _pkceManager;
    private _config;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IConsumerSubscriptionService, _pkceManager: IPKCEManager, _config?: DynamicConfig$1, dfpProtectedAuth?: IDFPProtectedAuthProvider);
    private getCodeChallenge;
    create(options: PasswordCreateOptions): Promise<PasswordCreateResponse>;
    authenticate(options: PasswordAuthenticateOptions): Promise<PasswordAuthenticateResponse>;
    resetByEmailStart(options: PasswordResetByEmailStartOptions): Promise<PasswordResetByEmailStartResponse>;
    resetByEmail(options: PasswordResetByEmailOptions): Promise<PasswordResetByEmailResponse>;
    resetByExistingPassword(options: PasswordResetByExistingPasswordOptions): Promise<PasswordResetByExistingPasswordResponse>;
    resetBySession(options: PasswordResetBySessionOptions): Promise<PasswordResetBySessionResponse>;
    strengthCheck(options: PasswordStrengthCheckOptions): Promise<PasswordStrengthCheckResponse>;
}
type DynamicConfig$2 = Promise<{
    pkceRequiredForEmailMagicLinks: boolean;
}>;
declare class HeadlessB2BMagicLinksClient implements IHeadlessB2BMagicLinksClient {
    private _networkClient;
    private _subscriptionService;
    private _pkceManager;
    private _passwordResetPKCEManager;
    private _config;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IB2BSubscriptionService, _pkceManager: IPKCEManager, _passwordResetPKCEManager: IPKCEManager, _config?: DynamicConfig$2, dfpProtectedAuth?: IDFPProtectedAuthProvider);
    private getCodeChallenge;
    private handlePKCEForAuthenticate;
    email: {
        invite: (data: B2BMagicLinksInviteOptions) => Promise<B2BMagicLinksInviteResponse>;
        loginOrSignup: (data: B2BMagicLinkLoginOrSignupOptions) => Promise<ResponseCommon>;
        discovery: {
            send: (data: B2BMagicLinksEmailDiscoverySendOptions) => Promise<B2BMagicLinksEmailDiscoverySendResponse>;
        };
    };
    authenticate: (data: B2BMagicLinksAuthenticateOptions) => Promise<B2BMagicLinksAuthenticateResponse>;
    discovery: {
        authenticate: (data: B2BMagicLinksDiscoveryAuthenticateOptions) => Promise<B2BMagicLinksDiscoveryAuthenticateResponse>;
    };
}
declare class HeadlessB2BSelfClient implements IHeadlessB2BSelfClient {
    private _networkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: IB2BSubscriptionService);
    get: () => Promise<Member | null>;
    getSync: () => Member | null;
    onChange: (callback: B2BMemberOnChangeCallback) => UnsubscribeFunction;
    update: (data: B2BMemberUpdateOptions) => Promise<B2BMemberUpdateResponse>;
    deleteMFAPhoneNumber: () => Promise<B2BMemberDeleteMFAPhoneNumberResponse>;
    deletePassword: (passwordId: string) => Promise<B2BMemberDeletePasswordResponse>;
}
type DynamicConfig$3 = Promise<{
    pkceRequiredForSso: boolean;
}>;
type Config$0 = {
    publicToken: string;
    testAPIURL: string;
    liveAPIURL: string;
};
declare class HeadlessB2BSSOClient implements IHeadlessB2BSSOClient {
    protected _networkClient: INetworkClient;
    protected _subscriptionService: IB2BSubscriptionService;
    protected _pkceManager: IPKCEManager;
    protected _dynamicConfig: DynamicConfig$3;
    protected _config: Config$0;
    protected dfpProtectedAuth: IDFPProtectedAuthProvider;
    constructor(_networkClient: INetworkClient, _subscriptionService: IB2BSubscriptionService, _pkceManager: IPKCEManager, _dynamicConfig: DynamicConfig$3, _config: Config$0, dfpProtectedAuth?: IDFPProtectedAuthProvider);
    authenticate(options: SSOAuthenticateOptions): Promise<B2BAuthenticateResponseWithMFA>;
    protected getBaseApiUrl(): Promise<string>;
    start({ connection_id, login_redirect_url, signup_redirect_url }: SSOStartOptions): Promise<void>;
    getConnections(): Promise<B2BSSOGetConnectionsResponse>;
    deleteConnection(connectionId: string): Promise<B2BSSODeleteConnectionResponse>;
    saml: {
        createConnection: (data: B2BSSOSAMLCreateConnectionOptions) => Promise<B2BSSOSAMLCreateConnectionResponse>;
        updateConnection: (data: B2BSSOSAMLUpdateConnectionOptions) => Promise<B2BSSOSAMLUpdateConnectionResponse>;
        updateConnectionByURL: (data: B2BSSOSAMLUpdateConnectionByURLOptions) => Promise<B2BSSOSAMLUpdateConnectionByURLResponse>;
        deleteVerificationCertificate: (data: B2BSSOSAMLDeleteVerificationCertificateOptions) => Promise<B2BSSOSAMLDeleteVerificationCertificateResponse>;
    };
    oidc: {
        createConnection: (data: B2BSSOOIDCCreateConnectionOptions) => Promise<B2BSSOOIDCCreateConnectionResponse>;
        updateConnection: (data: B2BSSOOIDCUpdateConnectionOptions) => Promise<B2BSSOOIDCUpdateConnectionResponse>;
    };
}
declare class HeadlessB2BOrganizationClient implements IHeadlessB2BOrganizationClient {
    private _networkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: IB2BSubscriptionService);
    get: () => Promise<Organization | null>;
    update: (data: B2BOrganizationsUpdateOptions) => Promise<B2BOrganizationsUpdateResponse>;
    delete: () => Promise<B2BOrganizationsDeleteResponse>;
    members: {
        create: (data: B2BOrganizationsMembersCreateOptions) => Promise<B2BOrganizationsMembersCreateResponse>;
        search: (data: B2BOrganizationsMembersSearchOptions) => Promise<B2BOrganizationsMembersSearchResponse>;
        update: (data: B2BOrganizationsMembersUpdateOptions) => Promise<B2BOrganizationsMembersUpdateResponse>;
        deletePassword: (passwordId: string) => Promise<B2BOrganizationsMemberDeletePasswordResponse>;
        deleteMFAPhoneNumber: (memberId: string) => Promise<B2BOrganizationsMemberDeleteMFAPhoneNumberResponse>;
        delete: (memberId: string) => Promise<B2BOrganizationsMembersDeleteResponse>;
        reactivate: (memberId: string) => Promise<B2BOrganizationsMembersReactivateResponse>;
    };
}
type DynamicConfig$4 = Promise<{
    cnameDomain: null | string;
    pkceRequiredForOAuth: boolean;
}>;
type Config$1 = {
    publicToken: string;
    testAPIURL: string;
    liveAPIURL: string;
};
declare class HeadlessB2BOAuthClient implements IHeadlessB2BOAuthClient {
    private _networkClient;
    private _subscriptionService;
    private _pkceManager;
    private _dynamicConfig;
    private _config;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IB2BSubscriptionService, _pkceManager: IPKCEManager, _dynamicConfig: DynamicConfig$4, _config: Config$1, dfpProtectedAuth?: IDFPProtectedAuthProvider);
    authenticate(options: B2BOAuthAuthenticateOptions): Promise<B2BOAuthAuthenticateResponse>;
    private getBaseApiUrl;
    private startOAuthFlow;
    private startDiscoveryOAuthFlow;
    discovery: {
        authenticate: (data: OAuthDiscoveryAuthenticateOptions) => Promise<B2BOAuthDiscoveryAuthenticateResponse>;
    };
    google: {
        start: ({ organization_id, organization_slug, login_redirect_url, signup_redirect_url, custom_scopes, provider_params }: OAuthStartOptions) => Promise<void>;
        discovery: {
            start: ({ discovery_redirect_url, custom_scopes, provider_params }: B2BOAuthDiscoveryStartOptions) => Promise<void>;
        };
    };
    microsoft: {
        start: ({ organization_id, organization_slug, login_redirect_url, signup_redirect_url, custom_scopes, provider_params }: OAuthStartOptions) => Promise<void>;
        discovery: {
            start: ({ discovery_redirect_url, custom_scopes, provider_params }: B2BOAuthDiscoveryStartOptions) => Promise<void>;
        };
    };
}
declare class HeadlessB2BSessionClient implements IHeadlessB2BSessionClient {
    private _networkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: IB2BSubscriptionService);
    getSync: () => MemberSession | null;
    onChange: (callback: B2BSessionOnChangeCallback) => UnsubscribeFunction;
    revoke: (options?: B2BSessionRevokeOptions) => Promise<ResponseCommon>;
    authenticate: (options?: SessionAuthenticateOptions) => Promise<B2BAuthenticateResponse>;
    getTokens(): SessionTokens | null;
    exchange: (data: B2BSessionExchangeOptions) => Promise<B2BAuthenticateResponseWithMFA>;
}
declare class HeadlessB2BDiscoveryClient implements IHeadlessB2BDiscoveryClient {
    private _networkClient;
    private _subscriptionService;
    constructor(_networkClient: INetworkClient, _subscriptionService: IB2BSubscriptionService);
    organizations: {
        list: () => Promise<B2BDiscoveryOrganizationsResponse>;
        create: (data: B2BDiscoveryOrganizationsCreateOptions) => Promise<B2BDiscoveryOrganizationsCreateResponse>;
    };
    intermediateSessions: {
        exchange: (data: B2BDiscoveryIntermediateSessionsExchangeOptions) => Promise<B2BDiscoveryIntermediateSessionsExchangeResponse>;
    };
}
type DynamicConfig$5 = Promise<{
    pkceRequiredForPasswordResets: boolean;
}>;
declare class HeadlessB2BPasswordsClient implements IHeadlessB2BPasswordClient {
    private _networkClient;
    private _subscriptionService;
    private _pkceManager;
    private _config;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IB2BSubscriptionService, _pkceManager: IPKCEManager, _config?: DynamicConfig$5, dfpProtectedAuth?: IDFPProtectedAuthProvider);
    private getCodeChallenge;
    authenticate(options: B2BPasswordAuthenticateOptions): Promise<B2BPasswordAuthenticateResponse>;
    resetByEmailStart(options: B2BPasswordResetByEmailStartOptions): Promise<B2BPasswordResetByEmailStartResponse>;
    resetByEmail(options: B2BPasswordResetByEmailOptions): Promise<B2BPasswordResetByEmailResponse>;
    resetByExistingPassword(options: B2BPasswordResetByExistingPasswordOptions): Promise<B2BPasswordResetByExistingPasswordResponse>;
    resetBySession(options: B2BPasswordResetBySessionOptions): Promise<B2BPasswordResetBySessionResponse>;
    strengthCheck(options: B2BPasswordStrengthCheckOptions): Promise<B2BPasswordStrengthCheckResponse>;
}
declare class HeadlessB2BOTPsClient implements IHeadlessB2BOTPsClient {
    private _networkClient;
    private _subscriptionService;
    private dfpProtectedAuth;
    constructor(_networkClient: INetworkClient, _subscriptionService: IB2BSubscriptionService, dfpProtectedAuth?: IDFPProtectedAuthProvider);
    sms: {
        send: (data: B2BSMSSendOptions) => Promise<B2BSMSSendResponse>;
        authenticate: (data: B2BSMSAuthenticateOptions) => Promise<B2BSMSAuthenticateResponse>;
    };
}
type CachedConfig = {
    rbacPolicy: RBACPolicyRaw | null;
};
type DynamicConfig$6 = Promise<CachedConfig>;
declare class HeadlessB2BRBACClient implements IHeadlessB2BRBACClient {
    private _subscriptionService;
    private cachedPolicy;
    private policyPromise;
    constructor(cachedConfig: CachedConfig, dynamicConfig: DynamicConfig$6, _subscriptionService: IB2BSubscriptionService);
    allPermissions<Permissions extends Record<string, string>>(): Promise<PermissionsMap<Permissions>>;
    isAuthorizedSync: IHeadlessB2BRBACClient["isAuthorizedSync"];
    isAuthorized: IHeadlessB2BRBACClient["isAuthorized"];
    private roleIds;
}
declare class IframeHostClient {
    private iframeURL;
    frame: Promise<HTMLIFrameElement>;
    constructor(iframeURL: string);
    private createIframe;
    call<T>(method: string, args: unknown[]): Promise<T>;
}
declare class IframeEmbeddedClient {
    handlers: Record<string, (...args: unknown[]) => Promise<unknown>>;
    constructor();
    runHandler(event: MessageEvent): Promise<void>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    registerHandler(handler: string, handlerImpl: (...args: any[]) => Promise<unknown>): void;
}
/**
 * All RPC Methods we currently support.
 * Remember - once you add an RPC method, it must be backwards compatible --- FOREVER!
 * Making breaking changes can break old versions of vanilla-js, so proceed with caution.
 *
 * I'll repeat it again - YOU CANNOT MAKE BACKWARDS INCOMPATIBLE CHANGES TO THIS FILE.
 *
 * Rules of thumb:
 * - RPC methods should take in Object { } options and return Objects {} - this makes it far easier to add more params later
 * - Prefer one big single param over n-ary arguments.
 * - Make everything async. You'll never know if you'll add an async function call in the future.
 * - If you need to break a method, call it method2 and move on.
 */
interface RPCManifest {
    oneTapStart: (req: OneTapStartRequest) => Promise<OneTapStartResponse>;
    oneTapSubmit: (req: OneTapSubmitRequest) => Promise<OneTapSubmitResponse>;
    parsedPhoneNumber: (req: ParsedPhoneNumberRequest) => Promise<ParsedPhoneNumberResponse>;
}
type ParsedPhoneNumberRequest = {
    phoneNumber: string;
    regionCode?: string;
};
type ParsedPhoneNumberResponse = {
    isValid: boolean;
    number: string;
    national: string;
};
type OneTapStartRequest = {
    publicToken: string;
};
type OneTapStartResponse = {
    requestId: string;
    googleClientId: string;
    stytchCsrfToken: string;
    oauthCallbackId: string;
};
type OneTapSubmitRequest = {
    publicToken: string;
    idToken: string;
    oauthCallbackID: string;
    loginRedirectURL?: string;
    signupRedirectURL?: string;
};
type OneTapSubmitResponse = {
    redirect_url: string;
};
interface ISessionManager {
    performBackgroundRefresh: () => void;
    cancelBackgroundRefresh: () => void;
}
declare class SessionManager implements ISessionManager {
    private _subscriptionService;
    private _headlessSessionClient;
    // Three minutes
    private static REFRESH_INTERVAL_MS;
    // When testing - it's often more useful to set to a shorter duration
    // private static REFRESH_INTERVAL_MS = 1000 * 3;
    private timeout;
    constructor(_subscriptionService: IConsumerSubscriptionService | IB2BSubscriptionService, _headlessSessionClient: IHeadlessSessionClient | IHeadlessB2BSessionClient);
    /**
     * The core logic of the session refresh recursive trampoline
     * - Refreshes the currently issued session
     * - Schedules a future refresh if successful
     */
    performBackgroundRefresh(): void;
    private scheduleBackgroundRefresh;
    cancelBackgroundRefresh(): void;
    /**
     * We need to listen to a few types of events:
     * - If the user logs in via invoking a .authenticate() call, we should start the background worker
     * - If the user steps up their authentication via another .authenticate call(), we should restart the background worker
     * - If the user logs out, we should terminate the worker
     * - We should ignore session changes that we ourselves caused - so if we already have a timeout, leave it be!
     */
    private _onDataChange;
    // In cases where we cannot get a satisfactory request:
    // - Stytch is hard-down
    // - The user's network is disconnected for an extended period of time
    // we will continue to retry every 4 minutes ad infinum
    private _reauthenticateWithBackoff;
    // We start with a backoff of 2000ms and increase exponentially to ~4 minutes (+/- 175 ms for jitter)
    // A short backoff initially helps increase the chance that we refresh the session before the JWT expires
    static timeoutForAttempt(count: number): number;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isUnrecoverableError(error: any): boolean;
}
export { TEST_API_URL, LIVE_API_URL, CLIENTSIDE_SERVICES_IFRAME_URL, STYTCH_WEB_BACKEND_URL, STYTCH_DFP_BACKEND_URL, STYTCH_DFP_CDN_URL, STYTCH_SESSION_COOKIE, STYTCH_SESSION_JWT_COOKIE, POWERED_BY_STYTCH_IMG_URL, GOOGLE_ONE_TAP_HOST, GOOGLE_ONE_TAP_SCRIPT_URL, STYTCH_CSRF_TOKEN_NAME, DEFAULT_SESSION_DURATION_MINUTES, DEFAULT_OTP_EXPIRATION_MINUTES, DFPProtectedAuthMode, DFPProtectedAuthState, DFPProtectedAuthProvider, DisabledDFPProtectedAuthProvider, IDFPProtectedAuthProvider, ErrorMarshaller, DEFAULT_MAX_BATCH_SIZE, DEFAULT_INTERVAL_DURATION_MS, EventLogger, EmailSentType, AnalyticsEvent, HeadlessUserClient, HeadlessSessionClient, HeadlessMagicLinksClient, HeadlessOTPClient, HeadlessOAuthClient, HeadlessCryptoWalletClient, HeadlessTOTPClient, HeadlessWebAuthnClient, HeadlessPasswordClient, HeadlessB2BMagicLinksClient, HeadlessB2BSelfClient, HeadlessB2BSSOClient, HeadlessB2BOrganizationClient, HeadlessB2BOAuthClient, HeadlessB2BSessionClient, HeadlessB2BDiscoveryClient, HeadlessB2BPasswordsClient, HeadlessB2BOTPsClient, HeadlessB2BRBACClient, SDKRequestInfo, SDKTelemetry, AdditionalTelemetryData, INetworkClient, RetriableSDKRequestInfo, RetriableSDKBaseRequestInfo, RetriableErrorType, RetriableError, retriableFetchSDK, SDKBaseRequestInfo, baseFetchSDK, ProofkeyPair, IPKCEManager, IAsyncPKCEManager, ISyncPKCEManager, IframeHostClient, IframeEmbeddedClient, RPCManifest, ParsedPhoneNumberRequest, ParsedPhoneNumberResponse, OneTapStartRequest, OneTapStartResponse, OneTapSubmitRequest, OneTapSubmitResponse, ISessionManager, SessionManager, StorageResponse, IStorageClient, SubscriptionDataLayer, ISubscriptionService, IConsumerSubscriptionService, IB2BSubscriptionService, SubscriptionService, ConsumerSubscriptionService, B2BSubscriptionService, BootstrapData, EnvironmentOptions, InternalStytchClientOptions, loadESModule, checkPublicToken, checkNotSSR, checkB2BNotSSR, logger, isTestPublicToken, createDeepEqual, normalizePromiseLike, createEventId, createAppSessionId, createPersistentId, validate, isPhoneMethod, isEmailMethod, removeResponseCommon, WithUser, omitUser, WILDCARD_ACTION, RBACPolicyRole, RBACPolicyResource, RBACPolicyRaw, RBACPolicy };
