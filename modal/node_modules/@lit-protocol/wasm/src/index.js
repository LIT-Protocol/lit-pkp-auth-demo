"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blsCombine = blsCombine;
exports.blsDecrypt = blsDecrypt;
exports.blsEncrypt = blsEncrypt;
exports.blsVerify = blsVerify;
exports.ecdsaCombine = ecdsaCombine;
exports.ecdsaDeriveKey = ecdsaDeriveKey;
exports.ecdsaVerify = ecdsaVerify;
exports.ecdsaCombnieAndVerify = ecdsaCombnieAndVerify;
exports.sevSnpGetVcekUrl = sevSnpGetVcekUrl;
exports.sevSnpVerify = sevSnpVerify;
const tslib_1 = require("tslib");
//@ts-ignore source map not found
const wasm_internal_1 = require("./pkg/wasm-internal");
const wasmInternal = tslib_1.__importStar(require("./pkg/wasm-internal"));
let loadingPromise = null;
let wasmSdkInstance;
// Give us a promise that _just_ encapsulates initializing the modules so we can wrap it in other logic
async function initWasm() {
    return (0, wasm_internal_1.initSync)((0, wasm_internal_1.getModule)());
}
/**
 * Initializes the wasm module and keeps the module in scope within
 * the module context. Does not expose the module context as it is
 * not intended to be used directly.
 * @returns {Promise<void>}
 */
async function loadModules() {
    if (wasmSdkInstance) {
        // Runtime is 'hot'; already have loaded WASM modules
        return wasmSdkInstance;
    }
    if (loadingPromise) {
        // Runtime is currently loading the WASM modules; chain on the result of that load attempt
        return loadingPromise;
    }
    // If we got here, we need to load the wasmSdkInstance -- but we want to avoid any other concurrent
    // requests loading it in parallel, so we stash this promise for those to check for
    loadingPromise = initWasm();
    try {
        wasmSdkInstance = await loadingPromise;
    }
    finally {
        loadingPromise = null;
    }
    // If we got here, the SDK loaded successfully
    return;
}
/**
 * Combines bls signature shares to decrypt
 *
 * Supports:
 * - 12381G2
 * - 12381G1
 * @param {BlsVariant} variant
 * @param {(Uint8Array)[]} signature_shares
 * @returns {Uint8Array}
 */
async function blsCombine(variant, signature_shares) {
    await loadModules();
    return wasmInternal.blsCombine(variant, signature_shares);
}
/**
 * Uses a combined BLS signature to decrypt with the
 * given ciphertext from {@link blsEncrypt}
 *
 * Supports:
 * - 12381G2
 * - 12381G1
 * @param {BlsVariant} variant
 * @param {Uint8Array} ciphertext
 * @param {Uint8Array} decryption_key
 * @returns {Uint8Array}
 */
async function blsDecrypt(variant, ciphertext, decryption_key) {
    await loadModules();
    return wasmInternal.blsDecrypt(variant, ciphertext, decryption_key);
}
/**
 * Used for BLS encryption
 *
 * Supports:
 * - 12381G2
 * - 12381G1
 * @param {BlsVariant} variant
 * @param {Uint8Array} encryption_key
 * @param {Uint8Array} message
 * @param {Uint8Array} identity
 * @returns {Uint8Array}
 */
async function blsEncrypt(variant, encryption_key, message, identity) {
    await loadModules();
    return wasmInternal.blsEncrypt(variant, encryption_key, message, identity);
}
/**
 * Verifies a BLS signature
 *
 * Supports:
 * - 12381G2
 * - 12381G1
 * @param {BlsVariant} variant
 * @param {Uint8Array} public_key
 * @param {Uint8Array} message
 * @param {Uint8Array} signature
 */
async function blsVerify(variant, public_key, message, signature) {
    await loadModules();
    return wasmInternal.blsVerify(variant, public_key, message, signature);
}
/**
 * Combine ECDSA signatures shares
 *
 * Supports:
 *  - K256
 *  - P256
 * @param {EcdsaVariant} variant
 * @param {Uint8Array} presignature
 * @param {(Uint8Array)[]} signature_shares
 * @returns {[Uint8Array, Uint8Array, number]}
 */
async function ecdsaCombine(variant, presignature, signature_shares) {
    await loadModules();
    return wasmInternal.ecdsaCombine(variant, presignature, signature_shares);
}
/**
 * HD key derivation
 *
 * Supports:
 * - k256
 * - p256
 * @param {EcdsaVariant} variant ecdsa scheme
 * @param {Uint8Array} id keyid which will be used for the key derivation
 * @param {(Uint8Array)[]} public_keys ecdsa root keys
 * @returns {Uint8Array}
 */
async function ecdsaDeriveKey(variant, id, public_keys) {
    await loadModules();
    return wasmInternal.ecdsaDeriveKey(variant, id, public_keys);
}
/**
 * Verifier for ECDSA signatures
 *
 * Supports:
 * - k256
 * - p256
 ** Note ** Not currently supported through the lit network. Please use other ECSDSA signature verification
 * @param {EcdsaVariant} variant
 * @param {Uint8Array} message_hash
 * @param {Uint8Array} public_key
 * @param {[Uint8Array, Uint8Array, number]} signature
 */
async function ecdsaVerify(variant, message_hash, public_key, signature) {
    await loadModules();
    return wasmInternal.ecdsaVerify(variant, message_hash, public_key, signature);
}
/**
 * Combiner and verifier for ECDSA signatures
 *
 * Supports:
 * - k256
 * - p256
 *  ** Note ** Not currently supported through the lit network. Please use other ECSDSA signature verification
 * @param {EcdsaVariant} variant
 * @param {Uint8Array} pre_signature
 * @param {Uint8Array[]} signature_shares
 * @param {Uint8Array} message_hash
 * @param {Uint8Array} public_key
 * @param {[Uint8Array, Uint8Array, number]} signature
 */
async function ecdsaCombnieAndVerify(variant, pre_signature, signature_shares, message_hash, public_key) {
    await loadModules();
    return wasmInternal.ecdsaCombineAndVerify(variant, pre_signature, signature_shares, message_hash, public_key);
}
/**
 * Gets the vcek url for the given attestation report.  You can fetch this certificate yourself, and pass it in to verify_attestation_report
 * @param {Uint8Array} attestation_report
 * @returns {string}
 */
async function sevSnpGetVcekUrl(attestation_report) {
    await loadModules();
    return wasmInternal.sevSnpGetVcekUrl(attestation_report);
}
/**
 * Checks attestation from a node with AMD certs
 * @param {Uint8Array} attestation_report
 * @param {Record<string, Uint8Array>} attestation_data
 * @param {(Uint8Array)[]} signatures
 * @param {Uint8Array} challenge
 * @param {Uint8Array} vcek_certificate
 * @returns {Promise<void>}
 */
async function sevSnpVerify(attestation_report, attestation_data, signatures, challenge, vcek_certificate) {
    await loadModules();
    return wasmInternal.sevSnpVerify(attestation_report, attestation_data, signatures, challenge, vcek_certificate);
}
//# sourceMappingURL=index.js.map