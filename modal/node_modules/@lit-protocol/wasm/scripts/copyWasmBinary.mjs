"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const pako = tslib_1.__importStar(require("pako"));
const WASM_MODULE_PATH = 'rust/pkg/wasm-internal_bg.wasm';
const WASM_BINDING_PATH = 'rust/pkg/wasm-internal.js';
const CHUNK_SIZE = 100;
const COMMENT_OUT_LINES = [
    // This regex matches the block that checks if `module_or_path` is undefined and assigns a URL to it.
    /if\s*\(\s*typeof\s+module_or_path\s*===\s*['"`]undefined['"`]\s*\)\s*{\s*module_or_path\s*=\s*new\s+URL\s*\(\s*['"`]wasm-internal_bg\.wasm['"`],\s*import\.meta\.url\s*\);\s*}/g,
    // This regex matches the block that checks if `module_or_path` is a string, `Request`, or `URL` and assigns it to the result of a `fetch`.
    /if\s*\(\s*typeof\s+module_or_path\s*===\s*['"`]string['"`]\s*\|\|\s*\(typeof\s+Request\s*===\s*['"`]function['"`]\s*&&\s*module_or_path\s*instanceof\s+Request\)\s*\|\|\s*\(typeof\s+URL\s*===\s*['"`]function['"`]\s*&&\s*module_or_path\s*instanceof\s+URL\)\s*\)\s*{\s*module_or_path\s*=\s*fetch\s*\(module_or_path\);\s*}/g,
];
function main() {
    const wasmModule = fs_1.default.readFileSync(WASM_MODULE_PATH);
    const wasmBindingModule = fs_1.default.readFileSync(WASM_BINDING_PATH);
    let wasmModuleBuffer = Buffer.from(wasmModule);
    wasmModuleBuffer = pako.deflate(new Uint8Array(wasmModuleBuffer));
    const wasmModuleB64 = Buffer.from(wasmModuleBuffer).toString('base64');
    let buffer = `let moduleBuffer = "";`;
    for (let i = 0; i < wasmModuleB64.length; i += CHUNK_SIZE) {
        const chunk = wasmModuleB64.slice(i, i + CHUNK_SIZE);
        buffer += `\nmoduleBuffer += "${chunk}";`;
    }
    let bindingModuleString = `
// @ts-nocheck - autogenerated from copyWasmBinary.mjs
import * as pako from 'pako';
  `;
    bindingModuleString += '\n';
    bindingModuleString += buffer;
    bindingModuleString += '\n';
    bindingModuleString += `
export function getModule() {
  let module = pako.inflate(new Uint8Array(Buffer.from(moduleBuffer, 'base64')));
  return Uint8Array.from(module);
}
`;
    bindingModuleString += wasmBindingModule;
    let allReplacementsDone = true; // Track whether all replacements were successful
    for (const commentOutItem of COMMENT_OUT_LINES) {
        const originalString = bindingModuleString; // Store the original string before replacement
        bindingModuleString = bindingModuleString.replace(commentOutItem, (match) => {
            const headerComment = '// NOTE: This line is commented out automatically by copyWasmBinary.mjs\n';
            const commentedBlock = match
                .split('\n') // Split the matched block into lines
                .map((line) => `// ${line}`) // Add "//" to each line
                .join('\n'); // Re-join the lines into a single string
            return `${headerComment}${commentedBlock}`; // Prepend the header comment to the commented block
        });
        // If no replacement was done (i.e., original string remains the same), mark as failure
        if (originalString === bindingModuleString) {
            allReplacementsDone = false;
        }
    }
    // throw an error if all replacements were NOT successful
    if (!allReplacementsDone) {
        throw new Error('❗️❗️ Failed to comment out all specified lines in the wasm binding module.');
    }
    else {
        console.log('✅ All replacements were successful!');
    }
    console.log('Writing wasm module');
    fs_1.default.writeFileSync(WASM_BINDING_PATH, bindingModuleString);
}
main();
//# sourceMappingURL=copyWasmBinary.mjs.map