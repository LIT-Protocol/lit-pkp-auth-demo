import { HTTP, HTTPS, LIT_CURVE_VALUES } from '@lit-protocol/constants';
import { AuthSig, CustomNetwork, FormattedMultipleAccs, HandshakeWithNode, JsonHandshakeResponse, LitNodeClientConfig, MultipleAccessControlConditions, NodeCommandServerKeysResponse, RejectedNodePromises, SendNodeCommand, SessionSigsMap, SuccessNodePromises, SupportedJsonRequests } from '@lit-protocol/types';
export type LitNodeClientConfigWithDefaults = Required<Pick<LitNodeClientConfig, 'alertWhenUnauthorized' | 'debug' | 'connectTimeout' | 'checkNodeAttestation' | 'litNetwork' | 'minNodeCount'>> & Partial<Pick<LitNodeClientConfig, 'storageProvider' | 'contractContext' | 'rpcUrl'>> & {
    bootstrapUrls: string[];
} & {
    nodeProtocol?: typeof HTTP | typeof HTTPS | null;
};
export declare class LitCore {
    config: LitNodeClientConfigWithDefaults;
    connectedNodes: Set<string>;
    serverKeys: Record<string, JsonHandshakeResponse>;
    ready: boolean;
    subnetPubKey: string | null;
    networkPubKey: string | null;
    networkPubKeySet: string | null;
    hdRootPubkeys: string[] | null;
    latestBlockhash: string | null;
    lastBlockHashRetrieved: number | null;
    private _networkSyncInterval;
    private _stakingContract;
    private _stakingContractListener;
    private _connectingPromise;
    private _epochCache;
    private _blockHashUrl;
    constructor(config: LitNodeClientConfig | CustomNetwork);
    getLogsForRequestId: (id: string) => string[];
    getRequestIds: () => Set<string>;
    /**
     * Retrieves the validator data including staking contract, epoch, minNodeCount, and bootstrapUrls.
     * @returns An object containing the validator data.
     * @throws Error if minNodeCount is not provided, is less than or equal to 0, or if bootstrapUrls are not available.
     */
    private _getValidatorData;
    private _handleStakingContractStateChange;
    /**
     * Sets up a listener to detect state changes (new epochs) in the staking contract.
     * When a new epoch is detected, it triggers the `setNewConfig` function to update
     * the client's configuration based on the new state of the network. This ensures
     * that the client's configuration is always in sync with the current state of the
     * staking contract.
     *
     * @returns {Promise<void>} A promise that resolves when the listener is successfully set up.
     */
    private _listenForNewEpoch;
    /**
     *  Stops internal listeners/polling that refresh network state and watch for epoch changes.
     *  Removes global objects created internally
     */
    disconnect(): Promise<void>;
    _stopListeningForNewEpoch(): void;
    /**
     *
     * Set bootstrapUrls to match the network litNetwork unless it's set to custom
     *
     * @returns { void }
     *
     */
    setCustomBootstrapUrls: () => void;
    /**
     * Return the latest blockhash from the nodes
     * @returns { Promise<string> } latest blockhash
     */
    getLatestBlockhash: () => Promise<string>;
    /**
     *
     * Connect to the LIT nodes
     *
     * @returns { Promise } A promise that resolves when the nodes are connected.
     *
     */
    connect(): Promise<void>;
    private _connect;
    private _handshakeAndVerifyNodeAttestation;
    /** Handshakes with all nodes that are in `bootstrapUrls`
     * @private
     *
     * @returns {Promise<{connectedNodes: Set<string>, serverKeys: {}}>} Returns a set of the urls of nodes that we
     * successfully connected to, an object containing their returned keys, and our 'core' config (most common values for
     * critical values)
     */
    private _runHandshakeWithBootstrapUrls;
    private _getCoreNodeConfigFromHandshakeResults;
    private _getProviderWithFallback;
    /**
     * Fetches the latest block hash and log any errors that are returned
     * Nodes will accept any blockhash in the last 30 days but use the latest 10 as challenges for webauthn
     * Note: last blockhash from providers might not be propagated to the nodes yet, so we need to use a slightly older one
     * @returns void
     */
    private _syncBlockhash;
    /** Currently, we perform a full sync every 30s, including handshaking with every node
     * However, we also have a state change listener that watches for staking contract state change events, which
     * _should_ be the only time that we need to perform handshakes with every node.
     *
     * However, the current block hash does need to be updated regularly, and we currently update it only when we
     * handshake with every node.
     *
     * We can remove this network sync code entirely if we refactor our code to fetch latest blockhash on-demand.
     * @private
     */
    /**
     *
     * Get a new random request ID
     *
     * @returns { string }
     *
     */
    protected _getNewRequestId(): string;
    /**
     *
     * Get a random hex string for use as an attestation challenge
     *
     * @returns { string }
     */
    getRandomHexString(size: number): string;
    /**
     * Handshake with Node
     *
     * @param { HandshakeWithNode } params
     * @param { string } requestId
     * @returns { Promise<NodeCommandServerKeysResponse> }
     *
     */
    handshakeWithNode: (params: HandshakeWithNode, requestId: string) => Promise<NodeCommandServerKeysResponse>;
    private _fetchCurrentEpochState;
    get currentEpochNumber(): number | null;
    private set _epochState(value);
    /**
     *
     * Send a command to nodes
     *
     * @param { SendNodeCommand }
     *
     * @returns { Promise<any> }
     *
     */
    sendCommandToNode: ({ url, data, requestId, }: SendNodeCommand) => Promise<any>;
    /**
     *
     * Get and gather node promises
     *
     * @param { any } callback
     *
     * @returns { Array<Promise<any>> }
     *
     */
    getNodePromises: (callback: (url: string) => Promise<any>) => Promise<any>[];
    getRandomNodePromise(callback: (url: string) => Promise<any>): Promise<any>[];
    /**
     * Retrieves the session signature for a given URL from the sessionSigs map.
     * Throws an error if sessionSigs is not provided or if the session signature for the URL is not found.
     *
     * @param sessionSigs - The session signatures map.
     * @param url - The URL for which to retrieve the session signature.
     * @returns The session signature for the given URL.
     * @throws An error if sessionSigs is not provided or if the session signature for the URL is not found.
     */
    getSessionSigByUrl: ({ sessionSigs, url, }: {
        sessionSigs: SessionSigsMap;
        url: string;
    }) => AuthSig;
    validateAccessControlConditionsSchema: (params: MultipleAccessControlConditions) => Promise<boolean>;
    /**
     *
     * Get hash of access control conditions
     *
     * @param { MultipleAccessControlConditions } params
     *
     * @returns { Promise<ArrayBuffer | undefined> }
     *
     */
    getHashedAccessControlConditions: (params: MultipleAccessControlConditions) => Promise<ArrayBuffer | undefined>;
    /**
     * Handle node promises
     *
     * @param { Array<Promise<any>> } nodePromises
     *
     * @param { string } requestId requestId to be logged in case of error
     * @param { number } minNodeCount number of nodes we need valid results from in order to resolve
     * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
     */
    handleNodePromises: <T>(nodePromises: Promise<T>[], requestId: string, minNodeCount: number) => Promise<SuccessNodePromises<T> | RejectedNodePromises>;
    /**
     * Throw node error
     *
     * @param { RejectedNodePromises } res
     * @param { string } requestId
     *
     * @returns { never }
     *
     */
    _throwNodeError: (res: RejectedNodePromises, requestId: string) => never;
    /**
     *
     * Get different formats of access control conditions, eg. evm, sol, unified etc.
     *
     * @param { SupportedJsonRequests } params
     *
     * @returns { FormattedMultipleAccs }
     *
     */
    getFormattedAccessControlConditions: (params: SupportedJsonRequests) => FormattedMultipleAccs;
    /**
     * Calculates an HD public key from a given keyId
     * The curve type or signature type is assumed to be k256 unless provided
     * @param keyId
     * @param {LIT_CURVE_VALUES} sigType
     * @returns {string} public key
     */
    computeHDPubKey: (keyId: string, sigType?: LIT_CURVE_VALUES) => Promise<string>;
    /**
     * Calculates a Key Id for claiming a pkp based on a user identifier and an app identifier.
     * The key Identifier is an Auth Method Id which scopes the key uniquely to a specific application context.
     * These identifiers are specific to each auth method and will derive the public key portion of a pkp which will be persisted
     * when a key is claimed.
     * | Auth Method | User ID | App ID |
     * |:------------|:--------|:-------|
     * | Google OAuth | token `sub` | token `aud` |
     * | Discord OAuth | user id | client app identifier |
     * | Stytch OTP |token `sub` | token `aud`|
     * | Lit Actions | user defined | ipfs cid |
     * *Note* Lit Action claiming uses a different schema than other auth methods
     *
     * @param {string} userId user identifier for the Key Identifier
     * @param {string} appId app identifier for the Key Identifier
     * @param {boolean} isForActionContext should be set for true if using claiming through actions
     *
     * @returns {string} public key of pkp when claimed
     */
    computeHDKeyId(userId: string, appId: string, isForActionContext?: boolean): string;
}
