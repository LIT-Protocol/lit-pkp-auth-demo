"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LitCore = void 0;
const ethers_1 = require("ethers");
const access_control_conditions_1 = require("@lit-protocol/access-control-conditions");
const constants_1 = require("@lit-protocol/constants");
const contracts_sdk_1 = require("@lit-protocol/contracts-sdk");
const crypto_1 = require("@lit-protocol/crypto");
const misc_1 = require("@lit-protocol/misc");
const endpoint_version_1 = require("./endpoint-version");
// On epoch change, we wait this many seconds for the nodes to update to the new epoch before using the new epoch #
const EPOCH_PROPAGATION_DELAY = 45000;
// This interval is responsible for keeping latest block hash up to date
const BLOCKHASH_SYNC_INTERVAL = 30000;
// When fetching the blockhash from a provider (not lit), we use a 5 minutes old block to ensure the nodes centralized indexer has it
const BLOCKHASH_COUNT_PROVIDER_DELAY = -30; // 30 blocks ago. Eth block are mined every 12s. 30 blocks is 6 minutes, indexer/nodes must have it by now
// Intentionally not including datil-dev here per discussion with Howard
const NETWORKS_REQUIRING_SEV = [
    constants_1.LIT_NETWORK.DatilTest,
    constants_1.LIT_NETWORK.Datil,
];
/**
 * Lowest latency, highest score & privacy enabled listed on https://chainlist.org/
 */
const FALLBACK_RPC_URLS = [
    'https://ethereum-rpc.publicnode.com',
    'https://eth.llamarpc.com',
    'https://eth.drpc.org',
    'https://eth.llamarpc.com',
];
class LitCore {
    // ========== Constructor ==========
    constructor(config) {
        this.config = {
            alertWhenUnauthorized: false,
            debug: true,
            connectTimeout: 20000,
            checkNodeAttestation: false,
            litNetwork: constants_1.LIT_NETWORK.Custom,
            minNodeCount: 2, // Default value, should be replaced
            bootstrapUrls: [], // Default value, should be replaced
            nodeProtocol: null,
        };
        this.connectedNodes = new Set();
        this.serverKeys = {};
        this.ready = false;
        this.subnetPubKey = null;
        this.networkPubKey = null;
        this.networkPubKeySet = null;
        this.hdRootPubkeys = null;
        this.latestBlockhash = null;
        this.lastBlockHashRetrieved = null;
        this._networkSyncInterval = null;
        this._stakingContract = null;
        this._stakingContractListener = null;
        this._connectingPromise = null;
        this._epochCache = {
            currentNumber: null,
            startTime: null,
        };
        this._blockHashUrl = 'https://block-indexer.litgateway.com/get_most_recent_valid_block';
        // ========== Logger utilities ==========
        this.getLogsForRequestId = (id) => {
            return globalThis.logManager.getLogsForId(id);
        };
        this.getRequestIds = () => {
            return globalThis.logManager.LoggerIds;
        };
        /**
         *
         * Set bootstrapUrls to match the network litNetwork unless it's set to custom
         *
         * @returns { void }
         *
         */
        this.setCustomBootstrapUrls = () => {
            // -- validate
            if (this.config.litNetwork === constants_1.LIT_NETWORK.Custom)
                return;
            // -- execute
            const hasNetwork = this.config.litNetwork in constants_1.LIT_NETWORKS;
            if (!hasNetwork) {
                // network not found, report error
                throw new constants_1.LitNodeClientBadConfigError({}, 'the litNetwork specified in the LitNodeClient config not found in LIT_NETWORKS');
            }
            this.config.bootstrapUrls = constants_1.LIT_NETWORKS[this.config.litNetwork];
        };
        /**
         * Return the latest blockhash from the nodes
         * @returns { Promise<string> } latest blockhash
         */
        this.getLatestBlockhash = async () => {
            await this._syncBlockhash();
            if (!this.latestBlockhash) {
                throw new constants_1.InvalidEthBlockhash({}, `latestBlockhash is not available. Received: "%s"`, this.latestBlockhash);
            }
            return this.latestBlockhash;
        };
        this._getProviderWithFallback = async (providerTest) => {
            for (const url of FALLBACK_RPC_URLS) {
                try {
                    const provider = new ethers_1.ethers.providers.JsonRpcProvider({
                        url: url,
                        // https://docs.ethers.org/v5/api/utils/web/#ConnectionInfo
                        timeout: 60000,
                    });
                    const testResult = await providerTest(provider); // Check to see if the provider is working
                    return {
                        provider,
                        testResult,
                    };
                }
                catch (error) {
                    (0, misc_1.logError)(`RPC URL failed: ${url}`);
                }
            }
            return null;
        };
        /**
         * Handshake with Node
         *
         * @param { HandshakeWithNode } params
         * @param { string } requestId
         * @returns { Promise<NodeCommandServerKeysResponse> }
         *
         */
        this.handshakeWithNode = async (params, requestId) => {
            // -- get properties from params
            const { url } = params;
            // -- create url with path
            const urlWithPath = (0, endpoint_version_1.composeLitUrl)({
                url,
                endpoint: constants_1.LIT_ENDPOINT.HANDSHAKE,
            });
            (0, misc_1.log)(`handshakeWithNode ${urlWithPath}`);
            const data = {
                clientPublicKey: 'test',
                challenge: params.challenge,
            };
            return await this.sendCommandToNode({
                url: urlWithPath,
                data,
                requestId,
            });
        };
        // ==================== SENDING COMMAND ====================
        /**
         *
         * Send a command to nodes
         *
         * @param { SendNodeCommand }
         *
         * @returns { Promise<any> }
         *
         */
        this.sendCommandToNode = async ({ url, data, requestId, }) => {
            // FIXME: Replace <any> usage with explicit, strongly typed handlers
            data = { ...data, epoch: this.currentEpochNumber };
            // If there is a `sessionSigs' object in the params remove before sending the request;
            // this line has been added as a catch all to prevent sending with the request
            if (data.sessionSigs) {
                delete data.sessionSigs;
            }
            (0, misc_1.logWithRequestId)(requestId, `sendCommandToNode with url ${url} and data`, data);
            const req = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Accept: 'application/json',
                    'X-Lit-SDK-Version': constants_1.version,
                    'X-Lit-SDK-Type': 'Typescript',
                    'X-Request-Id': 'lit_' + requestId,
                },
                body: JSON.stringify(data),
            };
            return (0, misc_1.sendRequest)(url, req, requestId);
        };
        /**
         *
         * Get and gather node promises
         *
         * @param { any } callback
         *
         * @returns { Array<Promise<any>> }
         *
         */
        this.getNodePromises = (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        callback
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ) => {
            // FIXME: Replace <any> usage with explicit, strongly typed handlers
            const nodePromises = [];
            for (const url of this.connectedNodes) {
                nodePromises.push(callback(url));
            }
            return nodePromises;
        };
        /**
         * Retrieves the session signature for a given URL from the sessionSigs map.
         * Throws an error if sessionSigs is not provided or if the session signature for the URL is not found.
         *
         * @param sessionSigs - The session signatures map.
         * @param url - The URL for which to retrieve the session signature.
         * @returns The session signature for the given URL.
         * @throws An error if sessionSigs is not provided or if the session signature for the URL is not found.
         */
        this.getSessionSigByUrl = ({ sessionSigs, url, }) => {
            if (!sessionSigs) {
                throw new constants_1.InvalidArgumentException({}, 'You must pass in sessionSigs. Received: %s', sessionSigs);
            }
            const sigToPassToNode = sessionSigs[url];
            if (!sessionSigs[url]) {
                throw new constants_1.InvalidArgumentException({}, 'You passed sessionSigs but we could not find session sig for node %s', url);
            }
            return sigToPassToNode;
        };
        this.validateAccessControlConditionsSchema = async (params) => {
            // ========== Prepare Params ==========
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, } = params;
            if (accessControlConditions) {
                await (0, access_control_conditions_1.validateAccessControlConditionsSchema)(accessControlConditions);
            }
            else if (evmContractConditions) {
                await (0, access_control_conditions_1.validateEVMContractConditionsSchema)(evmContractConditions);
            }
            else if (solRpcConditions) {
                await (0, access_control_conditions_1.validateSolRpcConditionsSchema)(solRpcConditions);
            }
            else if (unifiedAccessControlConditions) {
                await (0, access_control_conditions_1.validateUnifiedAccessControlConditionsSchema)(unifiedAccessControlConditions);
            }
            return true;
        };
        /**
         *
         * Get hash of access control conditions
         *
         * @param { MultipleAccessControlConditions } params
         *
         * @returns { Promise<ArrayBuffer | undefined> }
         *
         */
        this.getHashedAccessControlConditions = async (params) => {
            let hashOfConditions;
            // ========== Prepare Params ==========
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, } = params;
            // ========== Hash ==========
            if (accessControlConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashAccessControlConditions)(accessControlConditions);
            }
            else if (evmContractConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashEVMContractConditions)(evmContractConditions);
            }
            else if (solRpcConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashSolRpcConditions)(solRpcConditions);
            }
            else if (unifiedAccessControlConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashUnifiedAccessControlConditions)(unifiedAccessControlConditions);
            }
            else {
                return;
            }
            // ========== Result ==========
            return hashOfConditions;
        };
        /**
         * Handle node promises
         *
         * @param { Array<Promise<any>> } nodePromises
         *
         * @param { string } requestId requestId to be logged in case of error
         * @param { number } minNodeCount number of nodes we need valid results from in order to resolve
         * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
         */
        this.handleNodePromises = async (nodePromises, requestId, minNodeCount) => {
            async function waitForNSuccessesWithErrors(promises, n
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            ) {
                let responses = 0;
                const successes = [];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const errors = [];
                return new Promise((resolve) => {
                    promises.forEach((promise) => {
                        promise
                            .then((result) => {
                            successes.push(result);
                            if (successes.length >= n) {
                                // If we've got enough successful responses to continue, resolve immediately even if some are pending
                                resolve({ successes, errors });
                            }
                        })
                            .catch((error) => {
                            errors.push(error);
                        })
                            .finally(() => {
                            responses++;
                            if (responses === promises.length) {
                                // In case the total number of successful responses is less than n,
                                // resolve what we have when all promises are settled.
                                resolve({ successes, errors });
                            }
                        });
                    });
                });
            }
            // -- wait until we've received n responses
            const { successes, errors } = await waitForNSuccessesWithErrors(nodePromises, minNodeCount);
            // console.log(`successes: ${JSON.stringify(successes, null, 2)}`)
            // console.log(`errors: ${JSON.stringify(errors, null, 2)}`)
            // -- case: success (when success responses are more than minNodeCount)
            if (successes.length >= minNodeCount) {
                return {
                    success: true,
                    values: successes,
                };
            }
            // TODO Likely a good use case for MultiError
            // -- case: if we're here, then we did not succeed.  time to handle and report errors.
            const mostCommonError = JSON.parse(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (0, misc_1.mostCommonString)(errors.map((r) => JSON.stringify(r))));
            (0, misc_1.logErrorWithRequestId)(requestId || '', `most common error: ${JSON.stringify(mostCommonError)}`);
            return {
                success: false,
                error: mostCommonError,
            };
        };
        /**
         * Throw node error
         *
         * @param { RejectedNodePromises } res
         * @param { string } requestId
         *
         * @returns { never }
         *
         */
        this._throwNodeError = (res, requestId) => {
            if (res.error) {
                if (((res.error.errorCode &&
                    res.error.errorCode === constants_1.LIT_ERROR_CODE.NODE_NOT_AUTHORIZED) ||
                    res.error.errorCode === 'not_authorized') &&
                    this.config.alertWhenUnauthorized) {
                    (0, misc_1.log)('You are not authorized to access this content');
                }
                throw new constants_1.NodeError({
                    info: {
                        requestId,
                        errorCode: res.error.errorCode,
                        message: res.error.message,
                    },
                    cause: res.error,
                }, 'There was an error getting the signing shares from the nodes. Response from the nodes: %s', JSON.stringify(res));
            }
            else {
                throw new constants_1.UnknownError({
                    info: {
                        requestId,
                    },
                }, `There was an error getting the signing shares from the nodes. Response from the nodes: %s`, JSON.stringify(res));
            }
        };
        /**
         *
         * Get different formats of access control conditions, eg. evm, sol, unified etc.
         *
         * @param { SupportedJsonRequests } params
         *
         * @returns { FormattedMultipleAccs }
         *
         */
        this.getFormattedAccessControlConditions = (params) => {
            // -- prepare params
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, } = params;
            // -- execute
            let formattedAccessControlConditions;
            let formattedEVMContractConditions;
            let formattedSolRpcConditions;
            let formattedUnifiedAccessControlConditions;
            let error = false;
            if (accessControlConditions) {
                formattedAccessControlConditions = accessControlConditions.map((c) => (0, access_control_conditions_1.canonicalAccessControlConditionFormatter)(c));
                (0, misc_1.log)('formattedAccessControlConditions', JSON.stringify(formattedAccessControlConditions));
            }
            else if (evmContractConditions) {
                formattedEVMContractConditions = evmContractConditions.map((c) => (0, access_control_conditions_1.canonicalEVMContractConditionFormatter)(c));
                (0, misc_1.log)('formattedEVMContractConditions', JSON.stringify(formattedEVMContractConditions));
            }
            else if (solRpcConditions) {
                // FIXME: ConditionItem is too narrow, or `solRpcConditions` is too wide
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                formattedSolRpcConditions = solRpcConditions.map((c) => (0, access_control_conditions_1.canonicalSolRpcConditionFormatter)(c));
                (0, misc_1.log)('formattedSolRpcConditions', JSON.stringify(formattedSolRpcConditions));
            }
            else if (unifiedAccessControlConditions) {
                formattedUnifiedAccessControlConditions =
                    unifiedAccessControlConditions.map((c) => (0, access_control_conditions_1.canonicalUnifiedAccessControlConditionFormatter)(c));
                (0, misc_1.log)('formattedUnifiedAccessControlConditions', JSON.stringify(formattedUnifiedAccessControlConditions));
            }
            else {
                error = true;
            }
            return {
                error,
                formattedAccessControlConditions,
                formattedEVMContractConditions,
                formattedSolRpcConditions,
                formattedUnifiedAccessControlConditions,
            };
        };
        /**
         * Calculates an HD public key from a given keyId
         * The curve type or signature type is assumed to be k256 unless provided
         * @param keyId
         * @param {LIT_CURVE_VALUES} sigType
         * @returns {string} public key
         */
        this.computeHDPubKey = async (keyId, sigType = constants_1.LIT_CURVE.EcdsaCaitSith) => {
            if (!this.hdRootPubkeys) {
                (0, misc_1.logError)('root public keys not found, have you connected to the nodes?');
                throw new constants_1.LitNodeClientNotReadyError({}, 'root public keys not found, have you connected to the nodes?');
            }
            return await (0, crypto_1.computeHDPubKey)(this.hdRootPubkeys, keyId, sigType);
        };
        if (!(config.litNetwork in constants_1.LIT_NETWORKS)) {
            const validNetworks = Object.keys(constants_1.LIT_NETWORKS).join(', ');
            throw new constants_1.InvalidParamType({}, 'Unsupported network has been provided please use a "litNetwork" option which is supported (%s)', validNetworks);
        }
        // Initialize default config based on litNetwork
        switch (config?.litNetwork) {
            // Official networks; default value for `checkNodeAttestation` according to network provided.
            case constants_1.LIT_NETWORK.DatilDev:
                this.config = {
                    ...this.config,
                    checkNodeAttestation: NETWORKS_REQUIRING_SEV.includes(config?.litNetwork),
                    ...config,
                };
                break;
            default:
                // `custom`; no opinion about checkNodeAttestation
                this.config = {
                    ...this.config,
                    ...config,
                };
        }
        // -- set bootstrapUrls to match the network litNetwork unless it's set to custom
        this.setCustomBootstrapUrls();
        // -- set global variables
        (0, misc_1.setMiscLitConfig)(this.config);
        (0, misc_1.bootstrapLogManager)('core', this.config.debug ? constants_1.LogLevel.DEBUG : constants_1.LogLevel.OFF);
        // -- configure local storage if not present
        // LitNodeClientNodejs is a base for LitNodeClient
        // First check for if our runtime is node
        // If the user sets a new storage provider we respect it over our default storage
        // If the user sets a new file path, we respect it over the default path.
        if (this.config.storageProvider?.provider) {
            (0, misc_1.log)('localstorage api not found, injecting persistence instance found in config');
            // using Object defineProperty in order to set a property previously defined as readonly.
            // if the user wants to override the storage option explicitly we override.
            Object.defineProperty(globalThis, 'localStorage', {
                value: this.config.storageProvider?.provider,
            });
        }
        else if ((0, misc_1.isNode)() &&
            !globalThis.localStorage &&
            !this.config.storageProvider?.provider) {
            (0, misc_1.log)('Looks like you are running in NodeJS and did not provide a storage provider, your sessions will not be cached');
        }
    }
    /**
     * Retrieves the validator data including staking contract, epoch, minNodeCount, and bootstrapUrls.
     * @returns An object containing the validator data.
     * @throws Error if minNodeCount is not provided, is less than or equal to 0, or if bootstrapUrls are not available.
     */
    async _getValidatorData() {
        const { stakingContract, epochInfo, minNodeCount, bootstrapUrls } = await contracts_sdk_1.LitContracts.getConnectionInfo({
            litNetwork: this.config.litNetwork,
            networkContext: this.config.contractContext,
            rpcUrl: this.config.rpcUrl,
            nodeProtocol: this.config.nodeProtocol,
        });
        // Validate minNodeCount
        if (!minNodeCount) {
            throw new constants_1.InvalidArgumentException({}, `minNodeCount is %s, which is invalid. Please check your network connection and try again.`, minNodeCount);
        }
        // Validate bootstrapUrls
        if (!Array.isArray(bootstrapUrls) || bootstrapUrls.length <= 0) {
            throw new constants_1.InitError({}, `Failed to get bootstrapUrls for network %s`, this.config.litNetwork);
        }
        (0, misc_1.log)('[_getValidatorData] epochInfo: ', epochInfo);
        (0, misc_1.log)('[_getValidatorData] minNodeCount: ', minNodeCount);
        (0, misc_1.log)('[_getValidatorData] Bootstrap urls: ', bootstrapUrls);
        (0, misc_1.log)('[_getValidatorData] stakingContract: ', stakingContract.address);
        return {
            stakingContract,
            epochInfo,
            minNodeCount,
            bootstrapUrls,
        };
    }
    // ========== Scoped Class Helpers ==========
    async _handleStakingContractStateChange(state) {
        (0, misc_1.log)(`New state detected: "${state}"`);
        const validatorData = await this._getValidatorData();
        if (state === constants_1.STAKING_STATES.Active) {
            // We always want to track the most recent epoch number on _all_ networks
            this._epochState = await this._fetchCurrentEpochState(validatorData.epochInfo);
            if (constants_1.CENTRALISATION_BY_NETWORK[this.config.litNetwork] !== 'centralised') {
                // We don't need to handle node urls changing on centralised networks, since their validator sets are static
                try {
                    (0, misc_1.log)('State found to be new validator set locked, checking validator set');
                    const existingNodeUrls = [...this.config.bootstrapUrls];
                    const delta = validatorData.bootstrapUrls.filter((item) => existingNodeUrls.includes(item));
                    // if the sets differ we reconnect.
                    if (delta.length > 1) {
                        // check if the node sets are non-matching and re-connect if they do not.
                        /*
                            TODO: This covers *most* cases where a node may come in or out of the active
                            set which we will need to re attest to the execution environments.
                            However, the sdk currently does not know if there is an active network operation pending.
                            Such that the state when the request was sent will now mutate when the response is sent back.
                            The sdk should be able to understand its current execution environment and wait on an active
                            network request to the previous epoch's node set before changing over.
                          */
                        (0, misc_1.log)('Active validator sets changed, new validators ', delta, 'starting node connection');
                    }
                    await this.connect();
                }
                catch (err) {
                    // FIXME: We should emit an error event so that consumers know that we are de-synced and can connect() again
                    // But for now, our every-30-second network sync will fix things in at most 30s from now.
                    // this.ready = false; Should we assume core is invalid if we encountered errors refreshing from an epoch change?
                    const { message = '' } = err;
                    (0, misc_1.logError)('Error while attempting to reconnect to nodes after epoch transition:', message);
                }
            }
        }
    }
    /**
     * Sets up a listener to detect state changes (new epochs) in the staking contract.
     * When a new epoch is detected, it triggers the `setNewConfig` function to update
     * the client's configuration based on the new state of the network. This ensures
     * that the client's configuration is always in sync with the current state of the
     * staking contract.
     *
     * @returns {Promise<void>} A promise that resolves when the listener is successfully set up.
     */
    _listenForNewEpoch() {
        // Check if we've already set up the listener to avoid duplicates
        if (this._stakingContractListener) {
            // Already listening, do nothing
            return;
        }
        if (this._stakingContract) {
            (0, misc_1.log)('listening for state change on staking contract: ', this._stakingContract.address);
            // Stash a function instance, because its identity must be consistent for '.off()' usage to work later
            this._stakingContractListener = (state) => {
                // Intentionally not return or await; Listeners are _not async_
                this._handleStakingContractStateChange(state);
            };
            this._stakingContract.on('StateChanged', this._stakingContractListener);
        }
    }
    /**
     *  Stops internal listeners/polling that refresh network state and watch for epoch changes.
     *  Removes global objects created internally
     */
    async disconnect() {
        this.ready = false;
        this._stopListeningForNewEpoch();
        // this._stopNetworkPolling();
        (0, misc_1.setMiscLitConfig)(undefined);
    }
    // _stopNetworkPolling() {
    //   if (this._networkSyncInterval) {
    //     clearInterval(this._networkSyncInterval);
    //     this._networkSyncInterval = null;
    //   }
    // }
    _stopListeningForNewEpoch() {
        if (this._stakingContract && this._stakingContractListener) {
            this._stakingContract.off('StateChanged', this._stakingContractListener);
            this._stakingContractListener = null;
        }
    }
    /**
     *
     * Connect to the LIT nodes
     *
     * @returns { Promise } A promise that resolves when the nodes are connected.
     *
     */
    async connect() {
        // Ensure that multiple closely timed calls to `connect()` don't result in concurrent connect() operations being run
        if (this._connectingPromise) {
            return this._connectingPromise;
        }
        this._connectingPromise = this._connect();
        await this._connectingPromise.finally(() => {
            this._connectingPromise = null;
        });
    }
    async _connect() {
        // Ensure an ill-timed epoch change event doesn't trigger concurrent config changes while we're already doing that
        this._stopListeningForNewEpoch();
        // Ensure we don't fire an existing network sync poll handler while we're in the midst of connecting anyway
        // this._stopNetworkPolling();
        // Initialize a contractContext if we were not given one; this allows interaction against the staking contract
        // to be handled locally from then on
        if (!this.config.contractContext) {
            this.config.contractContext = await contracts_sdk_1.LitContracts.getContractAddresses(this.config.litNetwork, new ethers_1.ethers.providers.StaticJsonRpcProvider({
                url: this.config.rpcUrl || constants_1.RPC_URL_BY_NETWORK[this.config.litNetwork],
                skipFetchSetup: true,
            }));
        }
        else if (!this.config.contractContext.Staking &&
            !this.config.contractContext.resolverAddress) {
            throw new constants_1.InitError({
                info: {
                    contractContext: this.config.contractContext,
                    litNetwork: this.config.litNetwork,
                    rpcUrl: this.config.rpcUrl,
                },
            }, 'The provided contractContext was missing the "Staking" contract');
        }
        if (this.config.contractContext) {
            const logAddresses = Object.entries(this.config.contractContext).reduce((output, [key, val]) => {
                // @ts-expect-error since the object hash returned by `getContractAddresses` is `any`, we have no types here
                output[key] = val.address;
                return output;
            }, {});
            if (this.config.litNetwork === constants_1.LIT_NETWORK.Custom) {
                (0, misc_1.log)('using custom contracts: ', logAddresses);
            }
        }
        // Re-use staking contract instance from previous connect() executions that succeeded to improve performance
        // noinspection ES6MissingAwait - intentionally not `awaiting` so we can run this in parallel below
        const validatorData = await this._getValidatorData();
        this._stakingContract = validatorData.stakingContract;
        this.config.minNodeCount = validatorData.minNodeCount;
        this.config.bootstrapUrls = validatorData.bootstrapUrls;
        this._epochState = await this._fetchCurrentEpochState(validatorData.epochInfo);
        // -- handshake with each node.  Note that if we've previously initialized successfully, but this call fails,
        // core will remain useable but with the existing set of `connectedNodes` and `serverKeys`.
        const { connectedNodes, serverKeys, coreNodeConfig } = await this._runHandshakeWithBootstrapUrls();
        Object.assign(this, { ...coreNodeConfig, connectedNodes, serverKeys });
        // this._scheduleNetworkSync();
        this._listenForNewEpoch();
        this.ready = true;
        (0, misc_1.log)(`ðŸ”¥ lit is ready. "litNodeClient" variable is ready to use globally.`);
        (0, misc_1.log)('current network config', {
            networkPubkey: this.networkPubKey,
            networkPubKeySet: this.networkPubKeySet,
            hdRootPubkeys: this.hdRootPubkeys,
            subnetPubkey: this.subnetPubKey,
            latestBlockhash: this.latestBlockhash,
        });
        // browser only
        if ((0, misc_1.isBrowser)()) {
            document.dispatchEvent(new Event('lit-ready'));
        }
    }
    async _handshakeAndVerifyNodeAttestation({ url, requestId, }) {
        const challenge = this.getRandomHexString(64);
        const handshakeResult = await this.handshakeWithNode({ url, challenge }, requestId);
        const keys = {
            serverPubKey: handshakeResult.serverPublicKey,
            subnetPubKey: handshakeResult.subnetPublicKey,
            networkPubKey: handshakeResult.networkPublicKey,
            networkPubKeySet: handshakeResult.networkPublicKeySet,
            hdRootPubkeys: handshakeResult.hdRootPubkeys,
            latestBlockhash: handshakeResult.latestBlockhash,
        };
        // Nodes that have just bootstrapped will not have negotiated their keys, yet
        // They will return ERR for those values until they reach consensus
        // Note that if node attestation checks are disabled or checkSevSnpAttestation() succeeds, we will still track the
        // node, even though its keys may be "ERR".
        // Should we really track servers with ERR as keys?
        if (keys.serverPubKey === 'ERR' ||
            keys.subnetPubKey === 'ERR' ||
            keys.networkPubKey === 'ERR' ||
            keys.networkPubKeySet === 'ERR') {
            (0, misc_1.logErrorWithRequestId)(requestId, 'Error connecting to node. Detected "ERR" in keys', url, keys);
        }
        (0, misc_1.log)(`Handshake with ${url} returned keys: `, keys);
        if (!keys.latestBlockhash) {
            (0, misc_1.logErrorWithRequestId)(requestId, `Error getting latest blockhash from the node ${url}.`);
        }
        // We force SEV checks on some networks even if the caller attempts to construct the client with them disabled
        if (this.config.checkNodeAttestation ||
            NETWORKS_REQUIRING_SEV.includes(this.config.litNetwork)) {
            const attestation = handshakeResult.attestation;
            if (!attestation) {
                throw new constants_1.InvalidNodeAttestation({}, `Missing attestation in handshake response from %s`, url);
            }
            // actually verify the attestation by checking the signature against AMD certs
            (0, misc_1.log)('Checking attestation against amd certs...');
            try {
                // ensure we won't try to use a node with an invalid attestation response
                await (0, crypto_1.checkSevSnpAttestation)(attestation, challenge, url);
                (0, misc_1.log)(`Lit Node Attestation verified for ${url}`);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (e) {
                throw new constants_1.InvalidNodeAttestation({
                    cause: e,
                }, `Lit Node Attestation failed verification for %s - %s`, url, e.message);
            }
        }
        else if (this.config.litNetwork === constants_1.LIT_NETWORK.Custom) {
            (0, misc_1.log)(`Node attestation SEV verification is disabled. You must explicitly set "checkNodeAttestation" to true when using 'custom' network`);
        }
        return keys;
    }
    /** Handshakes with all nodes that are in `bootstrapUrls`
     * @private
     *
     * @returns {Promise<{connectedNodes: Set<string>, serverKeys: {}}>} Returns a set of the urls of nodes that we
     * successfully connected to, an object containing their returned keys, and our 'core' config (most common values for
     * critical values)
     */
    async _runHandshakeWithBootstrapUrls() {
        // -- handshake with each node
        const requestId = this._getNewRequestId();
        // track connectedNodes for the new handshake operation
        const connectedNodes = new Set();
        const serverKeys = {};
        let timeoutHandle;
        await Promise.race([
            new Promise((_resolve, reject) => {
                timeoutHandle = setTimeout(() => {
                    const msg = `Error: Could not handshake with nodes after timeout of ${this.config.connectTimeout}ms. Could only connect to ${Object.keys(serverKeys).length} of ${this.config.bootstrapUrls.length} nodes. Please check your network connection and try again. Note that you can control this timeout with the connectTimeout config option which takes milliseconds.`;
                    try {
                        throw new constants_1.InitError({}, msg);
                    }
                    catch (e) {
                        (0, misc_1.logErrorWithRequestId)(requestId, e);
                        reject(e);
                    }
                }, this.config.connectTimeout);
            }),
            Promise.all(this.config.bootstrapUrls.map(async (url) => {
                serverKeys[url] = await this._handshakeAndVerifyNodeAttestation({
                    url,
                    requestId,
                });
                connectedNodes.add(url);
            })).finally(() => {
                clearTimeout(timeoutHandle);
            }),
        ]);
        const coreNodeConfig = this._getCoreNodeConfigFromHandshakeResults({
            serverKeys,
            requestId,
        });
        return { connectedNodes, serverKeys, coreNodeConfig };
    }
    _getCoreNodeConfigFromHandshakeResults({ serverKeys, requestId, }) {
        const latestBlockhash = (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode) => keysFromSingleNode.latestBlockhash));
        if (!latestBlockhash) {
            (0, misc_1.logErrorWithRequestId)(requestId, 'Error getting latest blockhash from the nodes.');
            throw new constants_1.InvalidEthBlockhash({
                info: {
                    requestId,
                },
            }, `latestBlockhash is not available. Received: "%s"`, latestBlockhash);
        }
        // pick the most common public keys for the subnet and network from the bunch, in case some evil node returned a bad key
        return {
            subnetPubKey: (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode) => keysFromSingleNode.subnetPubKey)),
            networkPubKey: (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode) => keysFromSingleNode.networkPubKey)),
            networkPubKeySet: (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode) => keysFromSingleNode.networkPubKeySet)),
            hdRootPubkeys: (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode) => keysFromSingleNode.hdRootPubkeys)),
            latestBlockhash,
            lastBlockHashRetrieved: Date.now(),
        };
    }
    /**
     * Fetches the latest block hash and log any errors that are returned
     * Nodes will accept any blockhash in the last 30 days but use the latest 10 as challenges for webauthn
     * Note: last blockhash from providers might not be propagated to the nodes yet, so we need to use a slightly older one
     * @returns void
     */
    async _syncBlockhash() {
        const currentTime = Date.now();
        const blockHashValidityDuration = BLOCKHASH_SYNC_INTERVAL;
        if (this.latestBlockhash &&
            this.lastBlockHashRetrieved &&
            currentTime - this.lastBlockHashRetrieved < blockHashValidityDuration) {
            (0, misc_1.log)('Blockhash is still valid. No need to sync.');
            return;
        }
        (0, misc_1.log)('Syncing state for new blockhash ', 'current blockhash: ', this.latestBlockhash);
        try {
            // This fetches from the lit propagation service so nodes will always have it
            const resp = await fetch(this._blockHashUrl);
            // If the blockhash retrieval failed, throw an error to trigger fallback in catch block
            if (!resp.ok) {
                throw new constants_1.NetworkError({
                    responseResult: resp.ok,
                    responseStatus: resp.status,
                }, `Error getting latest blockhash from ${this._blockHashUrl}. Received: "${resp.status}"`);
            }
            const blockHashBody = await resp.json();
            const { blockhash, timestamp } = blockHashBody;
            // If the blockhash retrieval does not have the required fields, throw an error to trigger fallback in catch block
            if (!blockhash || !timestamp) {
                throw new constants_1.NetworkError({
                    responseResult: resp.ok,
                    blockHashBody,
                }, `Error getting latest blockhash from block indexer. Received: "${blockHashBody}"`);
            }
            this.latestBlockhash = blockHashBody.blockhash;
            this.lastBlockHashRetrieved = parseInt(timestamp) * 1000;
            (0, misc_1.log)('Done syncing state new blockhash: ', this.latestBlockhash);
        }
        catch (error) {
            const err = error;
            (0, misc_1.logError)('Error while attempting to fetch new latestBlockhash:', err instanceof Error ? err.message : err.messages, 'Reason: ', err instanceof Error ? err : err.reason);
            (0, misc_1.log)('Attempting to fetch blockhash manually using ethers with fallback RPC URLs...');
            const { testResult } = (await this._getProviderWithFallback(
            // We use a previous block to avoid nodes not having received the latest block yet
            (provider) => provider.getBlock(BLOCKHASH_COUNT_PROVIDER_DELAY))) || {};
            if (!testResult || !testResult.hash) {
                (0, misc_1.logError)('All fallback RPC URLs failed. Unable to retrieve blockhash.');
                return;
            }
            try {
                this.latestBlockhash = testResult.hash;
                this.lastBlockHashRetrieved = testResult.timestamp;
                (0, misc_1.log)('Successfully retrieved blockhash manually: ', this.latestBlockhash);
            }
            catch (ethersError) {
                (0, misc_1.logError)('Failed to manually retrieve blockhash using ethers');
            }
        }
    }
    /** Currently, we perform a full sync every 30s, including handshaking with every node
     * However, we also have a state change listener that watches for staking contract state change events, which
     * _should_ be the only time that we need to perform handshakes with every node.
     *
     * However, the current block hash does need to be updated regularly, and we currently update it only when we
     * handshake with every node.
     *
     * We can remove this network sync code entirely if we refactor our code to fetch latest blockhash on-demand.
     * @private
     */
    // private _scheduleNetworkSync() {
    //   if (this._networkSyncInterval) {
    //     clearInterval(this._networkSyncInterval);
    //   }
    //   this._networkSyncInterval = setInterval(async () => {
    //     if (
    //       !this.lastBlockHashRetrieved ||
    //       Date.now() - this.lastBlockHashRetrieved >= BLOCKHASH_SYNC_INTERVAL
    //     ) {
    //       await this._syncBlockhash();
    //     }
    //   }, BLOCKHASH_SYNC_INTERVAL);
    // }
    /**
     *
     * Get a new random request ID
     *
     * @returns { string }
     *
     */
    _getNewRequestId() {
        return Math.random().toString(16).slice(2);
    }
    /**
     *
     * Get a random hex string for use as an attestation challenge
     *
     * @returns { string }
     */
    getRandomHexString(size) {
        return [...Array(size)]
            .map(() => Math.floor(Math.random() * 16).toString(16))
            .join('');
    }
    async _fetchCurrentEpochState(epochInfo) {
        if (!this._stakingContract) {
            throw new constants_1.InitError({}, 'Unable to fetch current epoch number; no staking contract configured. Did you forget to `connect()`?');
        }
        if (!epochInfo) {
            (0, misc_1.log)('epochinfo not found. Not a problem, fetching current epoch state from staking contract');
            try {
                const validatorData = await this._getValidatorData();
                epochInfo = validatorData.epochInfo;
            }
            catch (error) {
                throw new constants_1.UnknownError({}, '[_fetchCurrentEpochNumber] Error getting current epoch number: %s', error);
            }
        }
        // when we transition to the new epoch, we don't store the start time.  but we
        // set the endTime to the current timestamp + epochLength.
        // by reversing this and subtracting epochLength from the endTime, we get the start time
        const startTime = epochInfo.endTime - epochInfo.epochLength;
        return {
            currentNumber: epochInfo.number,
            startTime,
        };
    }
    get currentEpochNumber() {
        // if the epoch started less than 15s ago (aka EPOCH_PROPAGATION_DELAY), use the previous epoch number
        // this gives the nodes time to sync with the chain and see the new epoch before we try to use it
        if (this._epochCache.currentNumber &&
            this._epochCache.startTime &&
            Math.floor(Date.now() / 1000) <
                this._epochCache.startTime +
                    Math.floor(EPOCH_PROPAGATION_DELAY / 1000) &&
            this._epochCache.currentNumber >= 3 // FIXME: Why this check?
        ) {
            return this._epochCache.currentNumber - 1;
        }
        return this._epochCache.currentNumber;
    }
    set _epochState({ currentNumber, startTime, }) {
        this._epochCache.currentNumber = currentNumber;
        this._epochCache.startTime = startTime;
    }
    getRandomNodePromise(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        const randomNodeIndex = Math.floor(Math.random() * this.connectedNodes.size);
        const nodeUrlsArr = Array.from(this.connectedNodes);
        return [callback(nodeUrlsArr[randomNodeIndex])];
    }
    /**
     * Calculates a Key Id for claiming a pkp based on a user identifier and an app identifier.
     * The key Identifier is an Auth Method Id which scopes the key uniquely to a specific application context.
     * These identifiers are specific to each auth method and will derive the public key portion of a pkp which will be persisted
     * when a key is claimed.
     * | Auth Method | User ID | App ID |
     * |:------------|:--------|:-------|
     * | Google OAuth | token `sub` | token `aud` |
     * | Discord OAuth | user id | client app identifier |
     * | Stytch OTP |token `sub` | token `aud`|
     * | Lit Actions | user defined | ipfs cid |
     * *Note* Lit Action claiming uses a different schema than other auth methods
     *
     * @param {string} userId user identifier for the Key Identifier
     * @param {string} appId app identifier for the Key Identifier
     * @param {boolean} isForActionContext should be set for true if using claiming through actions
     *
     * @returns {string} public key of pkp when claimed
     */
    computeHDKeyId(userId, appId, isForActionContext = false) {
        if (!isForActionContext) {
            return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${appId}`));
        }
        else {
            return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${appId}:${userId}`));
        }
    }
}
exports.LitCore = LitCore;
//# sourceMappingURL=lit-core.js.map