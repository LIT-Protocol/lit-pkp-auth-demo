"use strict";
/**
 * Param Validators is an abstraction of validating params of a function, each validator
 * returns a boolean value indicating whether the validation is passed or not.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.paramsValidators = exports.safeParams = void 0;
const utils_1 = require("ethers/lib/utils");
const constants_1 = require("@lit-protocol/constants");
const misc_1 = require("./misc");
const utils_2 = require("./utils");
const safeParams = ({ functionName, params, }) => {
    if (!exports.paramsValidators[functionName]) {
        (0, misc_1.log)(`This function ${functionName} is skipping params safe guarding.`);
        return (0, constants_1.ERight)(undefined);
    }
    const paramValidators = exports.paramsValidators[functionName](params);
    for (const validator of paramValidators) {
        const validationResponse = validator.validate();
        if (validationResponse.type === constants_1.EITHER_TYPE.ERROR) {
            return validationResponse;
        }
    }
    return (0, constants_1.ERight)(undefined);
};
exports.safeParams = safeParams;
exports.paramsValidators = {
    // ========== NO AUTH MATERIAL NEEDED FOR CLIENT SIDE ENCRYPTION ==========
    encrypt: (params) => [
        new AccessControlConditionsValidator('encrypt', params),
    ],
    encryptUint8Array: (params) => [
        new AccessControlConditionsValidator('encryptUint8Array', params),
        new Uint8ArrayValidator('encryptUint8Array', params.dataToEncrypt),
    ],
    encryptFile: (params) => [
        new AccessControlConditionsValidator('encryptFile', params),
        new FileValidator('encryptFile', params.file),
    ],
    encryptString: (params) => [
        new AccessControlConditionsValidator('encryptString', params),
        new StringValidator('encryptString', params.dataToEncrypt, 'dataToEncrypt'),
    ],
    encryptToJson: (params) => [
        new AccessControlConditionsValidator('encryptToJson', params),
        new EncryptToJsonValidator('encryptToJson', params),
    ],
    // ========== REQUIRED AUTH MATERIAL VALIDATORS ==========
    executeJs: (params) => [
        new AuthMaterialValidator('executeJs', params),
        new ExecuteJsValidator('executeJs', params),
    ],
    decrypt: (params) => [
        new AccessControlConditionsValidator('decrypt', params),
        new AuthMaterialValidator('decrypt', params, true),
        new StringValidator('decrypt', params.ciphertext, 'ciphertext'),
    ],
    decryptFromJson: (params) => [
        new AuthMaterialValidator('decryptFromJson', params),
        new DecryptFromJsonValidator('decryptFromJson', params.parsedJsonData),
    ],
};
class EncryptToJsonValidator {
    constructor(fnName, params) {
        this.fnName = fnName;
        this.params = params;
    }
    validate() {
        const { file, string } = this.params;
        if (string === undefined && file === undefined)
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'string',
                    value: string,
                    functionName: this.fnName,
                },
            }, 'Either string or file must be provided'));
        if (string !== undefined && file !== undefined)
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'string',
                    value: string,
                    functionName: this.fnName,
                },
            }, 'Provide only a "string" or "file" to encrypt; you cannot provide both'));
        return (0, constants_1.ERight)(undefined);
    }
}
class DecryptFromJsonValidator {
    constructor(fnName, params) {
        this.fnName = fnName;
        this.params = params;
    }
    validate() {
        const validators = [new StringValidator(this.fnName, this.params.dataType)];
        for (const validator of validators) {
            const validationResponse = validator.validate();
            if (validationResponse.type === constants_1.EITHER_TYPE.ERROR) {
                return validationResponse;
            }
        }
        const { dataType } = this.params;
        if (dataType !== 'string' && dataType !== 'file')
            return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
                info: {
                    functionName: this.fnName,
                    dataType,
                },
            }, `dataType of %s is not valid. Must be 'string' or 'file'.`, dataType));
        return (0, constants_1.ERight)(undefined);
    }
}
class Uint8ArrayValidator {
    constructor(fnName, uint8array, paramName = 'uint8array') {
        this.fnName = fnName;
        this.paramName = paramName;
        this.uint8array = uint8array;
    }
    validate() {
        if (!this.uint8array) {
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({}, 'uint8array is undefined'));
        }
        if (!(0, misc_1.checkType)({
            value: this.uint8array,
            allowedTypes: ['Uint8Array'],
            paramName: this.paramName,
            functionName: this.fnName,
        }))
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: this.paramName,
                    value: this.uint8array,
                    functionName: this.fnName,
                },
            }, '%s is not a Uint8Array', this.paramName));
        return (0, constants_1.ERight)(undefined);
    }
}
class StringValidator {
    constructor(fnName, str, paramName = 'string', checkIsHex = false) {
        this.fnName = fnName;
        this.paramName = paramName;
        this.checkIsHex = checkIsHex;
        this.str = str;
    }
    validate() {
        if (!this.str) {
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({}, 'str is undefined'));
        }
        if (!(0, misc_1.checkType)({
            value: this.str,
            allowedTypes: ['String'],
            paramName: this.paramName,
            functionName: this.fnName,
        }))
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: this.paramName,
                    value: this.str,
                    functionName: this.fnName,
                },
            }, '%s is not a string', this.paramName));
        if (this.checkIsHex && !(0, utils_1.isHexString)(this.str)) {
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: this.paramName,
                    value: this.str,
                    functionName: this.fnName,
                },
            }, '%s is not a valid hex string', this.paramName));
        }
        return (0, constants_1.ERight)(undefined);
    }
}
class AuthMethodValidator {
    constructor(fnName, authMethods) {
        this.fnName = fnName;
        this.authMethods = authMethods;
    }
    validate() {
        const { authMethods } = this;
        if (authMethods &&
            authMethods.length > 0 &&
            !(0, misc_1.checkType)({
                value: authMethods,
                allowedTypes: ['Array'],
                paramName: 'authMethods',
                functionName: this.fnName,
            }))
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'authMethods',
                    value: authMethods,
                    functionName: this.fnName,
                },
            }, 'authMethods is not an array'));
        return (0, constants_1.ERight)(undefined);
    }
}
class ExecuteJsValidator {
    constructor(fnName, params) {
        this.fnName = fnName;
        this.params = params;
    }
    validate() {
        const { code, ipfsId } = this.params;
        // -- validate: either 'code' or 'ipfsId' must exists
        if (!code && !ipfsId) {
            return (0, constants_1.ELeft)(new constants_1.ParamsMissingError({
                info: {
                    functionName: this.fnName,
                    params: this.params,
                },
            }, 'You must pass either code or ipfsId'));
        }
        // -- validate: 'code' and 'ipfsId' can't exists at the same time
        if (code && ipfsId) {
            return (0, constants_1.ELeft)(new constants_1.ParamsMissingError({
                info: {
                    functionName: this.fnName,
                    params: this.params,
                },
            }, "You cannot have both 'code' and 'ipfs' at the same time"));
        }
        return (0, constants_1.ERight)(undefined);
    }
}
class FileValidator {
    constructor(fnName, file) {
        this.fnName = fnName;
        this.file = file;
    }
    validate() {
        if (!this.file) {
            return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
                info: {
                    functionName: this.fnName,
                    file: this.file,
                },
            }, 'You must pass file param'));
        }
        const allowedTypes = ['Blob', 'File', 'Uint8Array'];
        if (!(0, misc_1.checkType)({
            value: this.file,
            allowedTypes,
            paramName: 'file',
            functionName: this.fnName,
        }))
            return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
                info: {
                    functionName: this.fnName,
                    file: this.file,
                    allowedTypes,
                },
            }, 'File param is not a valid Blob or File object'));
        return (0, constants_1.ERight)(undefined);
    }
}
class AuthMaterialValidator {
    constructor(fnName, params, checkIfAuthSigRequiresChainParam = false) {
        this.fnName = fnName;
        this.authMaterial = params;
        this.checkIfAuthSigRequiresChainParam = checkIfAuthSigRequiresChainParam;
    }
    validate() {
        const { authSig, sessionSigs } = this.authMaterial;
        if (authSig && !(0, misc_1.is)(authSig, 'Object', 'authSig', this.fnName))
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'authSig',
                    value: authSig,
                    functionName: this.fnName,
                },
            }, 'authSig is not an object'));
        if (this.checkIfAuthSigRequiresChainParam) {
            if (!this.authMaterial.chain)
                return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
                    info: {
                        functionName: this.fnName,
                        chain: this.authMaterial.chain,
                    },
                }, 'You must pass chain param'));
            if (authSig &&
                !(0, misc_1.checkIfAuthSigRequiresChainParam)(authSig, this.authMaterial.chain, this.fnName))
                return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                    info: {
                        param: 'authSig',
                        value: authSig,
                        functionName: this.fnName,
                    },
                }, 'authSig is not valid'));
        }
        if (sessionSigs && !(0, misc_1.is)(sessionSigs, 'Object', 'sessionSigs', this.fnName))
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'sessionSigs',
                    value: sessionSigs,
                    functionName: this.fnName,
                },
            }, 'sessionSigs is not an object'));
        if (!sessionSigs && !authSig)
            return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
                info: {
                    functionName: this.fnName,
                    sessionSigs,
                    authSig,
                },
            }, 'You must pass either authSig or sessionSigs'));
        // -- validate: if sessionSig and authSig exists
        if (sessionSigs && authSig)
            return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
                info: {
                    functionName: this.fnName,
                    sessionSigs,
                    authSig,
                },
            }, 'You cannot have both authSig and sessionSigs'));
        return (0, constants_1.ERight)(undefined);
    }
}
class AccessControlConditionsValidator {
    constructor(fnName, params) {
        this.fnName = fnName;
        this.conditions = params;
    }
    validate() {
        const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, } = this.conditions;
        if (accessControlConditions &&
            !(0, misc_1.is)(accessControlConditions, 'Array', 'accessControlConditions', this.fnName))
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'accessControlConditions',
                    value: accessControlConditions,
                    functionName: this.fnName,
                },
            }, '%s is not an array', 'accessControlConditions'));
        if (evmContractConditions &&
            !(0, misc_1.is)(evmContractConditions, 'Array', 'evmContractConditions', this.fnName))
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'evmContractConditions',
                    value: evmContractConditions,
                    functionName: this.fnName,
                },
            }, '%s is not an array', 'evmContractConditions'));
        if (solRpcConditions &&
            !(0, misc_1.is)(solRpcConditions, 'Array', 'solRpcConditions', this.fnName))
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'solRpcConditions',
                    value: solRpcConditions,
                    functionName: this.fnName,
                },
            }, '%s is not an array', 'solRpcConditions'));
        if (unifiedAccessControlConditions &&
            !(0, misc_1.is)(unifiedAccessControlConditions, 'Array', 'unifiedAccessControlConditions', this.fnName))
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'unifiedAccessControlConditions',
                    value: unifiedAccessControlConditions,
                    functionName: this.fnName,
                },
            }, '%s is not an array', 'unifiedAccessControlConditions'));
        if (!accessControlConditions &&
            !evmContractConditions &&
            !solRpcConditions &&
            !unifiedAccessControlConditions)
            return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
                info: {
                    functionName: this.fnName,
                    conditions: this.conditions,
                },
            }, 'You must pass either accessControlConditions, evmContractConditions, solRpcConditions or unifiedAccessControlConditions'));
        if (accessControlConditions &&
            !(0, utils_2.isValidBooleanExpression)(accessControlConditions))
            return (0, constants_1.ELeft)(new constants_1.InvalidBooleanException({
                info: {
                    functionName: this.fnName,
                    accessControlConditions,
                },
            }, 'Invalid boolean Access Control Conditions'));
        if (evmContractConditions &&
            !(0, utils_2.isValidBooleanExpression)(evmContractConditions))
            return (0, constants_1.ELeft)(new constants_1.InvalidBooleanException({
                info: {
                    functionName: this.fnName,
                    evmContractConditions,
                },
            }, 'Invalid boolean EVM Access Control Conditions'));
        if (solRpcConditions && !(0, utils_2.isValidBooleanExpression)(solRpcConditions))
            return (0, constants_1.ELeft)(new constants_1.InvalidBooleanException({
                info: {
                    functionName: this.fnName,
                    solRpcConditions,
                },
            }, 'Invalid boolean Solana Access Control Conditions'));
        if (unifiedAccessControlConditions &&
            !(0, utils_2.isValidBooleanExpression)(unifiedAccessControlConditions))
            return (0, constants_1.ELeft)(new constants_1.InvalidBooleanException({
                info: {
                    functionName: this.fnName,
                    unifiedAccessControlConditions,
                },
            }, 'Invalid boolean Unified Access Control Conditions'));
        return (0, constants_1.ERight)(undefined);
    }
}
//# sourceMappingURL=params-validators.js.map