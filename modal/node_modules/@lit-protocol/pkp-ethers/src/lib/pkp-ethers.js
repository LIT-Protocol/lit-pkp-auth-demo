"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PKPEthersWallet = void 0;
const address_1 = require("@ethersproject/address");
const bytes_1 = require("@ethersproject/bytes");
const hash_1 = require("@ethersproject/hash");
const hdnode_1 = require("@ethersproject/hdnode");
const json_wallets_1 = require("@ethersproject/json-wallets");
const keccak256_1 = require("@ethersproject/keccak256");
const logger_1 = require("@ethersproject/logger");
const properties_1 = require("@ethersproject/properties");
const random_1 = require("@ethersproject/random");
const transactions_1 = require("@ethersproject/transactions");
const ethers_1 = require("ethers");
const constants_1 = require("@lit-protocol/constants");
const pkp_base_1 = require("@lit-protocol/pkp-base");
const handler_1 = require("./handler");
const helper_1 = require("./helper");
const logger = new logger_1.Logger(ethers_1.version);
class PKPEthersWallet {
    get litNodeClientReady() {
        return this.pkpBase.litNodeClientReady;
    }
    constructor(prop) {
        this.getRpc = () => {
            return this.rpcProvider.connection.url;
        };
        this.setRpc = async (rpc) => {
            this.rpcProvider = new ethers_1.ethers.providers.StaticJsonRpcProvider({
                url: rpc,
                skipFetchSetup: true,
            });
        };
        this.handleRequest = async (payload) => {
            return await (0, handler_1.ethRequestHandler)({
                signer: this,
                payload,
            });
        };
        this.request = async (payload) => {
            return this.handleRequest(payload);
        };
        this.setGasPrice = (gasPrice) => {
            this.manualGasPrice = gasPrice;
        };
        this.setGasLimit = (gasLimit) => {
            this.manualGasLimit = gasLimit;
        };
        this.setNonce = (nonce) => {
            this.nonce = nonce;
        };
        this.setChainId = (chainId) => {
            this.chainId = chainId;
        };
        this.resetManualSettings = () => {
            this.manualGasPrice = undefined;
            this.manualGasLimit = undefined;
            this.nonce = undefined;
            this.chainId = undefined;
        };
        this.pkpBase = pkp_base_1.PKPBase.createInstance(prop);
        const rpcUrl = prop.rpc || constants_1.RPC_URL_BY_NETWORK[prop.litNodeClient.config.litNetwork];
        if (!rpcUrl) {
            throw new constants_1.InitError({
                info: {
                    rpcUrl,
                    network: prop.litNodeClient.config.litNetwork,
                },
            }, 'No RPC URL provided, and none could be found for the provided LitNodeClient');
        }
        this.rpcProvider = new ethers_1.ethers.providers.StaticJsonRpcProvider({
            url: rpcUrl,
            skipFetchSetup: true,
        });
        this.provider = prop.provider ?? this.rpcProvider;
        (0, properties_1.defineReadOnly)(this, '_isSigner', true);
        (0, properties_1.defineReadOnly)(this, 'address', (0, transactions_1.computeAddress)(this.pkpBase.uncompressedPubKeyBuffer));
    }
    get publicKey() {
        return this.pkpBase.uncompressedPubKey;
    }
    getAddress() {
        const addr = (0, transactions_1.computeAddress)(this.pkpBase.uncompressedPubKeyBuffer);
        return Promise.resolve(addr);
    }
    /**
     * Initializes the PKPEthersWallet instance and its dependencies
     */
    async init() {
        await this.pkpBase.init();
    }
    connect() {
        throw new constants_1.UnsupportedMethodError({
            info: {
                method: 'connect',
            },
        }, 'Use setRPC to set a new JSON RPC provider');
    }
    async signTransaction(transaction) {
        this.pkpBase.log('signTransaction => transaction:', transaction);
        // Check if the LIT node client is connected, and connect if it's not.
        await this.pkpBase.ensureLitNodeClientReady();
        const addr = await this.getAddress();
        this.pkpBase.log('signTransaction => addr:', addr);
        // if manual settings are set, use them
        if (this.manualGasPrice) {
            transaction.gasPrice = this.manualGasPrice;
        }
        if (this.manualGasLimit) {
            transaction.gasLimit = this.manualGasLimit;
        }
        if (this.nonce) {
            transaction.nonce = this.nonce;
        }
        if (this.chainId) {
            transaction.chainId = this.chainId;
        }
        try {
            if (!transaction['gasLimit']) {
                transaction.gasLimit = await this.rpcProvider.estimateGas(transaction);
                this.pkpBase.log('signTransaction => gasLimit:', transaction.gasLimit);
            }
            if (!transaction['nonce']) {
                transaction.nonce = await this.rpcProvider.getTransactionCount(addr);
                this.pkpBase.log('signTransaction => nonce:', transaction.nonce);
            }
            if (!transaction['chainId']) {
                transaction.chainId = (await this.rpcProvider.getNetwork()).chainId;
                this.pkpBase.log('signTransaction => chainId:', transaction.chainId);
            }
            if (!transaction['gasPrice']) {
                transaction.gasPrice = await this.getGasPrice();
                this.pkpBase.log('signTransaction => gasPrice:', transaction.gasPrice);
            }
        }
        catch (err) {
            this.pkpBase.log('signTransaction => unable to populate transaction with details:', err);
        }
        return (0, properties_1.resolveProperties)(transaction).then(async (tx) => {
            this.pkpBase.log('tx.from:', tx.from);
            this.pkpBase.log('this.address:', this.address);
            if (tx.from != null) {
                if ((0, address_1.getAddress)(tx.from) !== this.address) {
                    logger.throwArgumentError('transaction from address mismatch', 'transaction.from', transaction.from);
                }
                delete tx.from;
            }
            const serializedTx = (0, transactions_1.serialize)(tx);
            const unsignedTxn = (0, keccak256_1.keccak256)(serializedTx);
            // -- lit action --
            const toSign = (0, bytes_1.arrayify)(unsignedTxn);
            let signature;
            if (this.pkpBase.useAction) {
                this.pkpBase.log('running lit action => sigName: pkp-eth-sign-tx');
                signature = (await this.pkpBase.runLitAction(toSign, 'pkp-eth-sign-tx'))
                    .signature;
            }
            else {
                this.pkpBase.log('requesting signature from nodes');
                signature = (await this.pkpBase.runSign(toSign)).signature;
            }
            // -- reset manual settings --
            this.resetManualSettings();
            return (0, transactions_1.serialize)(tx, signature);
        });
    }
    async signMessage(message) {
        // Check if the LIT node client is connected, and connect if it's not.
        await this.pkpBase.ensureLitNodeClientReady();
        const toSign = (0, bytes_1.arrayify)((0, hash_1.hashMessage)(message));
        let signature;
        if (this.pkpBase.useAction) {
            this.pkpBase.log('running lit action => sigName: pkp-eth-sign-message');
            signature = await this.runLitAction(toSign, 'pkp-eth-sign-message');
        }
        else {
            this.pkpBase.log('requesting signature from nodes');
            signature = await this.runSign(toSign);
        }
        return (0, bytes_1.joinSignature)({
            r: '0x' + signature.r,
            s: '0x' + signature.s,
            v: signature.recid,
        });
    }
    async _signTypedData(domain, types, value) {
        // Check if the LIT node client is connected, and connect if it's not.
        await this.pkpBase.ensureLitNodeClientReady();
        // Populate any ENS names
        const populated = await hash_1._TypedDataEncoder.resolveNames(domain, types, value, 
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        (name) => {
            if (this.provider == null) {
                throw new constants_1.UnsupportedChainException({
                    info: {
                        operation: 'resolveName',
                        value: name,
                        domain,
                    },
                }, `cannot resolve ENS names without a provider`, Object.keys(constants_1.LIT_CHAINS));
            }
            return this.provider.resolveName(name);
        });
        // -- lit action --
        const toSign = hash_1._TypedDataEncoder.hash(populated.domain, types, populated.value);
        const toSignBuffer = (0, bytes_1.arrayify)(toSign);
        let signature;
        if (this.pkpBase.useAction) {
            this.pkpBase.log('running lit action => sigName: pkp-eth-sign-message');
            signature = await this.runLitAction(toSignBuffer, 'pkp-eth-sign-message');
        }
        else {
            this.pkpBase.log('requesting signature from nodes');
            signature = await this.runSign(toSignBuffer);
        }
        return (0, bytes_1.joinSignature)({
            r: '0x' + signature.r,
            s: '0x' + signature.s,
            v: signature.recid,
        });
    }
    encrypt(password, options, progressCallback) {
        if (typeof options === 'function' && !progressCallback) {
            progressCallback = options;
            options = {};
        }
        if (progressCallback && typeof progressCallback !== 'function') {
            throw new constants_1.InvalidParamType({
                info: {
                    progressCallback,
                },
            }, 'invalid callback');
        }
        if (!options) {
            options = {};
        }
        return (0, json_wallets_1.encryptKeystore)(this, password, options, progressCallback);
    }
    async sendTransaction(transaction) {
        // : Promise<TransactionResponse>
        this.pkpBase.log('sendTransaction => transaction:', transaction);
        let res;
        let signedTxn;
        try {
            if (!(0, helper_1.isSignedTransaction)(transaction)) {
                const unsignedTxFormatted = (0, helper_1.getTransactionToSign)(transaction);
                signedTxn = await this.signTransaction(unsignedTxFormatted);
            }
            else {
                signedTxn = transaction;
            }
            res = await this.rpcProvider.sendTransaction(signedTxn);
        }
        catch (e) {
            throw new constants_1.UnknownError({
                info: {
                    transaction,
                },
                cause: e,
            }, 'could not send transaction');
        }
        return res;
    }
    /**
     *  Static methods to create Wallet instances.
     */
    static createRandom(options) {
        let entropy = (0, random_1.randomBytes)(16);
        if (!options) {
            options = {};
        }
        if (options.extraEntropy) {
            entropy = (0, bytes_1.arrayify)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, options.locale);
        return ethers_1.Wallet.fromMnemonic(mnemonic, options.path, options.locale);
    }
    static fromEncryptedJson(json, password, progressCallback) {
        return (0, json_wallets_1.decryptJsonWallet)(json, password, progressCallback).then((account) => {
            return new ethers_1.Wallet(account);
        });
    }
    static fromEncryptedJsonSync(json, password) {
        return new ethers_1.Wallet((0, json_wallets_1.decryptJsonWalletSync)(json, password));
    }
    static fromMnemonic(mnemonic, path, wordlist) {
        if (!path) {
            path = hdnode_1.defaultPath;
        }
        return new ethers_1.Wallet(
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        hdnode_1.HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
    }
    getBalance(blockTag) {
        return this.rpcProvider.getBalance(this.address, blockTag);
    }
    getTransactionCount(blockTag) {
        return this.rpcProvider.getTransactionCount(this.address, blockTag);
    }
    estimateGas(transaction) {
        return this.rpcProvider.estimateGas(transaction);
    }
    async call(transaction, blockTag = 'latest') {
        return this.rpcProvider.call(transaction, blockTag);
    }
    async getChainId() {
        return (await this.rpcProvider.getNetwork()).chainId;
    }
    getGasPrice() {
        return this.rpcProvider.getGasPrice();
    }
    getFeeData() {
        return this.rpcProvider.getFeeData();
    }
    resolveName() {
        throw new constants_1.UnsupportedMethodError({
            info: {
                method: 'resolveName',
            },
        }, 'resolveName is not available in PKPEthersWallet');
    }
    checkTransaction() {
        throw new constants_1.UnsupportedMethodError({
            info: {
                method: 'checkTransaction',
            },
        }, 'checkTransaction is not available in PKPEthersWallet');
    }
    populateTransaction() {
        throw new constants_1.UnsupportedMethodError({
            info: {
                method: 'populateTransaction',
            },
        }, 'populateTransaction is not available in PKPEthersWallet');
    }
    _checkProvider() {
        this.pkpBase.log('This function is not implemented yet, but will skip it for now.');
    }
    get mnemonic() {
        throw new constants_1.UnsupportedMethodError({
            info: {
                method: 'mnemonic',
            },
        }, "There's no mnemonic for a PKPWallet");
    }
    get privateKey() {
        throw new constants_1.UnsupportedMethodError({
            info: {
                method: 'privateKey',
            },
        }, 'This PKP contains no private key (can you imagine!?)');
    }
    /**
     * Runs the specified Lit action with the given parameters.
     *
     * @param {Uint8Array} toSign - The data to be signed by the Lit action.
     * @param {string} sigName - The name of the signature to be returned by the Lit action.
     *
     * @returns {Promise<any>} - A Promise that resolves with the signature returned by the Lit action.
     *
     * @throws {Error} - Throws an error if `pkpPubKey` is not provided, if `controllerAuthSig` or `controllerSessionSigs` is not provided, if `controllerSessionSigs` is not an object, if `executeJsArgs` does not have either `code` or `ipfsId`, or if an error occurs during the execution of the Lit action.
     */
    async runLitAction(toSign, sigName) {
        return this.pkpBase.runLitAction(toSign, sigName);
    }
    /**
     * Sign the provided data with the PKP private key.
     *
     * @param {Uint8Array} toSign - The data to be signed.
     *
     * @returns {Promise<any>} - A Promise that resolves with the signature of the provided data.
     *
     * @throws {Error} - Throws an error if `pkpPubKey` is not provided, if `controllerAuthSig` or `controllerSessionSigs` is not provided, if `controllerSessionSigs` is not an object, or if an error occurs during the signing process.
     */
    async runSign(toSign) {
        return this.pkpBase.runSign(toSign);
    }
}
exports.PKPEthersWallet = PKPEthersWallet;
//# sourceMappingURL=pkp-ethers.js.map