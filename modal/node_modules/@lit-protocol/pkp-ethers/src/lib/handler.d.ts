import { EIP712TypedData, ETHHandlerReq, ETHHandlerRes, ETHRequestHandler, ETHSignature, LitTypeDataSigner, UnknownETHMethod, ETHTxRes } from './pkp-ethers-types';
/**
 * Signs an EIP-712 typed data object or a JSON string representation of the typed data object.
 *
 * @param {LitTypeDataSigner} signer - An instance of a LitTypeDataSigner, which is used for signing the typed data.
 * @param {T | string} msgParams - An EIP-712 typed data object that extends EIP712TypedData, or a JSON string representation of the typed data object.
 * @returns {Promise<string>} A promise that resolves to the signature of the typed data object.
 *
 * @template T - A generic type that extends the EIP712TypedData interface.
 *
 * @example
 * const signer = ... // Instance of a LitTypeDataSigner
 * const msgParams = ... // EIP-712 typed data object or its JSON string representation
 * const signature = await signTypedData(signer, msgParams);
 */
export declare const signTypedData: <T extends EIP712TypedData>(signer: LitTypeDataSigner, msgParams: T | string) => Promise<ETHSignature>;
/**
 *  A utility function for signing EIP-712 typed data using an Ethereum wallet that does not support EIP-712.
 *  @template T - The type of the message parameters.
 *  @param {LitTypeDataSigner} signer - An Ethereum wallet signer that does not support EIP-712.
 *  @param {T | any} msgParams - The parameters of the EIP-712 message.
 *  @throws {Error} Throws an error if the runLitAction function is not found in the signer object.
 *  @returns {Promise<ETHSignature>} - The signature of the message.
 *  This function computes the message hash using the typedSignatureHash function from the eth-sig-util library. It then uses the runLitAction function of the signer object to sign the hash. The function returns the encoded signature.
 */
export declare const signTypedDataLegacy: <T>(signer: LitTypeDataSigner, msgParams: T | any) => Promise<ETHSignature>;
/**
 *  Validates if the signerAddress matches the requestAddress. The comparison is done in a case-insensitive manner.
 *  @param {string} signerAddress - The address of the signer.
 *  @param {string} requestAddress - The address of the requester.
 *  @throws {Error} Throws an error if the signerAddress does not match the requestAddress.
 *  @returns {void}
 *  This function can be used to ensure that the signer of a transaction is the same as the requester. It is useful in preventing unauthorized access to sensitive data or assets.
 *  Note: It is assumed that the addresses are in the correct format and have already been validated for length and character set.
 */
export declare const validateAddressesMatch: (signerAddress: string, requestAddress: string) => void;
/**
 * Validate the input signature by checking if it is null, undefined, or an empty string.
 * If the signature is invalid, it throws an error.
 *
 * @param {string} signature - The signature to validate.
 * @throws {Error} If the signature is null, undefined, or an empty string.
 */
export declare const validateSignature: (signature: string) => void;
/**
 * Returns an object with version info based on isAddress boolean value.
 * If true, returns version 3 or 4 data properties.
 * If false, returns version 1 data properties.
 * @param { ETHRequestSigningPayload } payload
 */
export declare function getTypedDataVersionInfo({ signer, payload }: ETHHandlerReq): {
    addressRequested: string;
    msgParams: any;
    info: {
        logMessage: string;
        addressIndex: number;
        msgParamsIndex: number;
        signTypedDataFn: <T extends EIP712TypedData>(signer: LitTypeDataSigner, msgParams: T | string) => Promise<ETHSignature>;
    };
};
/**
 *  An ETHRequestHandler function that signs EIP-712 typed data using an Ethereum wallet.
 *  @param {ETHHandlerReq} params - An object containing the signer and payload.
 *  @throws {Error} Throws an error if the signer or payload is not defined, or if the validation of the signer and requester addresses fails.
 *  @returns {Promise<ETHHandlerRes>} - An object containing the signature.
 *  This function validates the signer and payload, then determines the version of the EIP-712 message being signed. It then uses the appropriate method to sign the message and returns the signature. The function can handle both V1 and V3/V4 versions of EIP-712 messages.
 *  Note: It is assumed that the addresses are in the correct format and have already been validated for length and character set.
 */
export declare const signTypedDataHandler: ETHRequestHandler;
/**
 * Handles signing a transaction using the provided signer and payload.
 *
 * @param {object} params - The input parameters.
 * @param {Wallet} params.signer - The signer (PKPEthersWallet) to be used for signing the transaction.
 * @param {object} params.payload - The payload containing the transaction information.
 * @returns {Promise<ETHSignature>} - A promise that resolves to an ETHSignature object containing the signed transaction signature.
 *
 * @throws {Error} - If the address in the payload does not match the signer's address, or if the signature is invalid.
 */
export declare const signTransactionHandler: ({ signer, payload, }: ETHHandlerReq) => Promise<ETHSignature>;
/**
 * Handle sending a transaction by signing it with the provided signer.
 * Validate the address of the signer and the address requested from the transaction parameters.
 * If the signature is valid, it returns an object containing the signature.
 *
 * @param {ETHHandlerReq} { signer, payload } - The input object containing the signer and payload.
 * @returns {Promise<any>} A Promise that resolves to an object containing the signature.
 * @throws {Error} If the addresses do not match or if the signature is invalid.
 */
export declare const sendTransactionHandler: ({ signer, payload, }: ETHHandlerReq) => Promise<ETHTxRes>;
/**
 * Handle sending a raw transaction by signing it with the provided signer.
 * If the signature is valid, it returns an object containing the signature.
 *
 * @param {ETHHandlerReq} { signer, payload } - The input object containing the signer and payload.
 * @returns {Promise<ETHHandlerRes>} A Promise that resolves to an object containing the signature.
 * @throws {Error} If the signature is invalid.
 */
export declare const sendRawTransactionHandler: ({ signer, payload, }: ETHHandlerReq) => Promise<ETHHandlerRes>;
/**
 * Handle signing a message with the provided signer.
 * Validate the address of the signer and the address requested from the payload.
 * Convert the message from hex to UTF-8, if necessary, and sign it.
 * If the signature is valid, it returns an object containing the signature.
 *
 * @param {ETHHandlerReq} { signer, payload } - The input object containing the signer and payload.
 * @returns {Promise<ETHHandlerRes>} A Promise that resolves to an object containing the signature.
 * @throws {Error} If the addresses do not match or if the signature is invalid.
 */
export declare const signHandler: ({ signer, payload, }: ETHHandlerReq) => Promise<ETHHandlerRes>;
/**
 * Handle signing a message with the provided signer using the 'personal_sign' method.
 * Validate the address of the signer and the address requested from the payload.
 * Convert the message from hex to UTF-8, if necessary, and sign it.
 * If the signature is valid, it returns an object containing the signature.
 *
 * @param {ETHHandlerReq} { signer, payload } - The input object containing the signer and payload.
 * @returns {Promise<ETHHandlerRes>} A Promise that resolves to an object containing the signature.
 * @throws {Error} If the addresses do not match or if the signature is invalid.
 */
export declare const personalSignHandler: ({ signer, payload, capability, }: ETHHandlerReq) => Promise<ETHHandlerRes>;
/**
 * An object mapping Ethereum JSON-RPC signing methods to their respective
 * request handlers. The request handlers take an ETHHandlerReq object
 * as input and return a promise that resolves to the signature result.
 * Currently supported methods:
 * eth_signTypedData
 * @type {{ eth_signTypedData: ETHRequestHandler;} & UnknownETHMethod}
 */
export declare const methodHandlers: {
    eth_signTypedData: ETHRequestHandler;
    eth_signTypedData_v1: any;
} & UnknownETHMethod;
/**
 * Handles Ethereum JSON-RPC requests for the given method and payload.
 * Executes the appropriate signing function based on the method and
 * returns the signature or transaction response.
 * @param {ETHHandlerReq} { signer, payload } - Request object containing signer and payload data.
 * @returns {Promise<T>} - A Promise that resolves to the requested data type (ETHSignature or ETHTxRes).
 * @throws {Error} - Throws an error if the requested method is not supported or if there's an issue during execution.
 */
export declare const ethRequestHandler: <T = string>({ signer, payload, }: ETHHandlerReq) => Promise<T>;
export declare const isEthRequest: (method: string) => boolean;
