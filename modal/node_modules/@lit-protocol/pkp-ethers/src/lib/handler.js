"use strict";
//
// Integrated from https://github.com/LIT-Protocol/lit-pkp-sdk/blob/main/examples/signTypedData.mjs
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEthRequest = exports.ethRequestHandler = exports.methodHandlers = exports.personalSignHandler = exports.signHandler = exports.sendRawTransactionHandler = exports.sendTransactionHandler = exports.signTransactionHandler = exports.signTypedDataHandler = exports.validateSignature = exports.validateAddressesMatch = exports.signTypedDataLegacy = exports.signTypedData = void 0;
exports.getTypedDataVersionInfo = getTypedDataVersionInfo;
const bytes_1 = require("@ethersproject/bytes");
const eth_sig_util_1 = require("@metamask/eth-sig-util");
const constants_1 = require("@lit-protocol/constants");
const ethers_1 = require("ethers");
const helper_1 = require("./helper");
/**
 * Signs an EIP-712 typed data object or a JSON string representation of the typed data object.
 *
 * @param {LitTypeDataSigner} signer - An instance of a LitTypeDataSigner, which is used for signing the typed data.
 * @param {T | string} msgParams - An EIP-712 typed data object that extends EIP712TypedData, or a JSON string representation of the typed data object.
 * @returns {Promise<string>} A promise that resolves to the signature of the typed data object.
 *
 * @template T - A generic type that extends the EIP712TypedData interface.
 *
 * @example
 * const signer = ... // Instance of a LitTypeDataSigner
 * const msgParams = ... // EIP-712 typed data object or its JSON string representation
 * const signature = await signTypedData(signer, msgParams);
 */
const signTypedData = async (signer, msgParams) => {
    if (typeof msgParams === 'string') {
        msgParams = JSON.parse(msgParams);
    }
    const { types, domain, primaryType, message } = msgParams;
    if (types['EIP712Domain']) {
        delete types['EIP712Domain'];
    }
    const signature = await signer._signTypedData(domain, types, message);
    return signature;
};
exports.signTypedData = signTypedData;
/**
 *  A utility function for signing EIP-712 typed data using an Ethereum wallet that does not support EIP-712.
 *  @template T - The type of the message parameters.
 *  @param {LitTypeDataSigner} signer - An Ethereum wallet signer that does not support EIP-712.
 *  @param {T | any} msgParams - The parameters of the EIP-712 message.
 *  @throws {Error} Throws an error if the runLitAction function is not found in the signer object.
 *  @returns {Promise<ETHSignature>} - The signature of the message.
 *  This function computes the message hash using the typedSignatureHash function from the eth-sig-util library. It then uses the runLitAction function of the signer object to sign the hash. The function returns the encoded signature.
 */
const signTypedDataLegacy = async (signer, msgParams) => {
    // https://github.com/MetaMask/eth-sig-util/blob/9f01c9d7922b717ddda3aa894c38fbba623e8bdf/src/sign-typed-data.ts#L435
    const messageHash = (0, eth_sig_util_1.typedSignatureHash)(msgParams);
    let sig;
    if (signer.runLitAction) {
        const _signer = signer;
        sig = await _signer.runSign(ethers_1.ethers.utils.arrayify(messageHash));
    }
    else {
        throw new constants_1.InvalidArgumentException({
            info: {
                signer,
                msgParams,
            },
        }, 'Unabled to runLitAction. This signer is not a PKPEthersWallet');
        // let _signer = signer as Signer;
        // sig = await _signer.signMessage(messageHash);
    }
    const encodedSig = (0, bytes_1.joinSignature)({
        r: '0x' + sig.r,
        s: '0x' + sig.s,
        v: sig.recid,
    });
    return encodedSig;
};
exports.signTypedDataLegacy = signTypedDataLegacy;
/**
 *  Validates if the signerAddress matches the requestAddress. The comparison is done in a case-insensitive manner.
 *  @param {string} signerAddress - The address of the signer.
 *  @param {string} requestAddress - The address of the requester.
 *  @throws {Error} Throws an error if the signerAddress does not match the requestAddress.
 *  @returns {void}
 *  This function can be used to ensure that the signer of a transaction is the same as the requester. It is useful in preventing unauthorized access to sensitive data or assets.
 *  Note: It is assumed that the addresses are in the correct format and have already been validated for length and character set.
 */
const validateAddressesMatch = (signerAddress, requestAddress) => {
    if (signerAddress.toLowerCase() !== requestAddress.toLowerCase()) {
        throw new constants_1.UnauthorizedException({
            info: {
                signerAddress,
                requestAddress,
            },
        }, `PKPWallet address does not match address requested`);
    }
};
exports.validateAddressesMatch = validateAddressesMatch;
/**
 * Validate the input signature by checking if it is null, undefined, or an empty string.
 * If the signature is invalid, it throws an error.
 *
 * @param {string} signature - The signature to validate.
 * @throws {Error} If the signature is null, undefined, or an empty string.
 */
const validateSignature = (signature) => {
    if (signature === null || signature === undefined || signature === '') {
        throw new constants_1.InvalidParamType({
            info: {
                signature,
            },
        }, 'Signature is null or undefined');
    }
};
exports.validateSignature = validateSignature;
/**
 * Returns an object with version info based on isAddress boolean value.
 * If true, returns version 3 or 4 data properties.
 * If false, returns version 1 data properties.
 * @param { ETHRequestSigningPayload } payload
 */
function getTypedDataVersionInfo({ signer, payload }) {
    if (!payload.params[0]) {
        throw new constants_1.InvalidParamType({
            info: {
                payload,
            },
        }, 'signTypedDataHandler: payload.params[0] is not defined');
    }
    const ethersIsAddress = ethers_1.ethers.utils.isAddress(payload.params[0]);
    let info;
    if (ethersIsAddress) {
        info = {
            logMessage: 'RUNNING VERSION 3 or 4',
            addressIndex: 0,
            msgParamsIndex: 1,
            signTypedDataFn: exports.signTypedData,
        };
    }
    else {
        info = {
            logMessage: 'RUNNING VERSION 1',
            addressIndex: 1,
            msgParamsIndex: 0,
            signTypedDataFn: exports.signTypedDataLegacy,
        };
    }
    let addressRequested = payload.params[info.addressIndex];
    (0, exports.validateAddressesMatch)(signer.address, addressRequested);
    let msgParams = payload.params[info.msgParamsIndex];
    return { addressRequested, msgParams, info };
}
/**
 *  An ETHRequestHandler function that signs EIP-712 typed data using an Ethereum wallet.
 *  @param {ETHHandlerReq} params - An object containing the signer and payload.
 *  @throws {Error} Throws an error if the signer or payload is not defined, or if the validation of the signer and requester addresses fails.
 *  @returns {Promise<ETHHandlerRes>} - An object containing the signature.
 *  This function validates the signer and payload, then determines the version of the EIP-712 message being signed. It then uses the appropriate method to sign the message and returns the signature. The function can handle both V1 and V3/V4 versions of EIP-712 messages.
 *  Note: It is assumed that the addresses are in the correct format and have already been validated for length and character set.
 */
const signTypedDataHandler = async ({ signer, payload, }) => {
    // -- validate
    if (!signer || !payload) {
        throw new constants_1.ParamsMissingError({
            info: {
                signer,
                payload,
            },
        }, `signer or payload is not defined`);
    }
    const { msgParams, info } = getTypedDataVersionInfo({
        signer,
        payload,
    });
    const signature = await info.signTypedDataFn(signer, msgParams);
    (0, exports.validateSignature)(signature);
    return { signature };
};
exports.signTypedDataHandler = signTypedDataHandler;
/**
 * Handles signing a transaction using the provided signer and payload.
 *
 * @param {object} params - The input parameters.
 * @param {Wallet} params.signer - The signer (PKPEthersWallet) to be used for signing the transaction.
 * @param {object} params.payload - The payload containing the transaction information.
 * @returns {Promise<ETHSignature>} - A promise that resolves to an ETHSignature object containing the signed transaction signature.
 *
 * @throws {Error} - If the address in the payload does not match the signer's address, or if the signature is invalid.
 */
const signTransactionHandler = async ({ signer, payload, }) => {
    const unsignedTx = payload.params[0];
    const addressRequested = unsignedTx.from;
    const _signer = signer;
    (0, exports.validateAddressesMatch)(_signer.address, addressRequested);
    const unsignedTxFormatted = (0, helper_1.getTransactionToSign)(unsignedTx);
    const signedTxSignature = await _signer.signTransaction(unsignedTxFormatted);
    (0, exports.validateSignature)(signedTxSignature);
    return signedTxSignature;
};
exports.signTransactionHandler = signTransactionHandler;
/**
 * Handle sending a transaction by signing it with the provided signer.
 * Validate the address of the signer and the address requested from the transaction parameters.
 * If the signature is valid, it returns an object containing the signature.
 *
 * @param {ETHHandlerReq} { signer, payload } - The input object containing the signer and payload.
 * @returns {Promise<any>} A Promise that resolves to an object containing the signature.
 * @throws {Error} If the addresses do not match or if the signature is invalid.
 */
const sendTransactionHandler = async ({ signer, payload, }) => {
    const unsignedTx = payload.params[0];
    const addressRequested = unsignedTx.from;
    const _signer = signer;
    (0, exports.validateAddressesMatch)(_signer.address, addressRequested);
    const unsignedTxFormatted = (0, helper_1.getTransactionToSign)(unsignedTx);
    const signedTxSignature = await _signer.signTransaction(unsignedTxFormatted);
    (0, exports.validateSignature)(signedTxSignature);
    const txRes = await _signer.sendTransaction(signedTxSignature);
    return txRes;
};
exports.sendTransactionHandler = sendTransactionHandler;
/**
 * Handle sending a raw transaction by signing it with the provided signer.
 * If the signature is valid, it returns an object containing the signature.
 *
 * @param {ETHHandlerReq} { signer, payload } - The input object containing the signer and payload.
 * @returns {Promise<ETHHandlerRes>} A Promise that resolves to an object containing the signature.
 * @throws {Error} If the signature is invalid.
 */
const sendRawTransactionHandler = async ({ signer, payload, }) => {
    const tx = (0, helper_1.getTransactionToSign)(payload.params[0]);
    const signature = await signer.sendTransaction(tx);
    (0, exports.validateSignature)(signature);
    return { signature };
};
exports.sendRawTransactionHandler = sendRawTransactionHandler;
/**
 * Handle signing a message with the provided signer.
 * Validate the address of the signer and the address requested from the payload.
 * Convert the message from hex to UTF-8, if necessary, and sign it.
 * If the signature is valid, it returns an object containing the signature.
 *
 * @param {ETHHandlerReq} { signer, payload } - The input object containing the signer and payload.
 * @returns {Promise<ETHHandlerRes>} A Promise that resolves to an object containing the signature.
 * @throws {Error} If the addresses do not match or if the signature is invalid.
 */
const signHandler = async ({ signer, payload, }) => {
    const addressRequested = payload.params[0];
    (0, exports.validateAddressesMatch)(signer.address, addressRequested);
    const msg = (0, helper_1.convertHexToUtf8)(payload.params[1]);
    const signature = await signer.signMessage(msg);
    (0, exports.validateSignature)(signature);
    return { signature };
};
exports.signHandler = signHandler;
/**
 * Handle signing a message with the provided signer using the 'personal_sign' method.
 * Validate the address of the signer and the address requested from the payload.
 * Convert the message from hex to UTF-8, if necessary, and sign it.
 * If the signature is valid, it returns an object containing the signature.
 *
 * @param {ETHHandlerReq} { signer, payload } - The input object containing the signer and payload.
 * @returns {Promise<ETHHandlerRes>} A Promise that resolves to an object containing the signature.
 * @throws {Error} If the addresses do not match or if the signature is invalid.
 */
const personalSignHandler = async ({ signer, payload, capability, }) => {
    const addressRequested = payload.params[1];
    (0, exports.validateAddressesMatch)(signer.address, addressRequested);
    const msg = (0, helper_1.convertHexToUtf8)(payload.params[0]);
    // -- we will add capability to for resource
    if (capability) {
    }
    const signature = await signer.signMessage(msg);
    (0, exports.validateSignature)(signature);
    return { signature };
};
exports.personalSignHandler = personalSignHandler;
/**
 * An object mapping Ethereum JSON-RPC signing methods to their respective
 * request handlers. The request handlers take an ETHHandlerReq object
 * as input and return a promise that resolves to the signature result.
 * Currently supported methods:
 * eth_signTypedData
 * @type {{ eth_signTypedData: ETHRequestHandler;} & UnknownETHMethod}
 */
exports.methodHandlers = {
    // signing
    eth_sign: exports.signHandler,
    personal_sign: exports.personalSignHandler,
    // signing typed data - the handler will choose the correct version to use
    eth_signTypedData: exports.signTypedDataHandler,
    eth_signTypedData_v1: exports.signTypedDataHandler,
    eth_signTypedData_v3: exports.signTypedDataHandler,
    eth_signTypedData_v4: exports.signTypedDataHandler,
    // sign tx
    eth_signTransaction: exports.signTransactionHandler,
    // send tx
    eth_sendTransaction: exports.sendTransactionHandler,
    eth_sendRawTransaction: exports.sendRawTransactionHandler,
};
/**
 * Handles Ethereum JSON-RPC requests for the given method and payload.
 * Executes the appropriate signing function based on the method and
 * returns the signature or transaction response.
 * @param {ETHHandlerReq} { signer, payload } - Request object containing signer and payload data.
 * @returns {Promise<T>} - A Promise that resolves to the requested data type (ETHSignature or ETHTxRes).
 * @throws {Error} - Throws an error if the requested method is not supported or if there's an issue during execution.
 */
const ethRequestHandler = async ({ signer, payload, }) => {
    // -- validate if method exists
    if (!exports.methodHandlers.hasOwnProperty(payload.method)) {
        throw new constants_1.UnsupportedMethodError({
            info: {
                payload,
                signer,
            },
        }, `Ethereum JSON-RPC signing method "${payload.method}" is not supported`);
    }
    // -- run found function
    const fn = exports.methodHandlers[payload.method];
    try {
        const data = await fn({ signer, payload });
        if (data['signature']) {
            return data.signature;
        }
        if (data['txRes']) {
            await data.txRes.wait();
            return data.txRes;
        }
        return data;
    }
    catch (e) {
        throw new constants_1.UnknownError({
            info: {
                payload,
                signer,
            },
            cause: e,
        }, 'Something went wrong when handling Ethereum JSON-RPC requests for the given method and payload');
    }
};
exports.ethRequestHandler = ethRequestHandler;
const isEthRequest = (method) => {
    return exports.methodHandlers.hasOwnProperty(method);
};
exports.isEthRequest = isEthRequest;
//# sourceMappingURL=handler.js.map