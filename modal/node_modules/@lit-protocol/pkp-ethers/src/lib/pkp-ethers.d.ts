import { Provider, TransactionRequest } from '@ethersproject/abstract-provider';
import { ExternallyOwnedAccount, Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from '@ethersproject/abstract-signer';
import { Bytes } from '@ethersproject/bytes';
import { EncryptOptions, ProgressCallback } from '@ethersproject/json-wallets';
import { Wordlist } from '@ethersproject/wordlists';
import { ethers, Wallet } from 'ethers';
import { PKPClientHelpers, PKPEthersWalletProp, PKPWallet, SigResponse } from '@lit-protocol/types';
import { ETHRequestSigningPayload } from './pkp-ethers-types';
export declare class PKPEthersWallet implements PKPWallet, Signer, ExternallyOwnedAccount, TypedDataSigner, PKPClientHelpers {
    private readonly pkpBase;
    readonly address: string;
    readonly _isSigner: boolean;
    rpcProvider: ethers.providers.StaticJsonRpcProvider;
    provider: Provider;
    manualGasPrice?: string;
    manualGasLimit?: string;
    nonce?: string;
    chainId?: number;
    get litNodeClientReady(): boolean;
    constructor(prop: PKPEthersWalletProp);
    getRpc: () => string;
    setRpc: (rpc: string) => Promise<void>;
    handleRequest: <T = string | ethers.Transaction>(payload: ETHRequestSigningPayload) => Promise<T>;
    request: <T = string | ethers.Transaction>(payload: ETHRequestSigningPayload) => Promise<T>;
    setGasPrice: (gasPrice: string) => void;
    setGasLimit: (gasLimit: string) => void;
    setNonce: (nonce: string) => void;
    setChainId: (chainId: number) => void;
    resetManualSettings: () => void;
    get publicKey(): string;
    getAddress(): Promise<string>;
    /**
     * Initializes the PKPEthersWallet instance and its dependencies
     */
    init(): Promise<void>;
    connect(): never;
    signTransaction(transaction: TransactionRequest): Promise<string>;
    signMessage(message: Bytes | string): Promise<string>;
    _signTypedData(domain: TypedDataDomain, types: Record<string, TypedDataField[]>, value: Record<string, any>): Promise<string>;
    encrypt(password: Bytes | string, options?: EncryptOptions | ProgressCallback, progressCallback?: ProgressCallback): Promise<string>;
    sendTransaction(transaction: TransactionRequest | any): Promise<any>;
    /**
     *  Static methods to create Wallet instances.
     */
    static createRandom(options?: {
        extraEntropy?: Uint8Array;
        locale?: Wordlist;
        path?: string;
    }): Wallet;
    static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet>;
    static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet;
    static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet;
    getBalance(blockTag?: ethers.providers.BlockTag | undefined): Promise<ethers.BigNumber>;
    getTransactionCount(blockTag?: ethers.providers.BlockTag | undefined): Promise<number>;
    estimateGas(transaction: ethers.utils.Deferrable<TransactionRequest>): Promise<ethers.BigNumber>;
    call(transaction: ethers.utils.Deferrable<TransactionRequest>, blockTag?: ethers.providers.BlockTag | Promise<ethers.providers.BlockTag>): Promise<string>;
    getChainId(): Promise<number>;
    getGasPrice(): Promise<ethers.BigNumber>;
    getFeeData(): Promise<ethers.providers.FeeData>;
    resolveName(): never;
    checkTransaction(): never;
    populateTransaction(): never;
    _checkProvider(): void;
    get mnemonic(): never;
    get privateKey(): never;
    /**
     * Runs the specified Lit action with the given parameters.
     *
     * @param {Uint8Array} toSign - The data to be signed by the Lit action.
     * @param {string} sigName - The name of the signature to be returned by the Lit action.
     *
     * @returns {Promise<any>} - A Promise that resolves with the signature returned by the Lit action.
     *
     * @throws {Error} - Throws an error if `pkpPubKey` is not provided, if `controllerAuthSig` or `controllerSessionSigs` is not provided, if `controllerSessionSigs` is not an object, if `executeJsArgs` does not have either `code` or `ipfsId`, or if an error occurs during the execution of the Lit action.
     */
    runLitAction(toSign: Uint8Array, sigName: string): Promise<any>;
    /**
     * Sign the provided data with the PKP private key.
     *
     * @param {Uint8Array} toSign - The data to be signed.
     *
     * @returns {Promise<any>} - A Promise that resolves with the signature of the provided data.
     *
     * @throws {Error} - Throws an error if `pkpPubKey` is not provided, if `controllerAuthSig` or `controllerSessionSigs` is not provided, if `controllerSessionSigs` is not an object, or if an error occurs during the signing process.
     */
    runSign(toSign: Uint8Array): Promise<SigResponse>;
}
