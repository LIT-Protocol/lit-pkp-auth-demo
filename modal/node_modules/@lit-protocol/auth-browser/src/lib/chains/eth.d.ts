import { Web3Provider, JsonRpcSigner } from '@ethersproject/providers';
import { ethers } from 'ethers';
import { IEither } from '@lit-protocol/constants';
import { AuthSig, AuthCallbackParams } from '@lit-protocol/types';
/** ---------- Local Interfaces ---------- */
interface ConnectWeb3 {
    chainId: number;
    walletConnectProjectId?: string;
}
interface ConnectWeb3Result {
    web3: Web3Provider | any;
    account: string | any;
}
type RPCUrls = Record<string, string>;
interface signAndSaveAuthParams {
    web3: Web3Provider;
    account: string;
    chainId: number;
    resources: any;
    expiration: string;
    uri?: string;
    nonce: string;
}
interface IABI {
    inputs: any[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
}
interface IABIEncode {
    abi: IABI[];
    functionName: string;
    functionParams: [];
}
interface IABIDecode {
    abi: IABI[];
    functionName: string;
    data: any;
}
interface SignMessageParams {
    body: string;
    web3: Web3Provider;
    account: string;
}
interface SignedMessage {
    signature: string;
    address: string;
}
declare const WALLET_ERROR: {
    readonly REQUESTED_CHAIN_HAS_NOT_BEEN_ADDED: 4902;
    readonly NO_SUCH_METHOD: -32601;
};
export type WALLET_ERROR_TYPE = keyof typeof WALLET_ERROR;
export type WALLET_ERROR_VALUES = (typeof WALLET_ERROR)[keyof typeof WALLET_ERROR];
/**
 *
 * Convert chain hex id to chain name
 *
 * @param { string } chainHexId
 * @returns { void | string }
 */
export declare const chainHexIdToChainName: (chainHexId: string) => void | string;
/**
 * Get chain id of the current network
 * @param { string } chain
 * @param { Web3Provider } web3
 * @returns { Promise<IEither> }
 */
export declare const getChainId: (chain: string, web3: Web3Provider) => Promise<IEither<number>>;
/**
 * Check if the Expiration Time in the signedMessage string is expired.
 * @param { string } signedMessage - The signed message containing the Expiration Time.
 * @returns true if expired, false otherwise.
 */
export declare function isSignedMessageExpired(signedMessage: string): boolean;
/**
 *
 * Check if the message must resign
 *
 * @param { AuthSig } authSig
 * @param { any } resources
 *
 * @returns { boolean }
 */
export declare const getMustResign: (authSig: AuthSig, resources: any) => boolean;
/**
 *
 * Get RPC Urls in the correct format
 * need to make it look like this:
   ---
   rpc: {
        1: "https://mainnet.mycustomnode.com",
        3: "https://ropsten.mycustomnode.com",
        100: "https://dai.poa.network",
        // ...
    },
   ---
 *
 * @returns
 */
export declare const getRPCUrls: () => RPCUrls;
/** ---------- Exports ---------- */
/**
 * @deprecated
 * encodeCallData has been removed.
 *
 * @param { IABIEncode }
 * @returns { string }
 */
export declare const encodeCallData: ({ abi, functionName, functionParams }: IABIEncode) => string;
/**
 * @deprecated
 * (ABI) Decode call data
 *
 * @param { IABIDecode }
 * @returns { string }
 */
export declare const decodeCallResult: ({ abi, functionName, data }: IABIDecode) => ethers.utils.Result;
/**
 * @browserOnly
 * Connect to web 3
 *
 * @param { ConnectWeb3 }
 *
 * @return { Promise<ConnectWeb3Result> } web3, account
 */
export declare const connectWeb3: ({ chainId, walletConnectProjectId, }: ConnectWeb3) => Promise<ConnectWeb3Result>;
/**
 * @browserOnly
 * Delete any saved AuthSigs from local storage. Takes no params and returns
 * nothing. This will also clear out the WalletConnect cache in local storage.
 * We often run this function as a result of the user pressing a "Logout" button.
 *
 * @return { void }
 */
export declare const disconnectWeb3: () => void;
/**
 * @browserOnly
 * Check and sign EVM auth message
 *
 * @param { CheckAndSignAuthParams }
 * @returns
 */
export declare const checkAndSignEVMAuthMessage: ({ chain, resources, switchChain, expiration, uri, walletConnectProjectId, nonce, }: AuthCallbackParams) => Promise<AuthSig>;
/**
 * @browserOnly
 * Sign the auth message with the user's wallet, and store it in localStorage.
 * Called by checkAndSignAuthMessage if the user does not have a signature stored.
 *
 * @param { signAndSaveAuthParams }
 * @returns { AuthSig }
 */
export declare const signAndSaveAuthMessage: ({ web3, account, chainId, resources, expiration, uri, nonce, }: signAndSaveAuthParams) => Promise<AuthSig>;
/**
 * @browserOnly
 * Sign Messags
 *
 * @param { SignMessageParams }
 *
 * @returns { Promise<SignedMessage> }
 */
export declare const signMessage: ({ body, web3, account, }: SignMessageParams) => Promise<SignedMessage>;
/**
 * @browserOnly
 * wrapper around signMessage that tries personal_sign first.  this is to fix a
 * bug with walletconnect where just using signMessage was failing
 *
 * @param { any | JsonRpcProvider} signer
 * @param { string } address
 * @param { string } message
 *
 * @returns { Promise<any | JsonRpcSigner> }
 */
export declare const signMessageAsync: (signer: any | JsonRpcSigner, address: string, message: string) => Promise<any | JsonRpcSigner>;
export {};
/**
 *
 * Get the number of decimal places in a token
 *
 * @property { string } contractAddress The token contract address
 * @property { string } chain The chain on which the token is deployed
 *
 * @returns { number } The number of decimal places in the token
 */
