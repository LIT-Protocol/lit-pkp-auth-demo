"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAndSignAuthMessage = void 0;
/**
 * FIXME: SessionSigs are only supported for EVM chains at the moment.  This will be expanded to other chains in the future.
 */
const constants_1 = require("@lit-protocol/constants");
const cosmos_1 = require("./chains/cosmos");
const eth_1 = require("./chains/eth");
const sol_1 = require("./chains/sol");
/**
 * SUPPORTED CHAINS: EVM, Solana, Cosmos
 *
 * !! NOTE !!
 * This function is purely used for crafting the authSig for access control conditions & decryption. For SessionSigs, you can pass the `authSig` as `jsParams`
 * or Eth Wallet Auth Method for `signSessionKey` and claiming, but you won't be able to use this to add resource ability requests in the SIWE message. Instead, you should provide your own signer to the authNeededCallback parameter for the getSessionSigs method.
 *
 * Check for an existing cryptographic authentication signature and create one of it does not exist.  This is used to prove ownership of a given crypto wallet address to the Lit nodes.  The result is stored in LocalStorage so the user doesn't have to sign every time they perform an operation.
 *
 * @param { AuthCallbackParams }
 *
 *  @returns { AuthSig } The AuthSig created or retrieved
 */
const checkAndSignAuthMessage = ({ chain, resources, switchChain, expiration, uri, cosmosWalletType, walletConnectProjectId, nonce, }) => {
    const chainInfo = constants_1.ALL_LIT_CHAINS[chain];
    // -- validate: if chain info not found
    if (!chainInfo) {
        throw new constants_1.UnsupportedChainException({
            info: {
                chain,
            },
        }, `Unsupported chain selected.  Please select one of: %s`, Object.keys(constants_1.ALL_LIT_CHAINS));
    }
    if (!expiration) {
        // set default of 1 week
        expiration = new Date(Date.now() + 1000 * 60 * 60 * 24 * 7).toISOString();
    }
    // -- check and sign auth message based on chain
    if (chainInfo.vmType === constants_1.VMTYPE.EVM) {
        return (0, eth_1.checkAndSignEVMAuthMessage)({
            chain,
            resources,
            switchChain,
            expiration,
            uri,
            walletConnectProjectId,
            nonce,
        });
    }
    else if (chainInfo.vmType === constants_1.VMTYPE.SVM) {
        return (0, sol_1.checkAndSignSolAuthMessage)();
    }
    else if (chainInfo.vmType === constants_1.VMTYPE.CVM) {
        return (0, cosmos_1.checkAndSignCosmosAuthMessage)({
            chain,
            walletType: cosmosWalletType || 'keplr',
        }); // Keplr is defaulted here, being the Cosmos wallet with the highest market share
    }
    // Else, throw an error
    throw new constants_1.UnsupportedChainException({
        info: {
            chain,
        },
    }, `vmType not found for this chain: %s. This should not happen. Unsupported chain selected. Please select one of: %s`, chain, Object.keys(constants_1.ALL_LIT_CHAINS));
};
exports.checkAndSignAuthMessage = checkAndSignAuthMessage;
//# sourceMappingURL=auth-browser.js.map