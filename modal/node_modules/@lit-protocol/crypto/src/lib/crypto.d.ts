import { LIT_CURVE_VALUES } from '@lit-protocol/constants';
import { CombinedECDSASignature, NodeAttestation, SessionKeyPair, SigShare } from '@lit-protocol/types';
export interface BlsSignatureShare {
    ProofOfPossession: string;
}
/**
 * Encrypt data with a BLS public key.
 * We are using G1 for encryption and G2 for signatures
 *
 * @param publicKeyHex hex-encoded string of the BLS public key to encrypt with
 * @param message Uint8Array of the data to encrypt
 * @param identity Uint8Array of the identity parameter used during encryption
 * @returns base64 encoded string of the ciphertext
 */
export declare const encrypt: (publicKeyHex: string, message: Uint8Array, identity: Uint8Array) => Promise<string>;
/**
 * Decrypt ciphertext using BLS signature shares.
 *
 * @param ciphertextBase64 base64-encoded string of the ciphertext to decrypt
 * @param shares hex-encoded array of the BLS signature shares
 * @returns Uint8Array of the decrypted data
 */
export declare const decryptWithSignatureShares: (ciphertextBase64: string, shares: BlsSignatureShare[]) => Promise<Uint8Array>;
/**
 * Verify and decrypt ciphertext using BLS signature shares.
 *
 * @param publicKeyHex hex-encoded string of the BLS public key to verify with
 * @param identity Uint8Array of the identity parameter used during encryption
 * @param ciphertextBase64 base64-encoded string of the ciphertext to decrypt
 * @param shares hex-encoded array of the BLS signature shares
 * @returns base64-encoded string of the decrypted data
 */
export declare const verifyAndDecryptWithSignatureShares: (publicKeyHex: string, identity: Uint8Array, ciphertextBase64: string, shares: BlsSignatureShare[]) => Promise<Uint8Array>;
/**
 * Combine BLS signature shares.
 *
 * @param shares hex-encoded array of the BLS signature shares
 * @returns hex-encoded string of the combined signature
 */
export declare const combineSignatureShares: (shares: BlsSignatureShare[]) => Promise<string>;
/**
 * Verify the BLS network signature.
 *
 * @param publicKeyHex hex-encoded string of the BLS public key to verify with.
 * @param message Uint8Array of the message to verify.
 * @param signature Uint8Array of the signature to verify.
 */
export declare const verifySignature: (publicKeyHex: string, message: Uint8Array, signature: Uint8Array) => Promise<void>;
/**
 *
 * Combine ECDSA Shares
 *
 * @param { Array<SigShare> } sigShares
 *
 * @returns { any }
 *
 */
export declare const combineEcdsaShares: (sigShares: SigShare[]) => Promise<CombinedECDSASignature>;
export declare const computeHDPubKey: (pubkeys: string[], keyId: string, sigType: LIT_CURVE_VALUES) => Promise<string>;
/**
 *
 * Generate a session key pair
 *
 * @returns { SessionKeyPair } sessionKeyPair
 */
export declare const generateSessionKeyPair: () => SessionKeyPair;
/**
 *
 * Check the attestation against AMD certs
 *
 * @param { NodeAttestation } attestation The actual attestation object, which includes the signature and report
 * @param { string } challengeHex The challenge we sent
 * @param { string } url The URL we talked to
 *
 * @returns { Promise<undefined> } A promise that throws if the attestation is invalid
 */
export declare const checkSevSnpAttestation: (attestation: NodeAttestation, challengeHex: string, url: string) => Promise<void>;
declare global {
    var LitNodeClient: any;
}
