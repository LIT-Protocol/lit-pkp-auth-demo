"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkSevSnpAttestation = exports.generateSessionKeyPair = exports.computeHDPubKey = exports.combineEcdsaShares = exports.verifySignature = exports.combineSignatureShares = exports.verifyAndDecryptWithSignatureShares = exports.decryptWithSignatureShares = exports.encrypt = void 0;
const utils_1 = require("ethers/lib/utils");
const constants_1 = require("@lit-protocol/constants");
const misc_1 = require("@lit-protocol/misc");
const nacl_1 = require("@lit-protocol/nacl");
const uint8arrays_1 = require("@lit-protocol/uint8arrays");
const wasm_1 = require("@lit-protocol/wasm");
/** ---------- Exports ---------- */
const LIT_CORS_PROXY = `https://cors.litgateway.com`;
/**
 * Encrypt data with a BLS public key.
 * We are using G1 for encryption and G2 for signatures
 *
 * @param publicKeyHex hex-encoded string of the BLS public key to encrypt with
 * @param message Uint8Array of the data to encrypt
 * @param identity Uint8Array of the identity parameter used during encryption
 * @returns base64 encoded string of the ciphertext
 */
const encrypt = async (publicKeyHex, message, identity) => {
    const publicKey = Buffer.from(publicKeyHex, 'hex');
    /**
     * Our system uses BLS12-381 on the G1 curve for encryption.
     * However, on the SDK side (this function), we expect the public key
     * to use the G2 curve for signature purposes, hence the switch on public key length.
     *
     * The G2 curve, `Bls12381G2`, is typically associated with signature generation/verification,
     * while G1 is associated with encryption. Here, the length of the public key determines how
     * we handle the encryption and the format of the returned encrypted message.
     */
    if (publicKeyHex.replace('0x', '').length !== 96) {
        throw new constants_1.InvalidParamType({
            info: {
                publicKeyHex,
            },
        }, `Invalid public key length. Expecting 96 characters, got ${publicKeyHex.replace('0x', '').length} instead.`);
    }
    return Buffer.from(await (0, wasm_1.blsEncrypt)('Bls12381G2', publicKey, message, identity)).toString('base64');
};
exports.encrypt = encrypt;
/**
 * Decrypt ciphertext using BLS signature shares.
 *
 * @param ciphertextBase64 base64-encoded string of the ciphertext to decrypt
 * @param shares hex-encoded array of the BLS signature shares
 * @returns Uint8Array of the decrypted data
 */
const decryptWithSignatureShares = async (ciphertextBase64, shares) => {
    const signature = await doCombineSignatureShares(shares);
    return doDecrypt(ciphertextBase64, signature);
};
exports.decryptWithSignatureShares = decryptWithSignatureShares;
/**
 * Verify and decrypt ciphertext using BLS signature shares.
 *
 * @param publicKeyHex hex-encoded string of the BLS public key to verify with
 * @param identity Uint8Array of the identity parameter used during encryption
 * @param ciphertextBase64 base64-encoded string of the ciphertext to decrypt
 * @param shares hex-encoded array of the BLS signature shares
 * @returns base64-encoded string of the decrypted data
 */
const verifyAndDecryptWithSignatureShares = async (publicKeyHex, identity, ciphertextBase64, shares) => {
    const publicKey = Buffer.from(publicKeyHex, 'hex');
    const signature = await doCombineSignatureShares(shares);
    await (0, wasm_1.blsVerify)('Bls12381G2', publicKey, identity, signature);
    return doDecrypt(ciphertextBase64, signature);
};
exports.verifyAndDecryptWithSignatureShares = verifyAndDecryptWithSignatureShares;
/**
 * Combine BLS signature shares.
 *
 * @param shares hex-encoded array of the BLS signature shares
 * @returns hex-encoded string of the combined signature
 */
const combineSignatureShares = async (shares) => {
    const signature = await doCombineSignatureShares(shares);
    return Buffer.from(signature).toString('hex');
};
exports.combineSignatureShares = combineSignatureShares;
/**
 * Verify the BLS network signature.
 *
 * @param publicKeyHex hex-encoded string of the BLS public key to verify with.
 * @param message Uint8Array of the message to verify.
 * @param signature Uint8Array of the signature to verify.
 */
const verifySignature = async (publicKeyHex, message, signature) => {
    const publicKey = Buffer.from(publicKeyHex, 'hex');
    await (0, wasm_1.blsVerify)('Bls12381G2', publicKey, message, signature);
};
exports.verifySignature = verifySignature;
// export interface EcdsaSignatureShare {
//   sigType: SIGTYPE;
//   signatureShare: string;
//   shareIndex: number; // ignored
//   publicKey: string;
//   dataSigned: string;
//   bigR: string;
//   sigName: string; // ignored
// }
const ecdsaSigntureTypeMap = {
    [constants_1.LIT_CURVE.EcdsaCaitSith]: 'K256',
    [constants_1.LIT_CURVE.EcdsaK256]: 'K256',
    [constants_1.LIT_CURVE.EcdsaCAITSITHP256]: 'P256',
};
/**
 *
 * Combine ECDSA Shares
 *
 * @param { Array<SigShare> } sigShares
 *
 * @returns { any }
 *
 */
const combineEcdsaShares = async (sigShares) => {
    const validShares = sigShares.filter((share) => share.signatureShare);
    const anyValidShare = validShares[0];
    if (!anyValidShare) {
        throw new constants_1.NoValidShares({
            info: {
                shares: sigShares,
            },
        }, 'No valid shares to combine');
    }
    const variant = ecdsaSigntureTypeMap[anyValidShare.sigType];
    const presignature = Buffer.from(anyValidShare.bigR, 'hex');
    const signatureShares = validShares.map((share) => Buffer.from(share.signatureShare, 'hex'));
    const [r, s, recId] = await (0, wasm_1.ecdsaCombine)(variant, presignature, signatureShares);
    const publicKey = Buffer.from(anyValidShare.publicKey, 'hex');
    const messageHash = Buffer.from(anyValidShare.dataSigned, 'hex');
    await (0, wasm_1.ecdsaVerify)(variant, messageHash, publicKey, [r, s, recId]);
    const signature = (0, utils_1.splitSignature)(Buffer.concat([r, s, Buffer.from([recId + 27])]));
    return {
        r: signature.r.slice('0x'.length),
        s: signature.s.slice('0x'.length),
        recid: signature.recoveryParam,
    };
};
exports.combineEcdsaShares = combineEcdsaShares;
const computeHDPubKey = async (pubkeys, keyId, sigType) => {
    const variant = ecdsaSigntureTypeMap[sigType];
    switch (sigType) {
        case constants_1.LIT_CURVE.EcdsaCaitSith:
        case constants_1.LIT_CURVE.EcdsaK256:
            // a bit of pre processing to remove characters which will cause our wasm module to reject the values.
            pubkeys = pubkeys.map((value) => {
                return value.replace('0x', '');
            });
            keyId = keyId.replace('0x', '');
            const preComputedPubkey = await (0, wasm_1.ecdsaDeriveKey)(variant, Buffer.from(keyId, 'hex'), pubkeys.map((hex) => Buffer.from(hex, 'hex')));
            return Buffer.from(preComputedPubkey).toString('hex');
        default:
            throw new constants_1.InvalidParamType({
                info: {
                    sigType,
                },
            }, `Non supported signature type`);
    }
};
exports.computeHDPubKey = computeHDPubKey;
/**
 *
 * Generate a session key pair
 *
 * @returns { SessionKeyPair } sessionKeyPair
 */
const generateSessionKeyPair = () => {
    const keyPair = nacl_1.nacl.sign.keyPair();
    const sessionKeyPair = {
        publicKey: (0, uint8arrays_1.uint8arrayToString)(keyPair.publicKey, 'base16'),
        secretKey: (0, uint8arrays_1.uint8arrayToString)(keyPair.secretKey, 'base16'),
    };
    return sessionKeyPair;
};
exports.generateSessionKeyPair = generateSessionKeyPair;
function doDecrypt(ciphertextBase64, signature) {
    console.log('signature from encrypt op: ', signature);
    const ciphertext = Buffer.from(ciphertextBase64, 'base64');
    return (0, wasm_1.blsDecrypt)('Bls12381G2', ciphertext, signature);
}
function doCombineSignatureShares(shares) {
    const sigShares = shares.map((s) => Buffer.from(s.ProofOfPossession, 'hex'));
    const signature = (0, wasm_1.blsCombine)('Bls12381G2', sigShares);
    return signature;
}
/**
 * Asynchronously fetches an AMD certification from a specified URL using a CORS proxy.
 * The primary purpose of using a CORS proxy is to avoid being rate-limited by AMD.
 * The function attempts to fetch the AMD cert through a proxy, and if the proxy fetch fails,
 * it retries directly from the original URL.
 *
 * Note: This project is hosted on heroku and uses this codebase: https://github.com/LIT-Protocol/cors-proxy-amd
 *
 * @param url The URL from which to fetch the AMD cert.
 * @returns A Promise that resolves to a Uint8Array containing the AMD certification data.
 * @throws An error detailing HTTP or network issues encountered during the fetch process.
 */
async function getAmdCert(url) {
    const proxyUrl = `${LIT_CORS_PROXY}/${url}`;
    (0, misc_1.log)(`[getAmdCert] Fetching AMD cert using proxy URL ${proxyUrl} to manage CORS restrictions and to avoid being rate limited by AMD.`);
    async function fetchAsUint8Array(targetUrl) {
        const res = await fetch(targetUrl);
        if (!res.ok) {
            throw new constants_1.NetworkError({
                info: {
                    targetUrl,
                },
            }, `[getAmdCert] HTTP error! status: ${res.status}`);
        }
        const arrayBuffer = await res.arrayBuffer();
        return new Uint8Array(arrayBuffer);
    }
    try {
        return await fetchAsUint8Array(proxyUrl);
    }
    catch (e) {
        (0, misc_1.log)(`[getAmdCert] Failed to fetch AMD cert from proxy:`, e);
    }
    // Try direct fetch only if proxy fails
    (0, misc_1.log)('[getAmdCert] Attempting to fetch directly without proxy.');
    try {
        return await fetchAsUint8Array(url);
    }
    catch (e) {
        (0, misc_1.log)('[getAmdCert] Direct fetch also failed:', e);
        throw e; // Re-throw to signal that both methods failed
    }
}
/**
 *
 * Check the attestation against AMD certs
 *
 * @param { NodeAttestation } attestation The actual attestation object, which includes the signature and report
 * @param { string } challengeHex The challenge we sent
 * @param { string } url The URL we talked to
 *
 * @returns { Promise<undefined> } A promise that throws if the attestation is invalid
 */
const checkSevSnpAttestation = async (attestation, challengeHex, url) => {
    var _a;
    const noonce = Buffer.from(attestation.noonce, 'base64');
    const challenge = Buffer.from(challengeHex, 'hex');
    const data = Object.fromEntries(Object.entries(attestation.data).map(([k, v]) => [
        k,
        Buffer.from(v, 'base64'),
    ]));
    const signatures = attestation.signatures.map((s) => Buffer.from(s, 'base64'));
    const report = Buffer.from(attestation.report, 'base64');
    if (!noonce.equals(challenge)) {
        throw new constants_1.NetworkError({
            info: {
                attestation,
                challengeHex,
                noonce,
                challenge,
            },
        }, `Attestation noonce ${noonce} does not match challenge ${challenge}`);
    }
    const parsedUrl = new URL(url);
    const ipWeTalkedTo = parsedUrl.hostname;
    let portWeTalkedTo = parsedUrl.port;
    if (portWeTalkedTo === '') {
        // if we're on HTTP or HTTPS, the port will be empty
        if (url.startsWith('https://')) {
            portWeTalkedTo = '443';
        }
        else if (url.startsWith('http://')) {
            portWeTalkedTo = '80';
        }
        else {
            throw new constants_1.NetworkError({
                info: {
                    url,
                },
            }, `Unknown port in URL ${url}`);
        }
    }
    const ipAndAddrFromReport = data['EXTERNAL_ADDR'].toString('utf8');
    const ipFromReport = ipAndAddrFromReport.split(':')[0];
    const portFromReport = ipAndAddrFromReport.split(':')[1];
    if (ipWeTalkedTo !== ipFromReport) {
        throw new constants_1.NetworkError({
            info: {
                attestation,
                ipWeTalkedTo,
                ipFromReport,
            },
        }, `Attestation external address ${ipFromReport} does not match IP we talked to ${ipWeTalkedTo}`);
    }
    if (portWeTalkedTo !== portFromReport) {
        throw new constants_1.NetworkError({
            info: {
                attestation,
                portWeTalkedTo,
                portFromReport,
            },
        }, `Attestation external port ${portFromReport} does not match port we talked to ${portWeTalkedTo}`);
    }
    // get the VCEK certificate
    let vcekCert;
    const vcekUrl = await (0, wasm_1.sevSnpGetVcekUrl)(report);
    // use local storage if we have one available
    if (globalThis.localStorage) {
        (0, misc_1.log)('Using local storage for certificate caching');
        vcekCert = localStorage.getItem(vcekUrl);
        if (vcekCert) {
            vcekCert = (0, uint8arrays_1.uint8arrayFromString)(vcekCert, 'base64');
        }
        else {
            vcekCert = await getAmdCert(vcekUrl);
            localStorage.setItem(vcekUrl, (0, uint8arrays_1.uint8arrayToString)(vcekCert, 'base64'));
        }
    }
    else {
        const cache = ((_a = globalThis).amdCertStore ?? (_a.amdCertStore = {}));
        cache[vcekUrl] ?? (cache[vcekUrl] = await getAmdCert(vcekUrl));
        vcekCert = cache[vcekUrl];
    }
    if (!vcekCert || vcekCert.length === 0 || vcekCert.length < 256) {
        throw new constants_1.UnknownError({
            info: {
                attestation,
                report,
                vcekUrl,
            },
        }, 'Unable to retrieve VCEK certificate from AMD');
    }
    // pass base64 encoded report to wasm wrapper
    return (0, wasm_1.sevSnpVerify)(report, data, signatures, challenge, vcekCert);
};
exports.checkSevSnpAttestation = checkSevSnpAttestation;
//# sourceMappingURL=crypto.js.map