"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBytes32FromMultihash = void 0;
const constants_1 = require("@lit-protocol/constants");
/**
 * NOTE: This function requires the "multiformats/cid" package in order to work
 *
 * Partition multihash string into object representing multihash
 *
 * @param {string} ipfsId A base58 encoded multihash string
 * @param {CIDParser} CID The CID object from the "multiformats/cid" package
 *
 * @example
 * const CID = require('multiformats/cid')
 * const ipfsId = 'QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW'
 * const {digest, hashFunction, size} = getBytes32FromMultihash(ipfsId, CID)
 * console.log(digest) // string
 * console.log(hashFunction) // number
 * console.log(size) // number
 *
 * @returns {IPFSHash}
 */
const getBytes32FromMultihash = (ipfsId, CID) => {
    if (!CID) {
        throw new constants_1.ParamsMissingError({
            info: {
                ipfsId,
                CID,
            },
        }, 'CID is required. Please import from "multiformats/cid" package, and pass the CID object to the function.');
    }
    if (!ipfsId) {
        throw new constants_1.ParamsMissingError({
            info: {
                ipfsId,
            },
        }, 'ipfsId is required');
    }
    let cid;
    try {
        cid = CID.parse(ipfsId);
    }
    catch (e) {
        throw new constants_1.InvalidArgumentException({
            info: {
                ipfsId,
                CID,
            },
        }, 'Error parsing CID');
    }
    const hashFunction = cid.multihash.code;
    const size = cid.multihash.size;
    const digest = '0x' + Buffer.from(cid.multihash.digest).toString('hex');
    const ipfsHash = {
        digest,
        hashFunction,
        size,
    };
    return ipfsHash;
};
exports.getBytes32FromMultihash = getBytes32FromMultihash;
//# sourceMappingURL=getBytes32FromMultihash.js.map