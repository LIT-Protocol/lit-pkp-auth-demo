import { ContractName, CreateCustomAuthMethodRequest, EpochInfo, GasLimitParam, LIT_NETWORKS_KEYS, LitContractContext, LitContractResolverContext, MintCapacityCreditsContext, MintCapacityCreditsRes, MintNextAndAddAuthMethods, MintWithAuthParams, MintWithAuthResponse } from '@lit-protocol/types';
import { BigNumberish, BytesLike, ContractReceipt, ethers } from 'ethers';
import { decToHex, hexToDec } from './hex2dec';
import * as allowlistContract from '../abis/Allowlist.sol/Allowlist';
import * as litTokenContract from '../abis/LITToken.sol/LITToken';
import * as multisenderContract from '../abis/Multisender.sol/Multisender';
import * as pkpHelperContract from '../abis/PKPHelper.sol/PKPHelper';
import * as pkpNftContract from '../abis/PKPNFT.sol/PKPNFT';
import * as pkpNftMetadataContract from '../abis/PKPNFTMetadata.sol/PKPNFTMetadata';
import * as pkpPermissionsContract from '../abis/PKPPermissions.sol/PKPPermissions';
import * as pubkeyRouterContract from '../abis/PubkeyRouter.sol/PubkeyRouter';
import * as rateLimitNftContract from '../abis/RateLimitNFT.sol/RateLimitNFT';
import * as stakingContract from '../abis/Staking.sol/Staking';
import * as stakingBalancesContract from '../abis/StakingBalances.sol/StakingBalances';
import { AUTH_METHOD_TYPE_VALUES, AUTH_METHOD_SCOPE_VALUES, HTTP, HTTPS } from '@lit-protocol/constants';
import { Logger } from '@lit-protocol/logger';
import { TokenInfo } from '@lit-protocol/types';
import { IPubkeyRouter } from '../abis/PKPNFT.sol/PKPNFT';
import { CIDParser, IPFSHash } from './helpers/getBytes32FromMultihash';
export declare const asyncForEachReturn: (array: any[], callback: Function) => Promise<any[]>;
declare global {
    interface Window {
        ethereum: any;
    }
}
export declare class LitContracts {
    provider: ethers.providers.StaticJsonRpcProvider | any;
    rpc: string;
    rpcs: string[];
    signer: ethers.Signer | ethers.Wallet;
    privateKey: string | undefined;
    options?: {
        storeOrUseStorageKey?: boolean;
    };
    randomPrivateKey: boolean;
    connected: boolean;
    isPKP: boolean;
    debug: boolean;
    network: LIT_NETWORKS_KEYS;
    customContext?: LitContractContext | LitContractResolverContext;
    static contractNames: ContractName[];
    static logger: Logger;
    allowlistContract: {
        read: allowlistContract.Allowlist;
        write: allowlistContract.Allowlist;
    };
    litTokenContract: {
        read: litTokenContract.LITToken;
        write: litTokenContract.LITToken;
    };
    multisenderContract: {
        read: multisenderContract.Multisender;
        write: multisenderContract.Multisender;
    };
    pkpHelperContract: {
        read: pkpHelperContract.PKPHelper;
        write: pkpHelperContract.PKPHelper;
    };
    pkpNftContract: {
        read: pkpNftContract.PKPNFT;
        write: pkpNftContract.PKPNFT;
    };
    pkpNftMetadataContract: {
        read: pkpNftMetadataContract.PKPNFTMetadata;
        write: pkpNftMetadataContract.PKPNFTMetadata;
    };
    pkpPermissionsContract: {
        read: pkpPermissionsContract.PKPPermissions;
        write: pkpPermissionsContract.PKPPermissions;
    };
    pubkeyRouterContract: {
        read: pubkeyRouterContract.PubkeyRouter;
        write: pubkeyRouterContract.PubkeyRouter;
    };
    rateLimitNftContract: {
        read: rateLimitNftContract.RateLimitNFT;
        write: rateLimitNftContract.RateLimitNFT;
    };
    stakingContract: {
        read: stakingContract.Staking;
        write: stakingContract.Staking;
    };
    stakingBalancesContract: {
        read: stakingBalancesContract.StakingBalances;
        write: stakingBalancesContract.StakingBalances;
    };
    constructor(args?: {
        provider?: ethers.providers.StaticJsonRpcProvider | any;
        customContext?: LitContractContext | LitContractResolverContext;
        rpcs?: string[] | any;
        rpc?: string | any;
        signer?: ethers.Signer | any;
        privateKey?: string | undefined;
        randomPrivatekey?: boolean;
        options?: {
            storeOrUseStorageKey?: boolean;
        };
        debug?: boolean;
        network?: LIT_NETWORKS_KEYS;
    });
    /**
     * Logs a message to the console.
     *
     * @param {any} [args] An optional value to log with the message.
     */
    log: (...args: any) => void;
    connect: () => Promise<void>;
    /**
     * Retrieves the Staking contract instance based on the provided network, context, and RPC URL.
     * If a context is provided, it determines if a contract resolver is used for bootstrapping contracts.
     * If a resolver address is present in the context, it retrieves the Staking contract from the contract resolver instance.
     * Otherwise, it retrieves the Staking contract using the contract address and ABI from the contract context.
     * Throws an error if required contract data is missing or if the Staking contract cannot be obtained.
     *
     * @param network - The network key.
     * @param context - The contract context or contract resolver context.
     * @param rpcUrl - The RPC URL.
     * @returns The Staking contract instance.
     * @throws Error if required contract data is missing or if the Staking contract cannot be obtained.
     */
    static getStakingContract(network: LIT_NETWORKS_KEYS, context?: LitContractContext | LitContractResolverContext, rpcUrl?: string): Promise<ethers.Contract>;
    private static _getContractsFromResolver;
    static getContractAddresses(network: LIT_NETWORKS_KEYS, provider: ethers.providers.StaticJsonRpcProvider, context?: LitContractContext | LitContractResolverContext): Promise<any>;
    /**
     * @deprecated - Use {@link getConnectionInfo } instead, which provides more information.
     */
    static getMinNodeCount: (network: LIT_NETWORKS_KEYS, context?: LitContractContext | LitContractResolverContext, rpcUrl?: string) => Promise<any>;
    /**
     * @deprecated - Use {@link getConnectionInfo } instead, which provides more information.
     */
    static getValidators: (network: LIT_NETWORKS_KEYS, context?: LitContractContext | LitContractResolverContext, rpcUrl?: string, nodeProtocol?: typeof HTTP | typeof HTTPS | null) => Promise<string[]>;
    /**
     * Retrieves the connection information for a given network.
     *
     * @param params
     * @param params.litNetwork - The key representing the network.
     * @param [params.networkContext] - Optional network context for the contract.
     * @param [params.rpcUrl] - Optional RPC URL for the network.
     * @param [params.nodeProtocol] - Optional protocol for the network node.
     *
     * @returns An object containing the staking contract, epoch number, minimum node count and an array of bootstrap URLs.
     *
     * @throws Error if the minimum validator count is not set or if the active validator set does not meet the threshold.
     */
    static getConnectionInfo: ({ litNetwork, networkContext, rpcUrl, nodeProtocol, }: {
        litNetwork: LIT_NETWORKS_KEYS;
        networkContext?: LitContractContext | LitContractResolverContext;
        rpcUrl?: string;
        nodeProtocol?: typeof HTTP | typeof HTTPS | null;
    }) => Promise<{
        stakingContract: ethers.Contract;
        epochInfo: EpochInfo;
        minNodeCount: number;
        bootstrapUrls: string[];
    }>;
    private static _resolveContractContext;
    /**
     * Mints a new token with authentication.
     *
     * @param authMethod - The authentication method.
     * @param scopes - The permission scopes.
     * @param pubkey - The public key.
     * @param authMethodId - (optional) The authentication ID.
     * @param gasLimit - (optional) The gas limit.
     * @returns An object containing the PKP information and the transaction receipt.
     * @throws Error if the contracts are not connected, the contract is not available, authMethodType or accessToken is missing, or permission scopes are required.
     */
    mintWithAuth: ({ authMethod, scopes, pubkey, authMethodId, gasLimit, }: MintWithAuthParams) => Promise<MintWithAuthResponse<ContractReceipt>>;
    /**
     * Mints a new token with customer authentication.
     *
     * @param { Object } params - The parameters for minting a new token with customer authentication.
     * @param { string } params.authMethodId - The authentication method id.
     * @param { string[] | number[] } params.scopes - The permission scopes.
     * @param { string } params.authMethodType - The authentication method type.
     * @returns { Promise<MintWithAuthResponse<ContractReceipt>> } - An object containing the PKP information and the transaction receipt.
     * @throws { Error } - If the contracts are not connected, the contract is not available, authMethodType, or permission scopes are required.
     *
     */
    mintWithCustomAuth: (params: CreateCustomAuthMethodRequest) => Promise<MintWithAuthResponse<ContractReceipt>>;
    /**
     * Adds a permitted authentication method for a given PKP token.
     *
     * @param {Object} params - The parameters for adding the permitted authentication method.
     * @param {string} params.pkpTokenId - The ID of the PKP token.
     * @param {AUTH_METHOD_TYPE_VALUES | number} params.authMethodType - The type of the authentication method.
     * @param {string | Uint8Array} params.authMethodId - The ID of the authentication method.
     * @param {AuthMethodScope[]} params.authMethodScopes - The scopes of the authentication method.
     * @param {string} [params.webAuthnPubkey] - The public key for WebAuthn.
     * @returns {Promise<any>} - A promise that resolves with the result of adding the permitted authentication method.
     * @throws {Error} - If an error occurs while adding the permitted authentication method.
     */
    addPermittedAuthMethod: ({ pkpTokenId, authMethodType, authMethodId, authMethodScopes, webAuthnPubkey, }: {
        pkpTokenId: string;
        authMethodType: AUTH_METHOD_TYPE_VALUES | number;
        authMethodId: string | Uint8Array;
        authMethodScopes: AUTH_METHOD_SCOPE_VALUES[];
        webAuthnPubkey?: string;
    }) => Promise<ethers.ContractReceipt>;
    /**
     * Adds a permitted action to the PKP permissions contract.
     *
     * @param ipfsId - The IPFS ID of the action.
     * @param pkpTokenId - The PKP token ID.
     * @param authMethodScopes - Optional array of authentication method scopes.
     * @returns A promise that resolves to the result of the write operation.
     * @throws If an error occurs during the write operation.
     */
    addPermittedAction: ({ ipfsId, pkpTokenId, authMethodScopes, }: {
        ipfsId: string;
        pkpTokenId: string;
        authMethodScopes: AUTH_METHOD_SCOPE_VALUES[];
    }) => Promise<ContractReceipt>;
    /**
     * Mint a Capacity Credits NFT (RLI) token with the specified daily request rate and expiration period. The expiration date is calculated to be at midnight UTC, a specific number of days from now.
     *
     * @param {MintCapacityCreditsContext} context - The minting context.
     * @returns {Promise<MintCapacityCreditsRes>} - A promise that resolves to the minted capacity credits NFT response.
     * @throws {Error} - If the input parameters are invalid or an error occurs during the minting process.
     */
    mintCapacityCreditsNFT: ({ requestsPerDay, requestsPerSecond, requestsPerKilosecond, daysUntilUTCMidnightExpiration, gasLimit, }: MintCapacityCreditsContext) => Promise<MintCapacityCreditsRes>;
    utils: {
        hexToDec: typeof hexToDec;
        decToHex: typeof decToHex;
        /**
         * Partition multihash string into object representing multihash
         *
         * @param {string} multihash A base58 encoded multihash string
         * @returns {string}
         */
        getBytesFromMultihash: (multihash: string) => string;
        /**
         *
         * Convert bytes32 to IPFS ID
         * @param { string } byte32 0x1220baa0d1e91f2a22fef53659418ddc3ac92da2a76d994041b86ed62c0c999de477
         * @returns { string } QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
         */
        getMultihashFromBytes: (byte32: string) => string;
        /**
         * NOTE: This function requires the "multiformats/cid" package in order to work
         *
         * Partition multihash string into object representing multihash
         *
         * @param {string} ipfsId A base58 encoded multihash string
         * @param {CIDParser} CID The CID object from the "multiformats/cid" package
         *
         * @example
         * const CID = require('multiformats/cid')
         * const ipfsId = 'QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW'
         * const bytes32 = getBytes32FromMultihash(ipfsId, CID)
         * console.log(bytes32)
         *
         * @returns {IPFSHash}
         */
        getBytes32FromMultihash: (ipfsId: string, CID: CIDParser) => IPFSHash;
        timestamp2Date: (timestamp: string) => string;
    };
    pkpNftContractUtils: {
        read: {
            /**
             * (IERC721Enumerable)
             *
             * Get all PKPs by a given address
             *
             * @param { string } ownerAddress
             * @retu
             * */
            getTokensByAddress: (ownerAddress: string) => Promise<string[]>;
            /**
             * (IERC721Enumerable)
             *
             * Get the x latest number of tokens
             *
             * @param { number } latestNumberOfTokens
             *
             * @returns { Array<string> } a list of PKP NFTs
             *
             */
            getTokens: (latestNumberOfTokens: number) => Promise<string[]>;
            /**
             * Get info of all PKPs by a given address
             */
            getTokensInfoByAddress: (ownerAddress: string) => Promise<TokenInfo[]>;
        };
        write: {
            mint: (param?: GasLimitParam) => Promise<{
                pkp: {
                    tokenId: any;
                    publicKey: string;
                    ethAddress: string;
                };
                tx: ethers.ContractTransaction;
                tokenId: any;
                res: any;
            }>;
            claimAndMint: (derivedKeyId: BytesLike, signatures: IPubkeyRouter.SignatureStruct[], txOpts?: ethers.CallOverrides) => Promise<{
                tx: ethers.ContractTransaction;
                res: ContractReceipt;
                tokenId: any;
            }>;
        };
    };
    pkpPermissionsContractUtils: {
        read: {
            /**
             *
             * Check if an address is permitted
             *
             * @param { string } tokenId
             * @param { string } address
             *
             * @returns { Promise<boolean> }
             */
            isPermittedAddress: (tokenId: string, address: string) => Promise<boolean>;
            /**
             * Get permitted addresses
             *
             * @param { string } tokenId
             *
             * @returns { Promise<Array<string>> }
             *
             */
            getPermittedAddresses: (tokenId: string) => Promise<string[]>;
            /**
             *
             * Get permitted action
             *
             * @param { any } tokenId
             *
             * @returns { Promise<Array<string>> }
             *
             */
            getPermittedActions: (tokenId: BigNumberish) => Promise<string[]>;
            /**
             *
             * Check if an action is permitted given the pkpid and ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             *
             * @return { object } transaction
             */
            isPermittedAction: (pkpId: string, ipfsId: string) => Promise<boolean>;
        };
        write: {
            /**
             *
             * Add permitted action to a given PKP id & ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             *
             * @return { object } transaction
             */
            addPermittedAction: (pkpId: string, ipfsId: string) => Promise<ethers.ContractTransaction>;
            /**
             * TODO: add transaction type
             * Add permitted action to a given PKP id & ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ownerAddress  0x3B5dD2605.....22aDC499A1
             *
             * @return { object } transaction
             */
            addPermittedAddress: (pkpId: string, ownerAddress: string) => Promise<ethers.ContractTransaction>;
            /**
             * Revoke permitted action of a given PKP id & ipfsId
             *
             * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
             * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             *
             * @return { object } transaction
             */
            revokePermittedAction: (pkpId: string, ipfsId: string) => Promise<ethers.ContractTransaction>;
        };
    };
    rateLimitNftContractUtils: {
        read: {
            /**
             * getCapacityByIndex: async (index: number): Promise<any> => {
             *
             *  This function takes a token index as a parameter and returns the capacity of the token
             *  with the given index. The capacity is an object that contains the number of requests
             *  per millisecond that the token allows, and an object with the expiration timestamp and
             *  formatted expiration date of the token.
             *
             *  @param {number} index - The index of the token.
             *  @returns {Promise<any>} - A promise that resolves to the capacity of the token.
             *
             *  Example:
             *
             *  const capacity = await getCapacityByIndex(1);
             *  this.log(capacity);
             *  // Output: {
             *  //   requestsPerMillisecond: 100,
             *  //   expiresAt: {
             *  //     timestamp: 1623472800,
             *  //     formatted: '2022-12-31',
             *  //   },
             *  // }
             *
             * }
             */
            getCapacityByIndex: (index: number) => Promise<any>;
            /**
             * getTokenURIByIndex: async (index: number): Promise<string> => {
             *
             *  This function takes a token index as a parameter and returns the URI of the token
             *  with the given index.
             *
             *  @param {number} index - The index of the token.
             *  @returns {Promise<string>} - A promise that resolves to the URI of the token.
             *
             *  Example:
             *
             *  const URI = await getTokenURIByIndex(1);
             *  this.log(URI);
             *  // Output: 'https://tokens.com/1'
             *
             * }
             */
            getTokenURIByIndex: (index: number) => Promise<string>;
            /**
             * getTokensByOwnerAddress: async (ownerAddress: string): Promise<any> => {
             *
             *  This function takes an owner address as a parameter and returns an array of tokens
             *  that are owned by the given address.
             *
             *  @param {string} ownerAddress - The address of the owner.
             *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
             *
             *  Example:
             *
             *  const tokens = await getTokensByOwnerAddress('0x1234...5678');
             *  this.log(tokens);
             *  // Output: [
             *  //   {
             *  //     tokenId: 1,
             *  //     URI: 'https://tokens.com/1',
             *  //     capacity: 100,
             *  //     isExpired: false,
             *  //   },
             *  //   {
             *  //     tokenId: 2,
             *  //     URI: 'https://tokens.com/2',
             *  //     capacity: 200,
             *  //     isExpired: true,
             *  //   },
             *  //   ...
             *  // ]
             *
             * }
             */
            getTokensByOwnerAddress: (ownerAddress: string) => Promise<any>;
            /**
             * getTokens: async (): Promise<any> => {
             *
             *  This function returns an array of all tokens that have been minted.
             *
             *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
             *
             *  Example:
             *
             *  const tokens = await getTokens();
             *  this.log(tokens);
             *  // Output: [
             *  //   {
             *  //     tokenId: 1,
             *  //     URI: 'https://tokens.com/1',
             *  //     capacity: 100,
             *  //     isExpired: false,
             *  //   },
             *  //   {
             *  //     tokenId: 2,
             *  //     URI: 'https://tokens.com/2',
             *  //     capacity: 200,
             *  //     isExpired: true,
             *  //   },
             *  //   ...
             *  // ]
             *
             * }
             */
            getTokens: () => Promise<any>;
        };
        write: {
            mint: ({ txOpts, timestamp, }: {
                txOpts: ethers.CallOverrides;
                timestamp: number;
            }) => Promise<{
                tx: ethers.ContractTransaction;
                tokenId: string | undefined;
            }>;
            /**
             * Transfer RLI token from one address to another
             *
             * @property { string } fromAddress
             * @property { string } toAddress
             * @property { string } RLITokenAddress
             *
             * @return { <Promise<void>> } void
             */
            transfer: ({ fromAddress, toAddress, RLITokenAddress, }: {
                fromAddress: string;
                toAddress: string;
                RLITokenAddress: string;
            }) => Promise<ethers.ContractTransaction>;
        };
    };
    routerContractUtils: {
        read: {};
        write: {};
    };
    pkpHelperContractUtil: {
        read: {};
        write: {
            /**
             *
             * @param param0
             * @returns
             */
            mintNextAndAddAuthMethods: ({ keyType, permittedAuthMethodTypes, permittedAuthMethodIds, permittedAuthMethodPubkeys, permittedAuthMethodScopes, addPkpEthAddressAsPermittedAddress, sendPkpToItself, gasLimit, }: MintNextAndAddAuthMethods) => Promise<ethers.ContractTransaction>;
        };
    };
    private _getAdjustedGasLimit;
    private _callWithAdjustedOverrides;
}
