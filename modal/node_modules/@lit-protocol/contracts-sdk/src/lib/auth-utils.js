"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringToArrayify = exports.totpAuthFactorParser = exports.whatsAppOtpAuthFactorParser = exports.smsOtpAuthFactorParser = exports.emailOtpAuthFactorParser = void 0;
exports.getAuthIdByAuthMethod = getAuthIdByAuthMethod;
exports.getEthAuthMethodId = getEthAuthMethodId;
const tslib_1 = require("tslib");
const constants_1 = require("@lit-protocol/constants");
const ethers_1 = require("ethers");
const jose = tslib_1.__importStar(require("jose"));
/**
 * Code here is ported from `packages/lit-auth-client` due to circular dep errors
 */
async function getAuthIdByAuthMethod(authMethod) {
    let authMethodId;
    switch (authMethod.authMethodType) {
        case 1:
            authMethodId = getEthAuthMethodId(authMethod);
            break;
        case 4:
            authMethodId = await getDiscordAuthId(authMethod);
            break;
        case 3:
            authMethodId = await getWebauthnAuthId(authMethod);
            break;
        case 6:
            authMethodId = await getGoogleJwtAuthId(authMethod);
            break;
        case 9:
            authMethodId = await getStytchAuthId(authMethod);
            break;
        case 10:
        case 11:
        case 12:
        case 13:
            authMethodId = await getStytchFactorAuthMethodId(authMethod);
            break;
        default:
            throw new constants_1.InvalidArgumentException({
                info: {
                    authMethod,
                },
            }, `Unsupported auth method type: ${authMethod.authMethodType}`);
    }
    return authMethodId;
}
/**
 * Get the auth method id for an eth auth method, the access token can either be an auth sig or a session sigs object
 * @param authMethod
 * @returns
 */
function getEthAuthMethodId(authMethod) {
    let accessToken;
    // -- try if access token can be parsed as JSON object first
    try {
        accessToken = JSON.parse(authMethod.accessToken);
    }
    catch (err) {
        throw new constants_1.InvalidArgumentException({
            info: {
                authMethod,
            },
            cause: err,
        }, 'Unable to parse access token as JSON object');
    }
    const address = accessToken.address;
    // -- check if address is empty
    if (!address) {
        throw new constants_1.NoWalletException({
            info: {
                authMethod,
            },
        }, 'No address found in access token');
    }
    return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${address}:lit`));
}
async function getDiscordAuthId(authMethod) {
    const _clientId = '1052874239658692668';
    // -- get user id from access token
    let userId;
    const meResponse = await fetch('https://discord.com/api/users/@me', {
        method: 'GET',
        headers: {
            authorization: `Bearer ${authMethod.accessToken}`,
        },
    });
    if (meResponse.ok) {
        const user = await meResponse.json();
        userId = user.id;
    }
    else {
        throw new constants_1.NetworkError({
            info: {
                authMethod,
            },
        }, 'Unable to verify Discord account');
    }
    // -- get auth method id
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${_clientId}`));
    return authMethodId;
}
async function getWebauthnAuthId(authMethod) {
    let credentialId;
    const rpNameToUse = 'lit';
    try {
        credentialId = JSON.parse(authMethod.accessToken).rawId;
    }
    catch (err) {
        throw new constants_1.InvalidArgumentException({
            info: {
                authMethod,
            },
            cause: err,
        }, `Error when parsing auth method to generate auth method ID for WebAuthn`);
    }
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${credentialId}:${rpNameToUse}`));
    return authMethodId;
}
async function getStytchAuthId(authMethod) {
    try {
        const tokenBody = _parseJWT(authMethod.accessToken);
        const userId = tokenBody['sub'];
        const orgId = tokenBody['aud'][0];
        const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${orgId.toLowerCase()}`));
        return authMethodId;
    }
    catch (err) {
        throw new constants_1.InvalidArgumentException({
            info: {
                authMethod,
            },
            cause: err,
        }, `Error while parsing auth method to generate auth method id for Stytch OTP`);
    }
}
/**
 * Get auth method id that can be used to look up and interact with
 * PKPs associated with the given auth method.
 * Will parse out the given `authentication factor` and use the transport
 * for the otp code as the `user identifier` for the given auth method.
 * @param {AuthMethod} authMethod - Auth method object
 *
 * @returns {Promise<string>} - Auth method id
 */
function getStytchFactorAuthMethodId(authMethod) {
    return new Promise((resolve, reject) => {
        const accessToken = authMethod.accessToken;
        const parsedToken = _parseJWT(accessToken);
        let factor = 'email';
        switch (authMethod.authMethodType) {
            case 10:
                factor = 'email';
                break;
            case 11:
                factor = 'sms';
                break;
            case 12:
                factor = 'whatsApp';
                break;
            case 13:
                factor = 'totp';
                break;
            default:
                throw new constants_1.InvalidArgumentException({
                    info: {
                        authMethod,
                    },
                }, `Unsupport stytch auth type`);
        }
        const factorParser = _resolveAuthFactor(factor).parser;
        try {
            resolve(factorParser(parsedToken, 'https://stytch.com/session'));
        }
        catch (e) {
            reject(e);
        }
    });
}
async function getGoogleJwtAuthId(authMethod) {
    const tokenPayload = jose.decodeJwt(authMethod.accessToken);
    const userId = tokenPayload['sub'];
    const audience = tokenPayload['aud'];
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${audience}`));
    return authMethodId;
}
/**
 *
 * @param jwt token to parse
 * @returns {string}- userId contained within the token message
 */
function _parseJWT(jwt) {
    const parts = jwt.split('.');
    if (parts.length !== 3) {
        throw new constants_1.WrongParamFormat({
            info: {
                jwt,
            },
        }, 'Invalid token length');
    }
    const body = Buffer.from(parts[1], 'base64');
    const parsedBody = JSON.parse(body.toString('ascii'));
    console.log('JWT body: ', parsedBody);
    return parsedBody;
}
const emailOtpAuthFactorParser = (parsedToken, provider) => {
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    const authFactor = authFactors.find((value, _index, _obj) => {
        if (value.email_factor)
            return value;
    });
    if (!authFactor) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider,
            },
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider,
            },
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.email_factor.email_address;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.emailOtpAuthFactorParser = emailOtpAuthFactorParser;
const smsOtpAuthFactorParser = (parsedToken, provider) => {
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj) => {
        if (value.phone_number_factor)
            return value;
    });
    if (!authFactor) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider,
            },
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider,
            },
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.phone_number_factor.phone_number;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.smsOtpAuthFactorParser = smsOtpAuthFactorParser;
const whatsAppOtpAuthFactorParser = (parsedToken, provider) => {
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj) => {
        if (value.phone_number_factor)
            return value;
    });
    if (!authFactor) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider,
            },
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider,
            },
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.phone_number_factor.phone_number;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.whatsAppOtpAuthFactorParser = whatsAppOtpAuthFactorParser;
const totpAuthFactorParser = (parsedToken, provider) => {
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj) => {
        if (value.phone_number_factor)
            return value;
    });
    if (!authFactor) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider,
            },
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider,
            },
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.authenticator_app_factor.totp_id;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.totpAuthFactorParser = totpAuthFactorParser;
function _resolveAuthFactor(factor) {
    switch (factor) {
        case 'email':
            return {
                parser: exports.emailOtpAuthFactorParser,
                authMethodType: 10,
            };
        case 'sms':
            return {
                parser: exports.smsOtpAuthFactorParser,
                authMethodType: 11,
            };
        case 'whatsApp':
            return {
                parser: exports.whatsAppOtpAuthFactorParser,
                authMethodType: 12,
            };
        case 'totp':
            return {
                parser: exports.totpAuthFactorParser,
                authMethodType: 13,
            };
    }
    throw new constants_1.InvalidArgumentException({
        info: {
            factor,
        },
    }, `Error could not find auth with factor ${factor}`);
}
/**
 * Converts a string into a byte array (arrayified value)
 * @param str - The input string to be converted.
 * @returns A Uint8Array representing the arrayified value of the string.
 */
const stringToArrayify = (str) => {
    try {
        // Convert the string to a UTF-8 encoded byte array
        const encoder = new TextEncoder();
        return encoder.encode(str);
    }
    catch (e) {
        throw new constants_1.InvalidParamType({
            info: {
                str,
            },
        }, `Error converting string to arrayify`);
    }
};
exports.stringToArrayify = stringToArrayify;
//# sourceMappingURL=auth-utils.js.map