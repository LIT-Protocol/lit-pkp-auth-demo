"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignatures = exports.getFlattenShare = void 0;
const utils_1 = require("ethers/lib/utils");
const constants_1 = require("@lit-protocol/constants");
const crypto_1 = require("@lit-protocol/crypto");
const misc_1 = require("@lit-protocol/misc");
const getFlattenShare = (share) => {
    // flatten the signature object so that the properties of the signature are top level
    const flattenObj = Object.values(share).map((item) => {
        if (item === null || item === undefined) {
            return null;
        }
        const typedItem = item;
        const requiredShareProps = [
            'sigType',
            'dataSigned',
            'signatureShare',
            'shareIndex',
            'bigR',
            'publicKey',
        ];
        const requiredSessionSigsShareProps = [
            ...requiredShareProps,
            'siweMessage',
        ];
        const requiredSignatureShareProps = [
            ...requiredShareProps,
            'sigName',
        ];
        const hasProps = (props) => {
            return props.every((prop) => typedItem[prop] !== undefined &&
                typedItem[prop] !== null);
        };
        if (hasProps(requiredSessionSigsShareProps) ||
            hasProps(requiredSignatureShareProps)) {
            const bigR = typedItem.bigR ?? typedItem.bigr;
            typedItem.signatureShare = (typedItem.signatureShare ?? '').replaceAll('"', '');
            typedItem.bigR = (bigR ?? '').replaceAll('"', '');
            typedItem.publicKey = (typedItem.publicKey ?? '').replaceAll('"', '');
            typedItem.dataSigned = (typedItem.dataSigned ?? '').replaceAll('"', '');
            return typedItem;
        }
        return null;
    });
    // removed all null values and should only have one item
    const flattenShare = flattenObj.filter((item) => item !== null)[0];
    if (flattenShare === null || flattenShare === undefined) {
        return share;
    }
    return flattenShare;
};
exports.getFlattenShare = getFlattenShare;
/**
 * Retrieves and combines signature shares from multiple nodes to generate the final signatures.
 *
 * @template T - The type of the final signatures. For `executeJs` endpoint, it returns as `signature`, and for `pkpSign` endpoint, it returns as `sig`.
 * @param {any} params.networkPubKeySet - The public key set of the network.
 * @param {number} params.minNodeCount - The threshold number of nodes
 * @param {any[]} params.signedData - The array of signature shares from each node.
 * @param {string} [params.requestId=''] - The optional request ID for logging purposes.
 * @returns {T | { signature: SigResponse; sig: SigResponse }} - The final signatures or an object containing the final signatures.
 *
 * @example
 *
 * executeJs: getSignatures<{ signature: SigResponse }>
 * pkpSign: getSignatures<{ sig: SigResponse }>
 */
const getSignatures = async (params) => {
    const { networkPubKeySet, minNodeCount, signedData, requestId } = params;
    const initialKeys = [...new Set(signedData.flatMap((i) => Object.keys(i)))];
    // processing signature shares for failed or invalid contents.  mutates the signedData object.
    for (const signatureResponse of signedData) {
        for (const sigName of Object.keys(signatureResponse)) {
            const requiredFields = ['signatureShare'];
            for (const field of requiredFields) {
                if (!signatureResponse[sigName][field]) {
                    (0, misc_1.logWithRequestId)(requestId, `invalid field ${field} in signature share: ${sigName}, continuing with share processing`);
                    // destructive operation on the object to remove invalid shares inline, without a new collection.
                    delete signatureResponse[sigName];
                }
                else {
                    let share = (0, exports.getFlattenShare)(signatureResponse[sigName]);
                    share = {
                        sigType: share.sigType,
                        signatureShare: share.signatureShare,
                        shareIndex: share.shareIndex,
                        bigR: share.bigR,
                        publicKey: share.publicKey,
                        dataSigned: share.dataSigned,
                        sigName: share.sigName ? share.sigName : 'sig',
                    };
                    signatureResponse[sigName] = share;
                }
            }
        }
    }
    const validatedSignedData = signedData;
    // -- prepare
    const signatures = {};
    // get all signature shares names from all node responses.
    // use a set to filter duplicates and copy into an array
    const allKeys = [
        ...new Set(validatedSignedData.flatMap((i) => Object.keys(i))),
    ];
    if (allKeys.length !== initialKeys.length) {
        throw new constants_1.NoValidShares({}, 'total number of valid signatures does not match requested');
    }
    // -- combine
    for (const key of allKeys) {
        // here we use a map filter implementation to find common shares in each node response.
        // we then filter out undefined object from the key access.
        // currently we are unable to know the total signature count requested by the user.
        // but this allows for incomplete sets of signature shares to be aggregated
        // and then checked against threshold
        const shares = validatedSignedData
            .map((r) => r[key])
            .filter((r) => r !== undefined);
        shares.sort((a, b) => a.shareIndex - b.shareIndex);
        const sigName = shares[0].sigName;
        (0, misc_1.logWithRequestId)(requestId, `starting signature combine for sig name: ${sigName}`, shares);
        (0, misc_1.logWithRequestId)(requestId, `number of shares for ${sigName}:`, signedData.length);
        (0, misc_1.logWithRequestId)(requestId, `validated length for signature: ${sigName}`, shares.length);
        (0, misc_1.logWithRequestId)(requestId, 'minimum required shares for threshold:', minNodeCount);
        if (shares.length < minNodeCount) {
            (0, misc_1.logErrorWithRequestId)(requestId, `not enough nodes to get the signatures.  Expected ${minNodeCount}, got ${shares.length}`);
            throw new constants_1.NoValidShares({
                info: {
                    requestId,
                    shares: shares.length,
                    minNodeCount,
                },
            }, 'The total number of valid signatures shares %s does not meet the threshold of %s', shares.length, minNodeCount);
        }
        const sigType = (0, misc_1.mostCommonString)(shares.map((s) => s.sigType));
        // -- validate if this.networkPubKeySet is null
        if (networkPubKeySet === null) {
            throw new constants_1.ParamNullError({
                info: {
                    requestId,
                },
            }, 'networkPubKeySet cannot be null');
        }
        // -- validate if signature type is ECDSA
        if (sigType !== constants_1.LIT_CURVE.EcdsaCaitSith &&
            sigType !== constants_1.LIT_CURVE.EcdsaK256 &&
            sigType !== constants_1.LIT_CURVE.EcdsaCAITSITHP256) {
            throw new constants_1.UnknownSignatureType({
                info: {
                    requestId,
                    signatureType: sigType,
                },
            }, 'signature type is %s which is invalid', sigType);
        }
        const signature = await (0, crypto_1.combineEcdsaShares)(shares);
        if (!signature.r) {
            throw new constants_1.UnknownSignatureError({
                info: {
                    requestId,
                    signature,
                },
            }, 'signature could not be combined');
        }
        const encodedSig = (0, utils_1.joinSignature)({
            r: '0x' + signature.r,
            s: '0x' + signature.s,
            recoveryParam: signature.recid,
        });
        signatures[key] = {
            ...signature,
            signature: encodedSig,
            publicKey: (0, misc_1.mostCommonString)(shares.map((s) => s.publicKey)),
            dataSigned: (0, misc_1.mostCommonString)(shares.map((s) => s.dataSigned)),
        };
    }
    return signatures;
};
exports.getSignatures = getSignatures;
//# sourceMappingURL=get-signatures.js.map