import { LitAccessControlConditionResource, LitResourceAbilityRequest } from '@lit-protocol/auth-helpers';
import { LitCore } from '@lit-protocol/core';
import { ILitResource, ISessionCapabilityObject } from '@lit-protocol/types';
import type { AuthCallbackParams, AuthSig, CapacityCreditsReq, CapacityCreditsRes, ClaimKeyResponse, ClaimProcessor, ClaimRequest, CustomNetwork, DecryptRequest, DecryptResponse, EncryptRequest, EncryptResponse, EncryptSdkParams, ExecuteJsResponse, GetLitActionSessionSigs, GetPkpSessionSigs, GetSessionSigsProps, GetSignSessionKeySharesProp, GetWalletSigProps, ILitNodeClient, JsonExecutionSdkParams, JsonExecutionSdkParamsTargetNode, JsonPkpSignSdkParams, LitClientSessionManager, LitNodeClientConfig, NodeBlsSigningShare, NodeCommandResponse, RejectedNodePromises, SessionKeyPair, SessionSigsMap, SigResponse, SignSessionKeyProp, SignSessionKeyResponse, SuccessNodePromises } from '@lit-protocol/types';
export declare class LitNodeClientNodeJs extends LitCore implements LitClientSessionManager, ILitNodeClient {
    defaultAuthCallback?: (authSigParams: AuthCallbackParams) => Promise<AuthSig>;
    constructor(args: LitNodeClientConfig | CustomNetwork);
    createCapacityDelegationAuthSig: (params: CapacityCreditsReq) => Promise<CapacityCreditsRes>;
    /**
     *
     * we need to send jwt params iat (issued at) and exp (expiration) because the nodes may have different wall clock times, the nodes will verify that these params are withing a grace period
     *
     */
    getJWTParams: () => {
        iat: number;
        exp: number;
    };
    /**
     * Try to get the session key in the local storage,
     * if not, generates one.
     * @return { SessionKeyPair } session key pair
     */
    getSessionKey: () => SessionKeyPair;
    /**
     * Check if a given object is of type SessionKeyPair.
     *
     * @param obj - The object to check.
     * @returns True if the object is of type SessionKeyPair.
     */
    isSessionKeyPair(obj: any): obj is SessionKeyPair;
    /**
     * Generates wildcard capability for each of the LIT resources
     * specified.
     * @param litResources is an array of LIT resources
     * @param addAllCapabilities is a boolean that specifies whether to add all capabilities for each resource
     */
    static generateSessionCapabilityObjectWithWildcards(litResources: ILitResource[], addAllCapabilities?: boolean): Promise<ISessionCapabilityObject>;
    generateSessionCapabilityObjectWithWildcards(litResources: ILitResource[]): Promise<ISessionCapabilityObject>;
    /**
     *
     * Get expiration for session default time is 1 day / 24 hours
     *
     */
    static getExpiration: () => string;
    getExpiration: () => string;
    /**
     *
     * Get the signature from local storage, if not, generates one
     *
     */
    getWalletSig: ({ authNeededCallback, chain, sessionCapabilityObject, switchChain, expiration, sessionKeyUri, nonce, resourceAbilityRequests, litActionCode, litActionIpfsId, jsParams, sessionKey, }: GetWalletSigProps) => Promise<AuthSig>;
    private _authCallbackAndUpdateStorageItem;
    /**
     *
     * Check if a session key needs to be resigned. These are the scenarios where a session key needs to be resigned:
     * 1. The authSig.sig does not verify successfully against the authSig.signedMessage
     * 2. The authSig.signedMessage.uri does not match the sessionKeyUri
     * 3. The authSig.signedMessage does not contain at least one session capability object
     *
     */
    checkNeedToResignSessionKey: ({ authSig, sessionKeyUri, resourceAbilityRequests, }: {
        authSig: AuthSig;
        sessionKeyUri: any;
        resourceAbilityRequests: LitResourceAbilityRequest[];
    }) => Promise<boolean>;
    /**
     *
     * Combine Shares from network public key set and signature shares
     *
     * @param { NodeBlsSigningShare } signatureShares
     *
     * @returns { string } final JWT (convert the sig to base64 and append to the jwt)
     *
     */
    combineSharesAndGetJWT: (signatureShares: NodeBlsSigningShare[], requestId?: string) => Promise<string>;
    private _decryptWithSignatureShares;
    getIpfsId: ({ dataToHash, sessionSigs, }: {
        dataToHash: string;
        sessionSigs: SessionSigsMap;
        debug?: boolean;
    }) => Promise<any>;
    /**
     * Run lit action on a single deterministicly selected node. It's important that the nodes use the same deterministic selection algorithm.
     *
     * Lit Action: dataToHash -> IPFS CID
     * QmUjX8MW6StQ7NKNdaS6g4RMkvN5hcgtKmEi8Mca6oX4t3
     *
     * @param { ExecuteJsProps } params
     *
     * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
     *
     */
    runOnTargetedNodes: (params: JsonExecutionSdkParamsTargetNode) => Promise<SuccessNodePromises<NodeCommandResponse> | RejectedNodePromises>;
    /**
     * Retrieves the fallback IPFS code for a given IPFS ID.
     *
     * @param gatewayUrl - the gateway url.
     * @param ipfsId - The IPFS ID.
     * @returns The base64-encoded fallback IPFS code.
     * @throws An error if the code retrieval fails.
     */
    private _getFallbackIpfsCode;
    private executeJsNodeRequest;
    /**
     *
     * Execute JS on the nodes and combine and return any resulting signatures
     *
     * @param { JsonExecutionSdkParams } params
     *
     * @returns { ExecuteJsResponse }
     *
     */
    executeJs: (params: JsonExecutionSdkParams) => Promise<ExecuteJsResponse>;
    /**
     * Generates a promise by sending a command to the Lit node
     *
     * @param url - The URL to send the command to.
     * @param params - The parameters to include in the command.
     * @param requestId - The ID of the request.
     * @returns A promise that resolves with the response from the server.
     */
    generatePromise: (url: string, params: any, requestId: string) => Promise<NodeCommandResponse>;
    /**
     * Use PKP to sign
     *
     * @param { JsonPkpSignSdkParams } params
     * @param params.toSign - The data to sign
     * @param params.pubKey - The public key to sign with
     * @param params.sessionSigs - The session signatures to use
     * @param params.authMethods - (optional) The auth methods to use
     */
    pkpSign: (params: JsonPkpSignSdkParams) => Promise<SigResponse>;
    /**
     *
     * Encrypt data using the LIT network public key.
     *
     * @param { EncryptSdkParams } params
     * @param params.dataToEncrypt - The data to encrypt
     * @param params.accessControlConditions - (optional) The access control conditions for the data
     * @param params.evmContractConditions - (optional) The EVM contract conditions for the data
     * @param params.solRpcConditions - (optional) The Solidity RPC conditions for the data
     * @param params.unifiedAccessControlConditions - (optional) The unified access control conditions for the data
     *
     * @return { Promise<EncryptResponse> } The encrypted ciphertext and the hash of the data
     *
     * @throws { Error } if the LIT node client is not ready
     * @throws { Error } if the subnetPubKey is null
     */
    encrypt: (params: EncryptSdkParams) => Promise<EncryptResponse>;
    /**
     *
     * Decrypt ciphertext with the LIT network.
     *
     */
    decrypt: (params: DecryptRequest) => Promise<DecryptResponse>;
    getLitResourceForEncryption: (params: EncryptRequest) => Promise<LitAccessControlConditionResource>;
    private _getIdentityParamForEncryption;
    /** ============================== SESSION ============================== */
    /**
     * Sign a session public key using a PKP, which generates an authSig.
     * @returns {Object} An object containing the resulting signature.
     */
    signSessionKey: (params: SignSessionKeyProp) => Promise<SignSessionKeyResponse>;
    private _isSuccessNodePromises;
    getSignSessionKeyShares: (url: string, params: GetSignSessionKeySharesProp, requestId: string) => Promise<any>;
    /**
     *
     * Retrieves or generates sessionSigs (think access token) for accessing Lit Network resources.
     *
     * How this function works on a high level:
     * 1. Generate or retrieve [session keys](https://v6-api-doc-lit-js-sdk.vercel.app/interfaces/types_src.SessionKeyPair.html) (a public and private key pair)
     * 2. Generate or retrieve the [`AuthSig`](https://v6-api-doc-lit-js-sdk.vercel.app/interfaces/types_src.AuthSig.html) that specifies the session [abilities](https://v6-api-doc-lit-js-sdk.vercel.app/enums/auth_helpers_src.LitAbility.html)
     * 3. Sign the specific resources with the session key
     *
     * The process follows these steps:
     * 1. Retrieves or generates a session key pair (Ed25519) for the user's device. The session key is either fetched from local storage or newly created if not found. The key does not expire.
     * 2. Generates an authentication signature (`authSig`) by signing an ERC-5573 “Sign-in with Ethereum” message, which includes resource ability requests, capabilities, expiration, the user's device session public key, and a nonce. The `authSig` is retrieved from local storage, and if it has expired, the user will be prompted to re-sign.
     * 3. Uses the session private key to sign the session public key along with the resource ability requests, capabilities, issuedAt, and expiration details. This creates a device-generated signature.
     * 4. Constructs the session signatures (`sessionSigs`) by including the device-generated signature and the original message. The `sessionSigs` provide access to Lit Network features such as `executeJs` and `pkpSign`.
     *
     * See Sequence Diagram: https://www.plantuml.com/plantuml/uml/VPH1RnCn48Nl_XLFlT1Av00eGkm15QKLWY8K9K9SO-rEar4sjcLFalBl6NjJAuaMRl5utfjlPjQvJsAZx7UziQtuY5-9eWaQufQ3TOAR77cJy407Rka6zlNdHTRouUbIzSEtjiTIBUswg5v_NwMnuAVlA9KKFPN3I0x9qSSj7bqNF3iPykl9c4o9oUSJMuElv2XQ8IHAYRt3bluWM8wuVUpUJwVlFjsP8JUh5B_1DyV2AYdD6DjhLsTQTaYd3W3ad28SGWqM997fG5ZrB9DJqOaALuRwH1TMpik8tIYze-E8OrPKU5I6cMqtem2kCqOhr4vdaRAvtSjcoMkTo68scKu_Vi1EPMfrP_xVtj7sFMaHNg-6GVqk0MW0z18uKdVULTvDWtdqko28b7KktvUB2hKOBd1asU2QgDfTzrj7T4bLPdv6TR0zLwPQKkkZpIRTY4CTMbrBpg_VKuXyi49beUAHqIlirOUrL2zq9JPPdpRR5OMLVQGoGlLcjyRyQNv6MHz4W_fG42W--xWhUfNyOxiLL1USS6lRLeyAkYLNjrkVJuClm_qp5I8Lq0krUw7lwIt2DgY9oiozrjA_Yhy0
     *
     * Note: When generating session signatures for different PKPs or auth methods,
     * be sure to call disconnectWeb3 to clear auth signatures stored in local storage
     *
     * @param { GetSessionSigsProps } params
     *
     * An example of how this function is used can be found in the Lit developer-guides-code repository [here](https://github.com/LIT-Protocol/developer-guides-code/tree/master/session-signatures/getSessionSigs).
     *
     */
    getSessionSigs: (params: GetSessionSigsProps) => Promise<SessionSigsMap>;
    /**
     * Retrieves the PKP sessionSigs.
     *
     * @param params - The parameters for retrieving the PKP sessionSigs.
     * @returns A promise that resolves to the PKP sessionSigs.
     * @throws An error if any of the required parameters are missing or if `litActionCode` and `ipfsId` exist at the same time.
     */
    getPkpSessionSigs: (params: GetPkpSessionSigs) => Promise<SessionSigsMap>;
    /**
     * Retrieves session signatures specifically for Lit Actions.
     * Unlike `getPkpSessionSigs`, this function requires either `litActionCode` or `litActionIpfsId`, and `jsParams` must be provided.
     *
     * @param params - The parameters required for retrieving the session signatures.
     * @returns A promise that resolves with the session signatures.
     */
    getLitActionSessionSigs: (params: GetLitActionSessionSigs) => Promise<SessionSigsMap>;
    /**
     *
     * Get Session Key URI eg. lit:session:0x1234
     *
     * @param publicKey is the public key of the session key
     * @returns { string } the session key uri
     */
    getSessionKeyUri: (publicKey: string) => string;
    /**
     * Authenticates an Auth Method for claiming a Programmable Key Pair (PKP).
     * A {@link MintCallback} can be defined for custom on chain interactions
     * by default the callback will forward to a relay server for minting on chain.
     * @param {ClaimKeyRequest} params an Auth Method and {@link MintCallback}
     * @returns {Promise<ClaimKeyResponse>}
     */
    claimKeyId(params: ClaimRequest<ClaimProcessor>): Promise<ClaimKeyResponse>;
}
