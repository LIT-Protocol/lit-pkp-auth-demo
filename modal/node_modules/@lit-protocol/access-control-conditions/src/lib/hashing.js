"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashSolRpcConditions = exports.hashEVMContractConditions = exports.hashAccessControlConditions = exports.hashResourceIdForSigning = exports.hashResourceId = exports.hashUnifiedAccessControlConditions = void 0;
const constants_1 = require("@lit-protocol/constants");
const misc_1 = require("@lit-protocol/misc");
const uint8arrays_1 = require("@lit-protocol/uint8arrays");
const canonicalFormatter_1 = require("./canonicalFormatter");
// Same as:
// const unifiedAccs = [
//   {
//     conditionType: 'evmBasic',
//     contractAddress: '',
//     standardContractType: '',
//     chain: 'ethereum',
//     method: '',
//     parameters: [':userAddress'],
//     returnValueTest: {
//       comparator: '=',
//       value: '0xBD4701851e9C9a22f448860A78872A00Da87899e',
//     },
//   },
//   { operator: 'or' },
//   {
//     conditionType: 'evmBasic',
//     contractAddress: '',
//     standardContractType: '',
//     chain: 'ethereum',
//     method: '',
//     parameters: [':userAddress'],
//     returnValueTest: {
//       comparator: '=',
//       value: '0x93E47A604BA72899a5f8dF986cF26C97AfdaE2A0',
//     },
//   },
// ];
// export const generateUnifiedAccsForRLIDelegation = async (
//   ethAddresses: string[]
// ): Promise<string> => {
//   const unifiedAccs: any[] = [];
//   ethAddresses.forEach((address, index) => {
//     const condition = {
//       conditionType: 'evmBasic',
//       contractAddress: '',
//       standardContractType: '',
//       chain: 'ethereum',
//       method: '',
//       parameters: [':userAddress'],
//       returnValueTest: {
//         comparator: '=',
//         value: address,
//       },
//     };
//     unifiedAccs.push(condition);
//     // Add the operator for all but the last address
//     if (index < ethAddresses.length - 1) {
//       unifiedAccs.push({ operator: 'or' });
//     }
//   });
//   const hash = await hashUnifiedAccessControlConditions(unifiedAccs);
//   return uint8arrayToString(new Uint8Array(hash), 'base16');
// };
/**
 *
 * Hash the unified access control conditions using SHA-256 in a deterministic way.
 *
 * @param { UnifiedAccessControlConditions } unifiedAccessControlConditions - The unified access control conditions to hash.
 * @returns { Promise<ArrayBuffer> } A promise that resolves to an ArrayBuffer that contains the hash
 */
const hashUnifiedAccessControlConditions = (unifiedAccessControlConditions) => {
    (0, misc_1.log)('unifiedAccessControlConditions:', unifiedAccessControlConditions);
    const conditions = unifiedAccessControlConditions.map((condition) => {
        return (0, canonicalFormatter_1.canonicalUnifiedAccessControlConditionFormatter)(condition);
    });
    (0, misc_1.log)('conditions:', conditions);
    // check if there's any undefined in the conditions
    const hasUndefined = conditions.some((c) => c === undefined);
    if (hasUndefined) {
        throw new constants_1.InvalidAccessControlConditions({
            info: {
                conditions,
            },
        }, 'Invalid access control conditions');
    }
    if (conditions.length === 0) {
        throw new constants_1.InvalidAccessControlConditions({
            info: {
                conditions,
            },
        }, 'No conditions provided');
    }
    const toHash = JSON.stringify(conditions);
    (0, misc_1.log)('Hashing unified access control conditions: ', toHash);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashUnifiedAccessControlConditions = hashUnifiedAccessControlConditions;
/**
 *
 * Hash resource id
 *
 * @param { JsonSigningResourceId } resourceId
 *
 * @returns { Promise<ArrayBuffer> }
 *
 */
const hashResourceId = (resourceId) => {
    const resId = (0, canonicalFormatter_1.canonicalResourceIdFormatter)(resourceId);
    const toHash = JSON.stringify(resId);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashResourceId = hashResourceId;
/**
 *
 * Hash resourceId for signing
 *
 * @param { JSONSigningResourceId } resourceId
 *
 * @returns { string } example: "5b36d72f2145af3617e5da2a8a626f9f42e64ed14340622bdfe1a6f0702b9e8d"
 */
const hashResourceIdForSigning = async (resourceId) => {
    const hashed = await (0, exports.hashResourceId)(resourceId);
    return (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashed), 'base16');
};
exports.hashResourceIdForSigning = hashResourceIdForSigning;
/**
 *
 * Hash access control conditions
 *
 * @param { AccessControlConditions } accessControlConditions
 *
 * @returns { Promise<ArrayBuffer> } example: {"data": [83, 176, 31, 130, 12, 130, 232, 109, 126, 76, 216, 4, 184, 166, 246, 134, 130, 34, 30, 235, 125, 247, 111, 212, 62, 231, 119, 200, 202, 171, 86, 40], "type": "Buffer"}
 *
 */
const hashAccessControlConditions = (accessControlConditions) => {
    const conds = accessControlConditions.map((c) => (0, canonicalFormatter_1.canonicalAccessControlConditionFormatter)(c));
    const toHash = JSON.stringify(conds);
    (0, misc_1.log)('Hashing access control conditions: ', toHash);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashAccessControlConditions = hashAccessControlConditions;
/**
 *
 * Hash EVM access control conditions
 *
 * @param { EvmContractConditions } evmContractConditions
 *
 * @returns { Promise<ArrayBuffer> } {"data": [216, 92, 128, 31, 171, 114, 74, 115, 133, 44, 234, 171, 214, 205, 228, 137, 117, 238, 14, 229, 254, 239, 97, 126, 1, 20, 166, 144, 176, 147, 217, 32], "type": "Buffer"}
 *
 */
const hashEVMContractConditions = (evmContractConditions) => {
    const conds = evmContractConditions.map((c) => (0, canonicalFormatter_1.canonicalEVMContractConditionFormatter)(c));
    const toHash = JSON.stringify(conds);
    (0, misc_1.log)('Hashing evm contract conditions: ', toHash);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashEVMContractConditions = hashEVMContractConditions;
/**
 *
 * Hash SOL access control conditions
 *
 * @param { SolRpcConditions } solRpcConditions
 *
 * @returns { Promise<ArrayBuffer> }
 *
 */
const hashSolRpcConditions = (solRpcConditions) => {
    const conds = solRpcConditions.map((c) => (0, canonicalFormatter_1.canonicalSolRpcConditionFormatter)(c));
    const toHash = JSON.stringify(conds);
    (0, misc_1.log)('Hashing sol rpc conditions: ', toHash);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashSolRpcConditions = hashSolRpcConditions;
//# sourceMappingURL=hashing.js.map