"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LitRelay = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const constants_1 = require("@lit-protocol/constants");
const WebAuthnProvider_1 = tslib_1.__importDefault(require("./providers/WebAuthnProvider"));
const utils_1 = require("./utils");
/**
 * Class that communicates with Lit relay server
 */
class LitRelay {
    /** URL for Lit's relay server */
    static getRelayUrl(litNetwork) {
        const relayerUrl = constants_1.RELAYER_URL_BY_NETWORK[litNetwork];
        if (!relayerUrl) {
            throw new constants_1.WrongNetworkException({
                info: {
                    litNetwork,
                },
            }, `Relay URL not found for network ${litNetwork}`);
        }
        return relayerUrl;
    }
    /**
     * Create a Relay instance
     *
     * @param {LitRelayConfig} config
     * @param {string} [config.relayApiKey] - API key for Lit's relay server
     * @param {string} [config.relayUrl] - URL for Lit's relay server. If not provided, will default to the last dev relay server.
     */
    constructor(config) {
        /**
         * Route for minting PKP
         */
        this.mintRoute = '/mint-next-and-add-auth-methods';
        /**
         * Route for fetching PKPs
         */
        this.fetchRoute = '/fetch-pkps-by-auth-method';
        this.relayUrl =
            config.relayUrl || LitRelay.getRelayUrl(constants_1.LIT_NETWORK.DatilDev);
        this.relayApiKey = config.relayApiKey || '';
        (0, utils_1.log)("Lit's relay server URL:", this.relayUrl);
    }
    /**
     * Mint a new PKP for the given auth method
     *
     * @param {string} body - Body of the request
     *
     * @returns {Promise<IRelayMintResponse>} Response from the relay server
     */
    async mintPKP(body) {
        const response = await fetch(`${this.relayUrl}${this.mintRoute}`, {
            method: 'POST',
            headers: {
                'api-key': this.relayApiKey,
                'Content-Type': 'application/json',
            },
            body: body,
        });
        if (response.status < 200 || response.status >= 400) {
            (0, utils_1.log)('Something wrong with the API call', await response.json());
            const err = new Error('Unable to mint PKP through relay server');
            throw err;
        }
        else {
            const resBody = await response.json();
            (0, utils_1.log)('Successfully initiated minting PKP with relayer');
            return resBody;
        }
    }
    /**
     * Mints a new pkp with all AuthMethods provided. Allows for permissions and flags to be set separately.
     * If no permissions are provided then each auth method will be assigned `1` for sign anything
     * If no flags are provided then `sendPkpToitself` will be false, and `addPkpEthAddressAsPermittedAddress` will be true
     * It is then up to the implementor to transfer the pkp nft to the pkp address.
     * **note** When adding permissions, each permission should be added in the same order the auth methods are ordered
     *
     * @throws {Error} - Throws an error if no AuthMethods are given
     * @param {AuthMethod[]} authMethods - AuthMethods authentication methods to be added to the pkp
     * @param {{ pkpPermissionScopes?: number[][]; sendPkpToitself?: boolean; addPkpEthAddressAsPermittedAddress?: boolean;}} options
     *
     * @returns {Promise<{pkpTokenId?: string; pkpEthAddress?: string; pkpPublicKey?: string}>} pkp information
     */
    async mintPKPWithAuthMethods(authMethods, options) {
        if (authMethods.length < 1) {
            throw new constants_1.InvalidParamType({
                info: {
                    authMethods,
                    options,
                },
            }, 'Must provide at least one auth method');
        }
        if (!options.pkpPermissionScopes ||
            options.pkpPermissionScopes.length < 1) {
            options.pkpPermissionScopes = [];
            for (let i = 0; i < authMethods.length; i++) {
                options.pkpPermissionScopes.push([
                    ethers_1.ethers.BigNumber.from('1').toNumber(),
                ]);
            }
        }
        const reqBody = {
            keyType: 2,
            permittedAuthMethodTypes: authMethods.map((value) => {
                return value.authMethodType;
            }),
            permittedAuthMethodScopes: options.pkpPermissionScopes,
            addPkpEthAddressAsPermittedAddress: options.addPkpEthAddressAsPermittedAddress ?? true,
            sendPkpToItself: options.sendPkpToitself ?? false,
        };
        const permittedAuthMethodIds = [];
        const permittedAuthMethodPubkeys = [];
        for (const authMethod of authMethods) {
            const id = await (0, utils_1.getAuthIdByAuthMethod)(authMethod);
            permittedAuthMethodIds.push(id);
            if (authMethod.authMethodType === constants_1.AUTH_METHOD_TYPE.WebAuthn) {
                permittedAuthMethodPubkeys.push(WebAuthnProvider_1.default.getPublicKeyFromRegistration(JSON.parse(authMethod.accessToken)));
            }
            else {
                // only webauthn has a `authMethodPubkey`
                permittedAuthMethodPubkeys.push('0x');
            }
        }
        reqBody.permittedAuthMethodIds = permittedAuthMethodIds;
        reqBody.permittedAuthMethodPubkeys = permittedAuthMethodPubkeys;
        const mintRes = await this.mintPKP(JSON.stringify(reqBody));
        if (!mintRes || !mintRes.requestId) {
            throw new constants_1.NetworkError({
                info: {
                    mintRes,
                },
            }, `Missing mint response or request ID from mint response ${mintRes.error}`);
        }
        const pollerResult = await this.pollRequestUntilTerminalState(mintRes.requestId);
        return {
            pkpTokenId: pollerResult.pkpTokenId,
            pkpPublicKey: pollerResult.pkpPublicKey,
            pkpEthAddress: pollerResult.pkpEthAddress,
        };
    }
    /**
     * Poll the relay server for status of minting request
     *
     * @param {string} requestId - Request ID to poll, likely the minting transaction hash
     * @param {number} [pollInterval] - Polling interval in milliseconds
     * @param {number} [maxPollCount] - Maximum number of times to poll
     *
     * @returns {Promise<IRelayPollStatusResponse>} Response from the relay server
     */
    async pollRequestUntilTerminalState(requestId, pollInterval = 15000, maxPollCount = 20) {
        for (let i = 0; i < maxPollCount; i++) {
            const response = await fetch(`${this.relayUrl}/auth/status/${requestId}`, {
                method: 'GET',
                headers: {
                    'api-key': this.relayApiKey,
                },
            });
            if (response.status < 200 || response.status >= 400) {
                (0, utils_1.log)('Something wrong with the API call', await response.json());
                const err = new Error(`Unable to poll the status of this mint PKP transaction: ${requestId}`);
                throw err;
            }
            const resBody = await response.json();
            (0, utils_1.log)('Response OK', { body: resBody });
            if (resBody.error) {
                // exit loop since error
                (0, utils_1.log)('Something wrong with the API call', {
                    error: resBody.error,
                });
                const err = new Error(resBody.error);
                throw err;
            }
            else if (resBody.status === 'Succeeded') {
                // exit loop since success
                (0, utils_1.log)('Successfully authed', { ...resBody });
                return resBody;
            }
            // otherwise, sleep then continue polling
            await new Promise((r) => setTimeout(r, pollInterval));
        }
        // at this point, polling ended and still no success, set failure status
        // console.error(`Hmm this is taking longer than expected...`);
        const err = new Error('Polling for mint PKP transaction status timed out');
        throw err;
    }
    /**
     * Fetch PKPs associated with the given auth method
     *
     * @param {string} body - Body of the request
     *
     * @returns {Promise<IRelayFetchResponse>} Response from the relay server
     */
    async fetchPKPs(body) {
        const response = await fetch(`${this.relayUrl}${this.fetchRoute}`, {
            method: 'POST',
            headers: {
                'api-key': this.relayApiKey,
                'Content-Type': 'application/json',
            },
            body: body,
        });
        if (response.status < 200 || response.status >= 400) {
            console.warn('Something wrong with the API call', await response.json());
            // console.log("Uh oh, something's not quite right.");
            const err = new Error('Unable to fetch PKPs through relay server');
            throw err;
        }
        else {
            const resBody = await response.json();
            console.log('Successfully fetched PKPs with relayer');
            return resBody;
        }
    }
    /**
     * Generate options for registering a new credential to pass to the authenticator
     *
     * @param {string} [username] - Optional username to associate with the credential
     *
     * @returns {Promise<any>} Registration options for the browser to pass to the authenticator
     */
    async generateRegistrationOptions(username) {
        let url = `${this.relayUrl}/auth/webauthn/generate-registration-options`;
        if (username && username !== '') {
            url = `${url}?username=${encodeURIComponent(username)}`;
        }
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'api-key': this.relayApiKey,
            },
        });
        if (response.status < 200 || response.status >= 400) {
            const err = new Error(`Unable to generate registration options: ${response}`);
            throw err;
        }
        const registrationOptions = await response.json();
        return registrationOptions;
    }
    /**
     * returns the relayUrl
     */
    getUrl() {
        return this.relayUrl;
    }
}
exports.LitRelay = LitRelay;
//# sourceMappingURL=relay.js.map