"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const constants_1 = require("@lit-protocol/constants");
const utils_1 = require("../utils");
const BaseProvider_1 = require("./BaseProvider");
const ethers_1 = require("ethers");
const jose = tslib_1.__importStar(require("jose"));
class AppleProvider extends BaseProvider_1.BaseProvider {
    constructor(options) {
        super(options);
        this.redirectUri = options.redirectUri || window.location.origin;
    }
    /**
     * Redirect user to the Lit's Apple login page
     *
     * @returns {Promise<void>} - Redirects user to Lit login page
     */
    async signIn() {
        // Get login url
        const loginUrl = await (0, utils_1.prepareLoginUrl)('apple', this.redirectUri);
        // Redirect to login url
        window.location.assign(loginUrl);
    }
    /**
     * Validate the URL parameters returned from Lit's login server and return the authentication data
     *
     * @returns {Promise<AuthMethod>} - Auth method object that contains OAuth token
     */
    async authenticate() {
        // Check if current url matches redirect uri
        if (!window.location.href.startsWith(this.redirectUri)) {
            throw new constants_1.UnauthorizedException({
                info: {
                    url: window.location.href,
                    redirectUri: this.redirectUri,
                },
            }, `Current url does not match provided redirect uri`);
        }
        // Check url for params
        const { provider, idToken, state, error } = (0, utils_1.parseLoginParams)(window.location.search);
        // Check if there's an error
        if (error) {
            throw new constants_1.UnknownError({
                info: {
                    error,
                },
                cause: new Error(error),
            }, error ?? 'Received error from discord authentication');
        }
        // Check if provider is Apple
        if (!provider || provider !== 'apple') {
            throw new constants_1.UnauthorizedException({
                info: {
                    provider,
                    redirectUri: this.redirectUri,
                },
            }, 'OAuth provider does not match "apple"');
        }
        // Check if state param matches
        if (!state || (0, utils_1.decode)(decodeURIComponent(state)) !== (0, utils_1.getStateParam)()) {
            throw new constants_1.UnauthorizedException({
                info: {
                    state,
                    redirectUri: this.redirectUri,
                },
            }, 'Invalid state parameter in callback URL');
        }
        // Clear params from url
        window.history.replaceState(null, window.document.title, window.location.pathname);
        // Check if id token is present in url
        if (!idToken) {
            throw new constants_1.UnauthorizedException({
                info: {
                    idToken,
                    redirectUri: this.redirectUri,
                },
            }, `Missing ID token in callback URL`);
        }
        const authMethod = {
            authMethodType: constants_1.AUTH_METHOD_TYPE.AppleJwt,
            accessToken: idToken,
        };
        return authMethod;
    }
    /**
     * Get auth method id that can be used to look up and interact with
     * PKPs associated with the given auth method
     *
     * @param {AuthMethod} authMethod - Auth method object
     *
     * @returns {Promise<string>} - Auth method id
     */
    async getAuthMethodId(authMethod) {
        return AppleProvider.authMethodId(authMethod);
    }
    static async authMethodId(authMethod) {
        const tokenPayload = jose.decodeJwt(authMethod.accessToken);
        const userId = tokenPayload['sub'];
        const audience = tokenPayload['aud'];
        const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${audience}`));
        return authMethodId;
    }
}
exports.default = AppleProvider;
//# sourceMappingURL=AppleProvider.js.map