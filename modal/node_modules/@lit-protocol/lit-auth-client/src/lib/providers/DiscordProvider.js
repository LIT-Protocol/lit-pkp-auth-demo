"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@lit-protocol/constants");
const BaseProvider_1 = require("./BaseProvider");
const utils_1 = require("../utils");
const ethers_1 = require("ethers");
class DiscordProvider extends BaseProvider_1.BaseProvider {
    constructor(options) {
        super(options);
        this.redirectUri = options.redirectUri || window.location.origin;
        this.clientId = options.clientId || '1052874239658692668';
    }
    /**
     * Redirect user to the Lit's Discord login page
     *
     * @returns {Promise<void>} - Redirects user to Lit login page
     */
    async signIn() {
        // Get login url
        const loginUrl = await (0, utils_1.prepareLoginUrl)('discord', this.redirectUri);
        // Redirect to login url
        window.location.assign(loginUrl);
    }
    /**
     * Validate the URL parameters returned from Lit's login server and return the authentication data
     *
     * @returns {Promise<AuthMethod>} - Auth method object that contains OAuth token
     */
    async authenticate() {
        // Check if current url matches redirect uri
        if (!window.location.href.startsWith(this.redirectUri)) {
            throw new constants_1.UnauthorizedException({
                info: {
                    url: window.location.href,
                    redirectUri: this.redirectUri,
                },
            }, `Current url does not match provided redirect uri`);
        }
        // Check url for params
        const { provider, accessToken, state, error } = (0, utils_1.parseLoginParams)(window.location.search);
        // Check if there's an error
        if (error) {
            throw new constants_1.UnknownError({
                info: {
                    error,
                },
                cause: new Error(error),
            }, error ?? 'Received error from discord authentication');
        }
        // Check if provider is Discord
        if (!provider || provider !== 'discord') {
            throw new constants_1.UnauthorizedException({
                info: {
                    provider,
                    redirectUri: this.redirectUri,
                },
            }, 'OAuth provider does not match "discord"');
        }
        // Check if state param matches
        if (!state || (0, utils_1.decode)(decodeURIComponent(state)) !== (0, utils_1.getStateParam)()) {
            throw new constants_1.UnauthorizedException({
                info: {
                    state,
                    redirectUri: this.redirectUri,
                },
            }, 'Invalid state parameter in callback URL');
        }
        // Clear params from url
        window.history.replaceState(null, window.document.title, window.location.pathname);
        // Check if access token is present in url
        if (!accessToken) {
            throw new constants_1.UnauthorizedException({
                info: {
                    accessToken,
                    redirectUri: this.redirectUri,
                },
            }, `Missing access token in callback URL`);
        }
        const authMethod = {
            authMethodType: constants_1.AUTH_METHOD_TYPE.Discord,
            accessToken: accessToken,
        };
        return authMethod;
    }
    /**
     * Sign in using popup window
     *
     * @param baseURL
     */
    async signInUsingPopup(baseURL) {
        const width = 500;
        const height = 600;
        const left = window.screen.width / 2 - width / 2;
        const top = window.screen.height / 2 - height / 2;
        const url = await (0, utils_1.prepareLoginUrl)('discord', this.redirectUri, baseURL);
        const popup = window.open(`${url}&caller=${window.location.origin}`, 'popup', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, copyhistory=no, width=${width}, height=${height}, top=${top}, left=${left}`);
        if (!popup) {
            throw new constants_1.UnknownError({}, 'Failed to open popup window');
        }
        return new Promise((resolve, reject) => {
            // window does not have a closed event, so we need to poll using a timer
            const interval = setInterval(() => {
                if (popup.closed) {
                    clearInterval(interval);
                    reject(new Error('User closed popup window'));
                }
            }, 1000);
            window.addEventListener('message', (event) => {
                if (event.origin !== (baseURL || utils_1.LIT_LOGIN_GATEWAY)) {
                    return;
                }
                const { provider, token, error } = event.data;
                if (error) {
                    clearInterval(interval);
                    reject(new Error(error));
                }
                if (provider === 'discord' && token) {
                    clearInterval(interval);
                    popup.close();
                    resolve({
                        authMethodType: constants_1.AUTH_METHOD_TYPE.Discord,
                        accessToken: token,
                    });
                }
            });
        });
    }
    /**
     * Get auth method id that can be used to look up and interact with
     * PKPs associated with the given auth method
     *
     * @param {AuthMethod} authMethod - Auth method object
     *
     * @returns {Promise<string>} - Auth method id
     */
    async getAuthMethodId(authMethod) {
        const userId = await this._fetchDiscordUser(authMethod.accessToken);
        const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${this.clientId}`));
        return authMethodId;
    }
    static async authMethodId(authMethod, clientId) {
        const _clientId = clientId || '1052874239658692668';
        // -- get user id from access token
        let userId;
        const meResponse = await fetch('https://discord.com/api/users/@me', {
            method: 'GET',
            headers: {
                authorization: `Bearer ${authMethod.accessToken}`,
            },
        });
        if (meResponse.ok) {
            const user = await meResponse.json();
            userId = user.id;
        }
        else {
            throw new constants_1.UnknownError({}, 'Unable to verify Discord account');
        }
        // -- get auth method id
        const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${_clientId}`));
        return authMethodId;
    }
    /**
     * Fetch Discord user ID
     *
     * @param {string} accessToken - Discord access token
     *
     * @returns {Promise<string>} - Discord user ID
     */
    async _fetchDiscordUser(accessToken) {
        const meResponse = await fetch('https://discord.com/api/users/@me', {
            method: 'GET',
            headers: {
                authorization: `Bearer ${accessToken}`,
            },
        });
        if (meResponse.ok) {
            const user = await meResponse.json();
            return user.id;
        }
        else {
            throw new constants_1.UnknownError({}, 'Unable to verify Discord account');
        }
    }
}
exports.default = DiscordProvider;
//# sourceMappingURL=DiscordProvider.js.map