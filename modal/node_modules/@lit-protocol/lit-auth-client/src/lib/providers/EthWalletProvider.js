"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const siwe_1 = require("siwe");
const constants_1 = require("@lit-protocol/constants");
const lit_node_client_1 = require("@lit-protocol/lit-node-client");
const misc_1 = require("@lit-protocol/misc");
const BaseProvider_1 = require("./BaseProvider");
class EthWalletProvider extends BaseProvider_1.BaseProvider {
    constructor(options) {
        super(options);
        const { domain, origin } = EthWalletProvider.getDomainAndOrigin(options);
        this.domain = domain;
        this.origin = origin;
    }
    static getDomainAndOrigin(options) {
        let domain, origin;
        try {
            domain = options.domain || window.location.hostname;
            origin = options.origin || window.location.origin;
        }
        catch (e) {
            (0, misc_1.log)('⚠️ Error getting "domain" and "origin" from window object, defaulting to "localhost" and "http://localhost"');
            domain = options.domain || 'localhost';
            origin = options.origin || 'http://localhost';
        }
        return { domain, origin };
    }
    /**
     * Generate a wallet signature to use as an auth method
     *
     * @param {EthWalletAuthenticateOptions} options
     * @param {string} [options.address] - Address to sign with
     * @param {string} [options.chain] - Name of chain to use for signature
     * @param {number} [options.expiration] - When the auth signature expires
     *
     * @returns {Promise<AuthMethod>} - Auth method object containing the auth signature
     */
    async authenticate(options) {
        if (!options) {
            throw new constants_1.InvalidArgumentException({
                info: {
                    options,
                },
            }, 'Options are required to authenticate with EthWalletProvider.');
        }
        return EthWalletProvider.authenticate({
            signer: options,
            address: options.address,
            chain: options.chain,
            litNodeClient: this.litNodeClient,
            expiration: options.expiration,
            domain: this.domain,
            origin: this.origin,
        });
    }
    /**
     * Generate a wallet signature to use as an auth method
     *
     * @param {EthWalletAuthenticateOptions} options
     * @param {object} options.signer - Signer object
     * @param {object} options.litNodeClient - LitNodeClient instance
     * @param {string} [options.address] - Address to sign with
     * @param {string} [options.chain] - Name of chain to use for signature
     * @param {number} [options.expiration] - When the auth signature expires
     * @param {string} [options.domain] - Domain from which the signing request is made
     * @param {string} [options.origin] - Origin from which the signing request is made
     * @returns {Promise<AuthMethod>} - Auth method object containing the auth signature
     * @static
     * @memberof EthWalletProvider
     *
     * @example
     * ```typescript
     *   const authMethod = await EthWalletProvider.authenticate({
     *      signer: wallet,
     *      litNodeClient: client,
     *   });
     * ```
     */
    static async authenticate({ signer, address, chain, litNodeClient, expiration, domain, origin, }) {
        chain = chain || 'ethereum';
        let authSig;
        // convert to EIP-55 format or else SIWE complains
        address =
            address ||
                (await signer?.getAddress()) ||
                signer?.address;
        if (!address) {
            throw new constants_1.InvalidArgumentException({
                info: {
                    address,
                    signer,
                },
            }, `Address is required to authenticate with EthWalletProvider. Cannot find it in signer or options.`);
        }
        address = ethers_1.ethers.utils.getAddress(address);
        if (signer?.signMessage) {
            // Get chain ID or default to Ethereum mainnet
            const selectedChain = constants_1.LIT_CHAINS[chain];
            const chainId = selectedChain?.chainId ? selectedChain.chainId : 1;
            // Get expiration or default to 24 hours
            expiration =
                expiration || new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString();
            const { domain: resolvedDomain, origin: resolvedOrigin } = EthWalletProvider.getDomainAndOrigin({ domain, origin });
            // Prepare Sign in with Ethereum message
            const preparedMessage = {
                domain: resolvedDomain,
                uri: resolvedOrigin,
                address,
                version: '1',
                chainId,
                expirationTime: expiration,
                nonce: await litNodeClient.getLatestBlockhash(),
            };
            const message = new siwe_1.SiweMessage(preparedMessage);
            const toSign = message.prepareMessage();
            // Use provided function to sign message
            const signature = await signer.signMessage(toSign);
            authSig = {
                sig: signature,
                derivedVia: 'web3.eth.personal.sign',
                signedMessage: toSign,
                address: address,
            };
        }
        else {
            authSig = await (0, lit_node_client_1.checkAndSignAuthMessage)({
                chain,
                nonce: await litNodeClient.getLatestBlockhash(),
            });
        }
        const authMethod = {
            authMethodType: constants_1.AUTH_METHOD_TYPE.EthWallet,
            accessToken: JSON.stringify(authSig),
        };
        return authMethod;
    }
    /**
     * Get auth method id that can be used to look up and interact with
     * PKPs associated with the given auth method
     *
     * @param {AuthMethod} authMethod - Auth method object
     *
     * @returns {Promise<string>} - Auth method id
     */
    async getAuthMethodId(authMethod) {
        return EthWalletProvider.authMethodId(authMethod);
    }
    static async authMethodId(authMethod) {
        let address;
        try {
            address = JSON.parse(authMethod.accessToken).address;
        }
        catch (err) {
            throw new constants_1.WrongParamFormat({
                info: {
                    authMethod,
                },
                cause: err,
            }, 'Error when parsing auth method to generate auth method ID for Eth wallet');
        }
        return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${address}:lit`));
    }
}
exports.default = EthWalletProvider;
//# sourceMappingURL=EthWalletProvider.js.map