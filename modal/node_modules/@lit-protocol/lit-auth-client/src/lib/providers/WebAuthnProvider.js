"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const constants_1 = require("@lit-protocol/constants");
const ethers_1 = require("ethers");
const base64url_1 = tslib_1.__importDefault(require("base64url"));
const utils_1 = require("../utils");
const BaseProvider_1 = require("./BaseProvider");
class WebAuthnProvider extends BaseProvider_1.BaseProvider {
    constructor(options) {
        super(options);
        this.rpName = options.rpName || 'lit';
    }
    /**
     * Generate registration options for the browser to pass to a supported authenticator
     *
     * @param {string} username - Username to register credential with
     *
     * @returns {Promise<PublicKeyCredentialCreationOptionsJSON>} - Options to pass to the authenticator
     */
    async register(username) {
        return await this.relay.generateRegistrationOptions(username);
    }
    /**
     * Mint PKP with verified registration data
     *
     * @param {PublicKeyCredentialCreationOptionsJSON} options - Registration options to pass to the authenticator
     * @param {MintRequestBody} [customArgs] - Extra data to overwrite default params
     *
     * @returns {Promise<string>} - Mint transaction hash
     */
    async verifyAndMintPKPThroughRelayer(options, customArgs) {
        // Submit registration options to the authenticator
        const { startRegistration } = await Promise.resolve().then(() => tslib_1.__importStar(require('@simplewebauthn/browser')));
        const attResp = await startRegistration(options);
        // Get auth method id
        const authMethodId = await this.getAuthMethodId({
            authMethodType: constants_1.AUTH_METHOD_TYPE.WebAuthn,
            accessToken: JSON.stringify(attResp),
        });
        // Get auth method pub key
        const authMethodPubkey = WebAuthnProvider.getPublicKeyFromRegistration(attResp);
        // Format args for relay server
        const defaultArgs = {
            keyType: 2,
            permittedAuthMethodTypes: [constants_1.AUTH_METHOD_TYPE.WebAuthn],
            permittedAuthMethodIds: [authMethodId],
            permittedAuthMethodPubkeys: [authMethodPubkey],
            permittedAuthMethodScopes: [[ethers_1.ethers.BigNumber.from('1')]],
            addPkpEthAddressAsPermittedAddress: true,
            sendPkpToItself: true,
        };
        const args = {
            ...defaultArgs,
            ...customArgs,
        };
        const body = JSON.stringify(args);
        // Mint PKP
        const mintRes = await this.relay.mintPKP(body);
        if (!mintRes || !mintRes.requestId) {
            throw new constants_1.UnknownError({
                info: {
                    mintRes,
                },
            }, 'Missing mint response or request ID from relay server');
        }
        return mintRes.requestId;
    }
    /**
     * @override
     * This method is not applicable for WebAuthnProvider and should not be used.
     * Use verifyAndMintPKPThroughRelayer instead to mint a PKP for a WebAuthn credential.
     *
     * @throws {Error} - Throws an error when called for WebAuthnProvider.
     */
    async mintPKPThroughRelayer() {
        throw new constants_1.RemovedFunctionError({
            info: {
                method: 'mintPKPThroughRelayer',
            },
        }, 'Use verifyAndMintPKPThroughRelayer for WebAuthnProvider instead.');
    }
    /**
     * Authenticate with a WebAuthn credential and return the relevant authentication data
     *
     * @returns {Promise<AuthMethod>} - Auth method object containing WebAuthn authentication data
     */
    async authenticate() {
        const blockHash = await this.litNodeClient.getLatestBlockhash();
        // Turn into byte array
        const blockHashBytes = ethers_1.ethers.utils.arrayify(blockHash);
        // Construct authentication options
        const rpId = (0, utils_1.getRPIdFromOrigin)(window.location.origin);
        const authenticationOptions = {
            challenge: (0, base64url_1.default)(Buffer.from(blockHashBytes)),
            timeout: 60000,
            userVerification: 'required',
            rpId,
        };
        // Authenticate with WebAuthn
        const { startAuthentication } = await Promise.resolve().then(() => tslib_1.__importStar(require('@simplewebauthn/browser')));
        const authenticationResponse = await startAuthentication(authenticationOptions);
        const actualAuthenticationResponse = JSON.parse(JSON.stringify(authenticationResponse));
        // Make sure userHandle is base64url encoded if it exists
        const userHandle = authenticationResponse.response?.userHandle;
        if (userHandle) {
            actualAuthenticationResponse.response.userHandle =
                base64url_1.default.encode(userHandle);
        }
        const authMethod = {
            authMethodType: constants_1.AUTH_METHOD_TYPE.WebAuthn,
            accessToken: JSON.stringify(actualAuthenticationResponse),
        };
        return authMethod;
    }
    /**
     * Get auth method id that can be used to look up and interact with
     * PKPs associated with the given auth method
     *
     * @param {AuthMethod} authMethod - Auth method object
     *
     * @returns {Promise<string>} - Auth method id
     */
    async getAuthMethodId(authMethod) {
        return WebAuthnProvider.authMethodId(authMethod, this.rpName);
    }
    static async authMethodId(authMethod, rpName) {
        let credentialId;
        const rpNameToUse = rpName || 'lit';
        try {
            credentialId = JSON.parse(authMethod.accessToken).rawId;
        }
        catch (err) {
            throw new constants_1.WrongParamFormat({
                info: {
                    authMethod,
                },
                cause: err,
            }, 'Error when parsing auth method to generate auth method ID for Eth wallet');
        }
        const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${credentialId}:${rpNameToUse}`));
        return authMethodId;
    }
    /**
     * Parse the WebAuthn registration response to get the WebAuthn credential public key
     *
     * @param {RegistrationResponseJSON} attResp - WebAuthn registration response
     *
     * @returns {string} - WebAuthn credential public key in hex format
     */
    static getPublicKeyFromRegistration(attResp) {
        let publicKey;
        try {
            // Create a buffer object from the base64 encoded content
            const attestationBuffer = Buffer.from(attResp.response.attestationObject, 'base64');
            // Parse the buffer to reconstruct the object
            // Buffer is COSE formatted, utilities decode the buffer into json, and extract the public key information
            const authenticationResponse = (0, utils_1.parseAuthenticatorData)(attestationBuffer);
            // Public key in cose format to register the auth method
            const publicKeyCoseBuffer = authenticationResponse
                .attestedCredentialData.credentialPublicKey;
            // Encode the public key for contract storage
            publicKey = ethers_1.ethers.utils.hexlify(ethers_1.ethers.utils.arrayify(publicKeyCoseBuffer));
        }
        catch (e) {
            throw new constants_1.UnknownError({
                cause: e,
            }, 'Error while decoding WebAuthn registration response for public key retrieval. Attestation response not encoded as expected');
        }
        return publicKey;
    }
}
exports.default = WebAuthnProvider;
//# sourceMappingURL=WebAuthnProvider.js.map