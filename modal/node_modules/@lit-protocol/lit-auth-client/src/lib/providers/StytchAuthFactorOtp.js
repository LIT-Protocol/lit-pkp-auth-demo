"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@lit-protocol/constants");
const BaseProvider_1 = require("./BaseProvider");
const StytchAuthFactors_1 = require("./StytchAuthFactors");
class StytchAuthFactorOtpProvider extends BaseProvider_1.BaseProvider {
    constructor(params, config, factor) {
        super(params);
        this._params = config;
        this._factor = factor;
    }
    /**
     * Validates claims within a stytch authenticated JSON Web Token
     * Will parse out the given `authentication factor` and use the transport
     * for the otp code as the `user identifier` for the given auth method.
     * @param options authentication option containing the authenticated token
     * @returns {AuthMethod} Authentication Method for auth method type OTP
     *
     */
    async authenticate(options) {
        return new Promise((resolve, reject) => {
            if (!options) {
                reject(new Error('No Authentication options provided, please supply an authenticated JWT'));
            }
            const accessToken = options?.accessToken;
            if (!accessToken) {
                reject(new Error('No access token provided, please provide a stych auth jwt'));
            }
            const parsedToken = StytchAuthFactorOtpProvider._parseJWT(accessToken);
            const factorParser = StytchAuthFactorOtpProvider._resolveAuthFactor(this._factor);
            try {
                factorParser.parser(parsedToken, StytchAuthFactorOtpProvider._provider);
            }
            catch (e) {
                reject(e);
            }
            resolve({
                authMethodType: factorParser.authMethodType,
                accessToken: accessToken,
            });
        });
    }
    /**
     * Get auth method id that can be used to look up and interact with
     * PKPs associated with the given auth method
     *
     * @param {AuthMethod} authMethod - Auth method object
     *
     * @returns {Promise<string>} - Auth method id
     */
    async getAuthMethodId(authMethod) {
        return StytchAuthFactorOtpProvider.authMethodId(authMethod);
    }
    /**
     * Get auth method id that can be used to look up and interact with
     * PKPs associated with the given auth method.
     * Will parse out the given `authentication factor` and use the transport
     * for the otp code as the `user identifier` for the given auth method.
     * @param {AuthMethod} authMethod - Auth method object
     *
     * @returns {Promise<string>} - Auth method id
     */
    static async authMethodId(authMethod) {
        return new Promise((resolve, reject) => {
            const accessToken = authMethod.accessToken;
            const parsedToken = StytchAuthFactorOtpProvider._parseJWT(accessToken);
            let factor = 'email';
            switch (authMethod.authMethodType) {
                case constants_1.AUTH_METHOD_TYPE.StytchEmailFactorOtp:
                    factor = 'email';
                    break;
                case constants_1.AUTH_METHOD_TYPE.StytchSmsFactorOtp:
                    factor = 'sms';
                    break;
                case constants_1.AUTH_METHOD_TYPE.StytchWhatsAppFactorOtp:
                    factor = 'whatsApp';
                    break;
                case constants_1.AUTH_METHOD_TYPE.StytchTotpFactorOtp:
                    factor = 'totp';
                    break;
                default:
                    throw new constants_1.InvalidArgumentException({
                        info: {
                            authMethodType: authMethod.authMethodType,
                        },
                    }, 'Unsupport stytch auth type');
            }
            const factorParser = this._resolveAuthFactor(factor).parser;
            try {
                resolve(factorParser(parsedToken, this._provider));
            }
            catch (e) {
                reject(e);
            }
        });
    }
    static _resolveAuthFactor(factor) {
        switch (factor) {
            case 'email':
                return {
                    parser: StytchAuthFactors_1.emailOtpAuthFactorParser,
                    authMethodType: constants_1.AUTH_METHOD_TYPE.StytchEmailFactorOtp,
                };
            case 'sms':
                return {
                    parser: StytchAuthFactors_1.smsOtpAuthFactorParser,
                    authMethodType: constants_1.AUTH_METHOD_TYPE.StytchSmsFactorOtp,
                };
            case 'whatsApp':
                return {
                    parser: StytchAuthFactors_1.whatsAppOtpAuthFactorParser,
                    authMethodType: constants_1.AUTH_METHOD_TYPE.StytchWhatsAppFactorOtp,
                };
            case 'totp':
                return {
                    parser: StytchAuthFactors_1.totpAuthFactorParser,
                    authMethodType: constants_1.AUTH_METHOD_TYPE.StytchTotpFactorOtp,
                };
        }
    }
    /**
     *
     * @param jwt token to parse
     * @returns {string}- userId contained within the token message
     */
    static _parseJWT(jwt) {
        const parts = jwt.split('.');
        if (parts.length !== 3) {
            throw new constants_1.WrongParamFormat({
                info: {
                    jwt,
                },
            }, 'Invalid token length');
        }
        const body = Buffer.from(parts[1], 'base64');
        const parsedBody = JSON.parse(body.toString('ascii'));
        return parsedBody;
    }
}
StytchAuthFactorOtpProvider._provider = 'https://stytch.com/session';
exports.default = StytchAuthFactorOtpProvider;
//# sourceMappingURL=StytchAuthFactorOtp.js.map