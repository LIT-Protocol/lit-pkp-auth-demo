"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StytchOtpProvider = void 0;
const constants_1 = require("@lit-protocol/constants");
const BaseProvider_1 = require("./BaseProvider");
const ethers_1 = require("ethers");
class StytchOtpProvider extends BaseProvider_1.BaseProvider {
    constructor(params, config) {
        super(params);
        this._provider = 'https://stytch.com/session';
        this._params = config;
    }
    /**
     * Validates claims within a stytch authenticated JSON Web Token
     * @param options authentication option containing the authenticated token
     * @returns {AuthMethod} Authentication Method for auth method type OTP
     * */
    authenticate(options) {
        return new Promise((resolve, reject) => {
            if (!options) {
                reject(new Error('No Authentication options provided, please supply an authenticated JWT'));
            }
            const userId = this._params.userId ??
                options.userId;
            const accessToken = options?.accessToken;
            if (!accessToken) {
                reject(new Error('No access token provided, please provide a stych auth jwt'));
            }
            const parsedToken = StytchOtpProvider._parseJWT(accessToken);
            const audience = parsedToken['aud'][0];
            if (audience != this._params.appId) {
                reject(new Error('Parsed application id does not match parameters'));
            }
            if (!audience) {
                reject(new Error('could not find project id in token body, is this a stych token?'));
            }
            const session = parsedToken[this._provider];
            const authFactor = session['authentication_factors'][0];
            if (!authFactor) {
                reject(new Error('Could not find authentication info in session'));
            }
            if (userId && userId != parsedToken['sub']) {
                reject(new Error('UserId does not match token contents. is this the right token for your application?'));
            }
            resolve({
                authMethodType: constants_1.AUTH_METHOD_TYPE.StytchOtp,
                accessToken: accessToken,
            });
        });
    }
    /**
     * Get auth method id that can be used to look up and interact with
     * PKPs associated with the given auth method
     *
     * @param {AuthMethod} authMethod - Auth method object
     *
     * @returns {Promise<string>} - Auth method id
     */
    async getAuthMethodId(authMethod) {
        return StytchOtpProvider.authMethodId(authMethod);
    }
    static async authMethodId(authMethod) {
        const tokenBody = StytchOtpProvider._parseJWT(authMethod.accessToken);
        const userId = tokenBody['sub'];
        const orgId = tokenBody['aud'][0];
        const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${orgId.toLowerCase()}`));
        return authMethodId;
    }
    /**
     *
     * @param jwt token to parse
     * @returns {string}- userId contained within the token message
     */
    static _parseJWT(jwt) {
        const parts = jwt.split('.');
        if (parts.length !== 3) {
            throw new constants_1.WrongParamFormat({
                info: {
                    jwt,
                },
            }, 'Invalid token length');
        }
        const body = Buffer.from(parts[1], 'base64');
        const parsedBody = JSON.parse(body.toString('ascii'));
        console.log('JWT body: ', parsedBody);
        return parsedBody;
    }
}
exports.StytchOtpProvider = StytchOtpProvider;
//# sourceMappingURL=StytchOtpProvider.js.map