"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const constants_1 = require("@lit-protocol/constants");
const utils_1 = require("../utils");
const BaseProvider_1 = require("./BaseProvider");
const ethers_1 = require("ethers");
const jose = tslib_1.__importStar(require("jose"));
class GoogleProvider extends BaseProvider_1.BaseProvider {
    constructor(options) {
        super(options);
        this.redirectUri = options.redirectUri || window.location.origin;
    }
    /**
     * Redirect user to the Lit's Google login page
     *
     * @param {Function} [callback] - Optional callback to handle login URL
     * @returns {Promise<void>} - Redirects user to Lit login page
     */
    async signIn(callback) {
        // Get login url
        const loginUrl = await (0, utils_1.prepareLoginUrl)('google', this.redirectUri);
        // If callback is provided, use it. Otherwise, redirect to login url
        if (callback) {
            callback(loginUrl);
        }
        else {
            window.location.assign(loginUrl);
        }
    }
    /**
     * Validate the URL parameters returned from Lit's login server and return the authentication data
     *
     * @returns {Promise<AuthMethod>} - Auth method object that contains OAuth token
     */
    async authenticate(_, urlCheckCallback) {
        // Check if current url matches redirect uri using the callback if provided
        const isUrlValid = urlCheckCallback
            ? urlCheckCallback(window.location.href, this.redirectUri)
            : window.location.href.startsWith(this.redirectUri);
        if (!isUrlValid) {
            throw new constants_1.UnauthorizedException({
                info: {
                    url: window.location.href,
                    redirectUri: this.redirectUri,
                },
            }, `Current url does not match provided redirect uri`);
        }
        // Check url for params
        const { provider, idToken, state, error } = (0, utils_1.parseLoginParams)(window.location.search);
        // Check if there's an error
        if (error) {
            throw new constants_1.UnknownError({
                info: {
                    error,
                },
                cause: new Error(error),
            }, error ?? 'Received error from discord authentication');
        }
        // Check if provider is Google
        if (!provider || provider !== 'google') {
            throw new constants_1.UnauthorizedException({
                info: {
                    provider,
                    redirectUri: this.redirectUri,
                },
            }, 'OAuth provider does not match "google"');
        }
        // Check if state param matches
        if (!state || (0, utils_1.decode)(decodeURIComponent(state)) !== (0, utils_1.getStateParam)()) {
            throw new constants_1.UnauthorizedException({
                info: {
                    state,
                    redirectUri: this.redirectUri,
                },
            }, 'Invalid state parameter in callback URL');
        }
        // Clear params from url
        window.history.replaceState(null, window.document.title, window.location.pathname);
        // Check if id token is present in url
        if (!idToken) {
            throw new constants_1.UnauthorizedException({
                info: {
                    idToken,
                    redirectUri: this.redirectUri,
                },
            }, 'Missing ID token in callback URL');
        }
        const authMethod = {
            authMethodType: constants_1.AUTH_METHOD_TYPE.GoogleJwt,
            accessToken: idToken,
        };
        return authMethod;
    }
    /**
     * Sign in using popup window
     *
     * @param baseURL
     */
    async signInUsingPopup(baseURL) {
        const width = 500;
        const height = 600;
        const left = window.screen.width / 2 - width / 2;
        const top = window.screen.height / 2 - height / 2;
        const url = await (0, utils_1.prepareLoginUrl)('google', this.redirectUri, baseURL);
        const popup = window.open(`${url}&caller=${window.location.origin}`, 'popup', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, copyhistory=no, width=${width}, height=${height}, top=${top}, left=${left}`);
        if (!popup) {
            throw new constants_1.UnknownError({}, 'Failed to open popup window');
        }
        return new Promise((resolve, reject) => {
            // window does not have a closed event, so we need to poll using a timer
            const interval = setInterval(() => {
                if (popup.closed) {
                    clearInterval(interval);
                    reject(new Error('User closed popup window'));
                }
            }, 1000);
            window.addEventListener('message', (event) => {
                if (event.origin !== (baseURL || utils_1.LIT_LOGIN_GATEWAY)) {
                    return;
                }
                const { provider, token, error } = event.data;
                if (error) {
                    clearInterval(interval);
                    reject(new Error(error));
                }
                if (provider === 'google' && token) {
                    clearInterval(interval);
                    popup.close();
                    resolve({
                        authMethodType: constants_1.AUTH_METHOD_TYPE.GoogleJwt,
                        accessToken: token,
                    });
                }
            });
        });
    }
    /**
     * Get auth method id that can be used to look up and interact with
     * PKPs associated with the given auth method
     *
     * @param {AuthMethod} authMethod - Auth method object
     *
     * @returns {Promise<string>} - Auth method id
     */
    async getAuthMethodId(authMethod) {
        return GoogleProvider.authMethodId(authMethod);
    }
    static async authMethodId(authMethod) {
        const tokenPayload = jose.decodeJwt(authMethod.accessToken);
        const userId = tokenPayload['sub'];
        const audience = tokenPayload['aud'];
        const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${audience}`));
        return authMethodId;
    }
}
exports.default = GoogleProvider;
//# sourceMappingURL=GoogleProvider.js.map