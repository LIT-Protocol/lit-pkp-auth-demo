"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.totpAuthFactorParser = exports.whatsAppOtpAuthFactorParser = exports.smsOtpAuthFactorParser = exports.emailOtpAuthFactorParser = void 0;
const constants_1 = require("@lit-protocol/constants");
const ethers_1 = require("ethers");
const emailOtpAuthFactorParser = (parsedToken, provider) => {
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj) => {
        if (value.email_factor)
            return value;
    });
    if (!authFactor) {
        throw new constants_1.WrongParamFormat({
            info: {
                parsedToken,
                provider,
            },
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.WrongParamFormat({
            info: {
                parsedToken,
                provider,
            },
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.email_factor.email_address;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.emailOtpAuthFactorParser = emailOtpAuthFactorParser;
const smsOtpAuthFactorParser = (parsedToken, provider) => {
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj) => {
        if (value.phone_number_factor)
            return value;
    });
    if (!authFactor) {
        throw new constants_1.WrongParamFormat({
            info: {
                parsedToken,
                provider,
            },
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.WrongParamFormat({
            info: {
                parsedToken,
                provider,
            },
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.phone_number_factor.phone_number;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.smsOtpAuthFactorParser = smsOtpAuthFactorParser;
const whatsAppOtpAuthFactorParser = (parsedToken, provider) => {
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj) => {
        if (value.phone_number_factor)
            return value;
    });
    if (!authFactor) {
        throw new constants_1.WrongParamFormat({
            info: {
                parsedToken,
                provider,
            },
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.WrongParamFormat({
            info: {
                parsedToken,
                provider,
            },
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.phone_number_factor.phone_number;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.whatsAppOtpAuthFactorParser = whatsAppOtpAuthFactorParser;
const totpAuthFactorParser = (parsedToken, provider) => {
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj) => {
        if (value.phone_number_factor)
            return value;
    });
    if (!authFactor) {
        throw new constants_1.WrongParamFormat({
            info: {
                parsedToken,
                provider,
            },
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.WrongParamFormat({
            info: {
                parsedToken,
                provider,
            },
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.authenticator_app_factor.totp_id;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.totpAuthFactorParser = totpAuthFactorParser;
//# sourceMappingURL=StytchAuthFactors.js.map