import { LIT_NETWORK_VALUES } from '@lit-protocol/constants';
import { AuthMethod, IRelay, IRelayFetchResponse, IRelayMintResponse, IRelayPollStatusResponse, LitRelayConfig } from '@lit-protocol/types';
/**
 * Class that communicates with Lit relay server
 */
export declare class LitRelay implements IRelay {
    /** URL for Lit's relay server */
    static getRelayUrl(litNetwork: LIT_NETWORK_VALUES): string;
    /**
     * URL for Lit's relay server
     */
    private readonly relayUrl;
    /**
     * API key for Lit's relay server
     */
    private readonly relayApiKey;
    /**
     * Route for minting PKP
     */
    private readonly mintRoute;
    /**
     * Route for fetching PKPs
     */
    private readonly fetchRoute;
    /**
     * Create a Relay instance
     *
     * @param {LitRelayConfig} config
     * @param {string} [config.relayApiKey] - API key for Lit's relay server
     * @param {string} [config.relayUrl] - URL for Lit's relay server. If not provided, will default to the last dev relay server.
     */
    constructor(config: LitRelayConfig);
    /**
     * Mint a new PKP for the given auth method
     *
     * @param {string} body - Body of the request
     *
     * @returns {Promise<IRelayMintResponse>} Response from the relay server
     */
    mintPKP(body: string): Promise<IRelayMintResponse>;
    /**
     * Mints a new pkp with all AuthMethods provided. Allows for permissions and flags to be set separately.
     * If no permissions are provided then each auth method will be assigned `1` for sign anything
     * If no flags are provided then `sendPkpToitself` will be false, and `addPkpEthAddressAsPermittedAddress` will be true
     * It is then up to the implementor to transfer the pkp nft to the pkp address.
     * **note** When adding permissions, each permission should be added in the same order the auth methods are ordered
     *
     * @throws {Error} - Throws an error if no AuthMethods are given
     * @param {AuthMethod[]} authMethods - AuthMethods authentication methods to be added to the pkp
     * @param {{ pkpPermissionScopes?: number[][]; sendPkpToitself?: boolean; addPkpEthAddressAsPermittedAddress?: boolean;}} options
     *
     * @returns {Promise<{pkpTokenId?: string; pkpEthAddress?: string; pkpPublicKey?: string}>} pkp information
     */
    mintPKPWithAuthMethods(authMethods: AuthMethod[], options: {
        pkpPermissionScopes?: number[][];
        sendPkpToitself?: boolean;
        addPkpEthAddressAsPermittedAddress?: boolean;
    }): Promise<{
        pkpTokenId?: string;
        pkpEthAddress?: string;
        pkpPublicKey?: string;
    }>;
    /**
     * Poll the relay server for status of minting request
     *
     * @param {string} requestId - Request ID to poll, likely the minting transaction hash
     * @param {number} [pollInterval] - Polling interval in milliseconds
     * @param {number} [maxPollCount] - Maximum number of times to poll
     *
     * @returns {Promise<IRelayPollStatusResponse>} Response from the relay server
     */
    pollRequestUntilTerminalState(requestId: string, pollInterval?: number, maxPollCount?: number): Promise<IRelayPollStatusResponse>;
    /**
     * Fetch PKPs associated with the given auth method
     *
     * @param {string} body - Body of the request
     *
     * @returns {Promise<IRelayFetchResponse>} Response from the relay server
     */
    fetchPKPs(body: string): Promise<IRelayFetchResponse>;
    /**
     * Generate options for registering a new credential to pass to the authenticator
     *
     * @param {string} [username] - Optional username to associate with the credential
     *
     * @returns {Promise<any>} Registration options for the browser to pass to the authenticator
     */
    generateRegistrationOptions(username?: string): Promise<any>;
    /**
     * returns the relayUrl
     */
    getUrl(): string;
}
