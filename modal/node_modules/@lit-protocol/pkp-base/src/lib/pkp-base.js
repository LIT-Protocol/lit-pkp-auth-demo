"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PKPBase = void 0;
const tslib_1 = require("tslib");
/**
 * This module defines the PKPBase class, which provides a base implementation for wallet functionality
 * that can be shared between Ethers and Cosmos signers. The class is responsible for managing public key
 * compression, initializing and connecting to the LIT node, and running LIT actions based on provided properties.
 * The class also includes debug functions for logging and error handling.
 *
 * The module exports the PKPBase class, as well as the PKPBaseProp type definition used for
 * initializing the class instances.
 */
const depd_1 = tslib_1.__importDefault(require("depd"));
const constants_1 = require("@lit-protocol/constants");
const misc_1 = require("@lit-protocol/misc");
const deprecated = (0, depd_1.default)('lit-js-sdk:pkp-base:pkp-base');
/**
 * Compresses a given public key.
 * @param {string} pubKey - The public key to be compressed.
 * @returns {string} - The compressed public key.
 */
const compressPubKey = (pubKey) => {
    const testBuffer = Buffer.from(pubKey, 'hex');
    if (testBuffer.length === 64) {
        pubKey = '04' + pubKey;
    }
    // const hex = Buffer.from(pubKey, 'hex');
    const uint8array = Buffer.from(pubKey, 'hex');
    const compressedKey = (0, misc_1.publicKeyConvert)(uint8array, true);
    const hex = Buffer.from(compressedKey).toString('hex');
    return hex;
};
/**
 * A base class that can be shared between Ethers and Cosmos signers.
 */
class PKPBase {
    get litNodeClientReady() {
        return this.litNodeClient.ready;
    }
    /**
     * @deprecated - Use a different authentication method instead.
     */
    get controllerAuthSig() {
        deprecated('controllerAuthSig is deprecated.');
        return this._controllerAuthSig;
    }
    /**
     * @deprecated - Use a different authentication method instead.
     */
    set controllerAuthSig(value) {
        deprecated('controllerAuthSig is deprecated.');
        this._controllerAuthSig = value;
    }
    // Rest of the PKPBase class...
    constructor(pkpBaseProp) {
        // -- debug things
        this.PREFIX = '[PKPBase]';
        this.orange = '\x1b[33m';
        this.reset = '\x1b[0m';
        const prop = { ...pkpBaseProp }; // Avoid modifications to the received object
        this.debug = prop.debug || false;
        if (prop.pkpPubKey.startsWith('0x')) {
            prop.pkpPubKey = prop.pkpPubKey.slice(2);
        }
        this.setUncompressedPubKeyAndBuffer(prop);
        this.setCompressedPubKeyAndBuffer(prop);
        this.rpcs = prop.rpcs;
        this.controllerAuthSig = prop.controllerAuthSig;
        this.controllerAuthMethods = prop.controllerAuthMethods;
        this.controllerSessionSigs = prop.controllerSessionSigs;
        this.authContext = prop.authContext;
        this.validateAuthContext();
        this.setLitAction(prop);
        this.setLitActionJsParams(prop.litActionJsParams || {});
        this.litNodeClient = prop.litNodeClient;
    }
    /**
     * Creates a new instance of the PKPBase class with the provided properties.
     *
     * @param { PKPBaseProp } pkpBaseProp - The properties for the PKPBase instance.
     *
     * @returns { PKPBase } - A new instance of the PKPBase class.
     * */
    static createInstance(pkpBaseProp) {
        return new PKPBase(pkpBaseProp);
    }
    /**
     * Sets the uncompressed public key and its buffer representation.
     *
     * @param { PKPBaseProp } prop - The properties for the PKPBase instance.
     */
    setUncompressedPubKeyAndBuffer(prop) {
        try {
            this.uncompressedPubKey = prop.pkpPubKey;
            this.uncompressedPubKeyBuffer = Buffer.from(prop.pkpPubKey, 'hex');
        }
        catch (e) {
            throw new constants_1.UnknownError({
                info: {
                    param: 'pkpPubKey',
                    value: prop.pkpPubKey,
                },
                cause: e,
            }, 'Failed to set uncompressed public key and buffer');
        }
    }
    /**
     * Sets the compressed public key and its buffer representation.
     *
     * @param {PKPBaseProp} prop - The properties for the PKPBase instance.
     */
    setCompressedPubKeyAndBuffer(prop) {
        try {
            this.compressedPubKey = compressPubKey(prop.pkpPubKey);
            this.compressedPubKeyBuffer = Buffer.from(this.compressedPubKey, 'hex');
        }
        catch (e) {
            throw new constants_1.UnknownError({
                info: {
                    param: 'pkpPubKey',
                    value: prop.pkpPubKey,
                },
                cause: e,
            }, 'Failed to set compressed public key and buffer');
        }
    }
    /**
     * Sets the Lit action to be executed by the LitNode client.
     *
     * @param {PKPBaseProp} pkpBaseProp - An object containing the parameters for the Lit action.
     *
     * @returns {void} - If both `litActionCode` and `litActionIPFS` are present, throws an Error. Otherwise, does not return a value.
     */
    setLitAction(pkpBaseProp) {
        this.litActionCode = pkpBaseProp.litActionCode;
        this.litActionIPFS = pkpBaseProp.litActionIPFS;
        if (pkpBaseProp.litActionCode && pkpBaseProp.litActionIPFS) {
            throw new constants_1.InitError({
                info: {
                    pkpBaseProp,
                },
            }, 'Both litActionCode and litActionIPFS cannot be present at the same time.');
        }
        if (!pkpBaseProp.litActionCode && !pkpBaseProp.litActionIPFS) {
            this.log('No lit action code or IPFS hash provided. Using default action.');
            this.useAction = false;
        }
    }
    /**
     * A function that sets the value of the litActionJsParams property to the given params object.
     * @template CustomType - A generic type that extends T, where T is the type of the litActionJsParams property.
     *
     * @param { CustomType } params - An object of type CustomType that contains the parameters to be set as litActionJsParams.
     *
     * @returns { void }
     */
    setLitActionJsParams(params) {
        this.litActionJsParams = params;
    }
    /**
     * Initializes the PKPBase instance by connecting to the LIT node.
     */
    async init() {
        try {
            await this.litNodeClient.connect();
            this.log('Connected to Lit Node');
        }
        catch (e) {
            throw new constants_1.LitNodeClientNotReadyError({
                info: {
                    litNodeConfig: this.litNodeClient.config,
                },
                cause: e,
            }, 'Failed to connect to Lit Node');
        }
    }
    validateAuthContext() {
        const providedAuthentications = [
            this.controllerAuthSig,
            this.controllerSessionSigs,
            this.authContext,
        ].filter(Boolean).length;
        if (providedAuthentications !== 1) {
            // log which authentications has the user provided
            if (this.controllerAuthSig) {
                (0, misc_1.logError)('controllerAuthSig is provided');
            }
            if (this.controllerSessionSigs) {
                (0, misc_1.logError)('controllerSessionSigs is provided');
            }
            if (this.authContext) {
                (0, misc_1.logError)('authContext is provided');
            }
            throw new constants_1.InitError({
                info: {
                    authContext: this.authContext,
                    controllerAuthSig: this.controllerAuthSig,
                    controllerSessionSigs: this.controllerSessionSigs,
                },
            }, 'Must specify one, and only one, authentication method ');
        }
        // Check if authContext is provided correctly
        if (this.authContext && !this.authContext.getSessionSigsProps) {
            throw new constants_1.InitError({
                info: {
                    authContext: this.authContext,
                },
            }, 'authContext must be an object with getSessionSigsProps');
        }
    }
    async getSessionSigs() {
        const sessionSigs = this.authContext
            ? await this.litNodeClient.getSessionSigs(this.authContext.getSessionSigsProps)
            : this.controllerSessionSigs;
        if (!sessionSigs) {
            throw new constants_1.UnknownError({}, 'Could not get sessionSigs');
        }
        return sessionSigs;
    }
    /**
     * Runs the specified Lit action with the given parameters.
     *
     * @param {Uint8Array} toSign - The data to be signed by the Lit action.
     * @param {string} sigName - The name of the signature to be returned by the Lit action.
     *
     * @returns {Promise<any>} - A Promise that resolves with the signature returned by the Lit action.
     *
     * @throws {Error} - Throws an error if `pkpPubKey` is not provided, if `controllerAuthSig` or `controllerSessionSigs` is not provided, if `controllerSessionSigs` is not an object, if `executeJsArgs` does not have either `code` or `ipfsId`, or if an error occurs during the execution of the Lit action.
     */
    async runLitAction(toSign, sigName) {
        // -- validate executeJsArgs
        if (this.litActionCode && this.litActionIPFS) {
            throw new constants_1.InitError({
                info: {
                    litActionCode: this.litActionCode,
                    litActionIPFS: this.litActionIPFS,
                },
            }, 'litActionCode and litActionIPFS cannot exist at the same time');
        }
        await this.ensureLitNodeClientReady();
        // If no PKP public key is provided, throw error
        if (!this.uncompressedPubKey) {
            throw new constants_1.InitError({}, 'pkpPubKey (aka. uncompressedPubKey) is required');
        }
        this.validateAuthContext();
        const controllerSessionSigs = await this.getSessionSigs();
        const executeJsArgs = {
            ...(this.litActionCode && { code: this.litActionCode }),
            ...(this.litActionIPFS && { ipfsId: this.litActionIPFS }),
            sessionSigs: controllerSessionSigs,
            jsParams: {
                ...{
                    toSign,
                    publicKey: this.uncompressedPubKey,
                    sigName,
                },
                ...{
                    ...this.litActionJsParams,
                },
            },
        };
        // check if executeJsArgs has either code or ipfsId
        if (!executeJsArgs.code && !executeJsArgs.ipfsId) {
            throw new constants_1.InitError({
                info: {
                    litActionCode: this.litActionCode,
                    litActionIPFS: this.litActionIPFS,
                },
            }, 'executeJsArgs must have either code or ipfsId');
        }
        this.log('executeJsArgs:', executeJsArgs);
        const res = await this.litNodeClient.executeJs(executeJsArgs);
        const sig = res.signatures[sigName];
        this.log('res:', res);
        this.log('res.signatures[sigName]:', sig);
        if (sig.r && sig.s) {
            // pad sigs with 0 if length is odd
            sig.r = sig.r.length % 2 === 0 ? sig.r : '0' + sig.r;
            sig.s = sig.s.length % 2 === 0 ? sig.s : '0' + sig.s;
        }
        return sig;
    }
    /**
     * Sign the provided data with the PKP private key.
     *
     * @param {Uint8Array} toSign - The data to be signed.
     *
     * @returns {Promise<any>} - A Promise that resolves with the signature of the provided data.
     *
     * @throws {Error} - Throws an error if `pkpPubKey` is not provided, if `controllerAuthSig` or `controllerSessionSigs` is not provided, if `controllerSessionSigs` is not an object, or if an error occurs during the signing process.
     */
    async runSign(toSign) {
        await this.ensureLitNodeClientReady();
        // If no PKP public key is provided, throw error
        if (!this.uncompressedPubKey) {
            throw new constants_1.InitError({}, 'pkpPubKey (aka. uncompressedPubKey) is required');
        }
        this.validateAuthContext();
        const controllerSessionSigs = await this.getSessionSigs();
        try {
            const sig = await this.litNodeClient.pkpSign({
                toSign,
                pubKey: this.uncompressedPubKey,
                sessionSigs: controllerSessionSigs,
            });
            if (!sig) {
                throw new constants_1.UnknownError({}, 'No signature returned');
            }
            // pad sigs with 0 if length is odd
            sig.r = sig.r.length % 2 === 0 ? sig.r : '0' + sig.r;
            sig.s = sig.s.length % 2 === 0 ? sig.s : '0' + sig.s;
            return sig;
        }
        catch (e) {
            console.log('err: ', e);
            throw e;
        }
    }
    /**
     * Ensures that the LitNode client is ready for use by waiting for initialization if necessary.
     * If the client is already ready, this function does nothing.
     *
     * @returns {Promise<void>} - A Promise that resolves when the LitNode client is ready for use.
     */
    async ensureLitNodeClientReady() {
        if (!this.litNodeClientReady) {
            await this.init();
        }
    }
    /**
     * Logs the provided arguments to the console, but only if debugging is enabled.
     *
     * @param {...any[]} args - The values to be logged to the console.
     *
     * @returns {void} - This function does not return a value.
     */
    log(...args) {
        if (this.debug) {
            console.log(this.orange + this.PREFIX + this.reset, ...args);
        }
    }
}
exports.PKPBase = PKPBase;
//# sourceMappingURL=pkp-base.js.map