import Bt,{EventEmitter as N}from"events";import jt from"@walletconnect/keyvaluestorage";import{HEARTBEAT_EVENTS as j,HeartBeat as Vt}from"@walletconnect/heartbeat";import{generateChildLogger as E,getLoggerContext as f,pino as De,getDefaultLoggerOptions as ye}from"@walletconnect/logger";import{IMessageTracker as qt,IPublisher as Yt,ISubscriber as Gt,IRelayer as Jt,IStore as Ht,IJsonRpcHistory as Wt,IExpirer as Xt,IVerify as Zt,ICore as Qt}from"@walletconnect/types";import{safeJsonStringify as ei,safeJsonParse as ti}from"@walletconnect/safe-json";import*as V from"@walletconnect/relay-auth";import{getInternalError as c,mapToObj as be,objToMap as me,generateKeyPair as ii,generateRandomBytes32 as Q,deriveSymKey as si,hashKey as ri,validateEncoding as ni,isTypeOneEnvelope as Ee,encrypt as ai,validateDecoding as oi,decrypt as hi,deserialize as fe,decodeTypeByte as ci,BASE16 as ui,hashMessage as ee,getRelayProtocolName as te,createExpiringPromise as q,getRelayProtocolApi as Y,isUndefined as ie,getSdkError as F,isValidArray as li,formatRelayRpcUrl as di,isProposalStruct as gi,isSessionStruct as pi,TYPE_1 as Di,calcExpiry as G,formatUri as yi,parseUri as bi,createDelayedPromise as mi,engineEvent as se,isExpired as we,isValidParams as re,isValidUrl as Ei,isValidString as fi,parseExpirerTarget as wi,formatTopicTarget as vi,formatIdTarget as Ii,isReactNative as Ci,isBrowser as _i,isNode as Ri}from"@walletconnect/utils";import{toString as Ti}from"uint8arrays";import{ONE_DAY as U,SIX_HOURS as Si,ONE_SECOND as ve,THIRTY_DAYS as J,FIVE_SECONDS as ne,THIRTY_SECONDS as Ie,toMiliseconds as z,TEN_SECONDS as Pi,Watch as Oi,FIVE_MINUTES as Ce}from"@walletconnect/time";import{JsonRpcProvider as xi}from"@walletconnect/jsonrpc-provider";import{getBigIntRpcId as Ai,isJsonRpcRequest as _e,isJsonRpcResponse as Re,formatJsonRpcResult as Te,formatJsonRpcRequest as Se,formatJsonRpcError as zi,isJsonRpcResult as Ni,isJsonRpcError as Pe}from"@walletconnect/jsonrpc-utils";import Ui from"@walletconnect/jsonrpc-ws-connection";import Li from"lodash.isequal";function $i(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),i=0;i<t.length;i++)t[i]=255;for(var s=0;s<r.length;s++){var n=r.charAt(s),a=n.charCodeAt(0);if(t[a]!==255)throw new TypeError(n+" is ambiguous");t[a]=s}var o=r.length,h=r.charAt(0),l=Math.log(o)/Math.log(256),d=Math.log(256)/Math.log(o);function b(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var D=0,A=0,v=0,R=u.length;v!==R&&u[v]===0;)v++,D++;for(var T=(R-v)*d+1>>>0,m=new Uint8Array(T);v!==R;){for(var S=u[v],x=0,I=T-1;(S!==0||x<A)&&I!==-1;I--,x++)S+=256*m[I]>>>0,m[I]=S%o>>>0,S=S/o>>>0;if(S!==0)throw new Error("Non-zero carry");A=x,v++}for(var P=T-A;P!==T&&m[P]===0;)P++;for(var B=h.repeat(D);P<T;++P)B+=r.charAt(m[P]);return B}function y(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var D=0;if(u[D]!==" "){for(var A=0,v=0;u[D]===h;)A++,D++;for(var R=(u.length-D)*l+1>>>0,T=new Uint8Array(R);u[D];){var m=t[u.charCodeAt(D)];if(m===255)return;for(var S=0,x=R-1;(m!==0||S<v)&&x!==-1;x--,S++)m+=o*T[x]>>>0,T[x]=m%256>>>0,m=m/256>>>0;if(m!==0)throw new Error("Non-zero carry");v=S,D++}if(u[D]!==" "){for(var I=R-v;I!==R&&T[I]===0;)I++;for(var P=new Uint8Array(A+(R-I)),B=A;I!==R;)P[B++]=T[I++];return P}}}function k(u){var D=y(u);if(D)return D;throw new Error(`Non-${e} character`)}return{encode:b,decodeUnsafe:y,decode:k}}var Fi=$i,Mi=Fi;const Oe=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},Ki=r=>new TextEncoder().encode(r),ki=r=>new TextDecoder().decode(r);class Bi{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class ji{constructor(e,t,i){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return xe(this,e)}}class Vi{constructor(e){this.decoders=e}or(e){return xe(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const xe=(r,e)=>new Vi({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class qi{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new Bi(e,t,i),this.decoder=new ji(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const H=({name:r,prefix:e,encode:t,decode:i})=>new qi(r,e,t,i),M=({prefix:r,name:e,alphabet:t})=>{const{encode:i,decode:s}=Mi(t,e);return H({prefix:r,name:e,encode:i,decode:n=>Oe(s(n))})},Yi=(r,e,t,i)=>{const s={};for(let d=0;d<e.length;++d)s[e[d]]=d;let n=r.length;for(;r[n-1]==="=";)--n;const a=new Uint8Array(n*t/8|0);let o=0,h=0,l=0;for(let d=0;d<n;++d){const b=s[r[d]];if(b===void 0)throw new SyntaxError(`Non-${i} character`);h=h<<t|b,o+=t,o>=8&&(o-=8,a[l++]=255&h>>o)}if(o>=t||255&h<<8-o)throw new SyntaxError("Unexpected end of data");return a},Gi=(r,e,t)=>{const i=e[e.length-1]==="=",s=(1<<t)-1;let n="",a=0,o=0;for(let h=0;h<r.length;++h)for(o=o<<8|r[h],a+=8;a>t;)a-=t,n+=e[s&o>>a];if(a&&(n+=e[s&o<<t-a]),i)for(;n.length*t&7;)n+="=";return n},p=({name:r,prefix:e,bitsPerChar:t,alphabet:i})=>H({prefix:e,name:r,encode(s){return Gi(s,i,t)},decode(s){return Yi(s,i,t,r)}}),Ji=H({prefix:"\0",name:"identity",encode:r=>ki(r),decode:r=>Ki(r)});var Hi=Object.freeze({__proto__:null,identity:Ji});const Wi=p({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Xi=Object.freeze({__proto__:null,base2:Wi});const Zi=p({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Qi=Object.freeze({__proto__:null,base8:Zi});const es=M({prefix:"9",name:"base10",alphabet:"0123456789"});var ts=Object.freeze({__proto__:null,base10:es});const is=p({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),ss=p({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var rs=Object.freeze({__proto__:null,base16:is,base16upper:ss});const ns=p({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),as=p({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),os=p({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),hs=p({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),cs=p({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),us=p({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ls=p({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ds=p({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),gs=p({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var ps=Object.freeze({__proto__:null,base32:ns,base32upper:as,base32pad:os,base32padupper:hs,base32hex:cs,base32hexupper:us,base32hexpad:ls,base32hexpadupper:ds,base32z:gs});const Ds=M({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),ys=M({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var bs=Object.freeze({__proto__:null,base36:Ds,base36upper:ys});const ms=M({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Es=M({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var fs=Object.freeze({__proto__:null,base58btc:ms,base58flickr:Es});const ws=p({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),vs=p({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Is=p({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Cs=p({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var _s=Object.freeze({__proto__:null,base64:ws,base64pad:vs,base64url:Is,base64urlpad:Cs});const Ae=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Rs=Ae.reduce((r,e,t)=>(r[t]=e,r),[]),Ts=Ae.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function Ss(r){return r.reduce((e,t)=>(e+=Rs[t],e),"")}function Ps(r){const e=[];for(const t of r){const i=Ts[t.codePointAt(0)];if(i===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const Os=H({prefix:"\u{1F680}",name:"base256emoji",encode:Ss,decode:Ps});var xs=Object.freeze({__proto__:null,base256emoji:Os}),As=Ne,ze=128,zs=127,Ns=~zs,Us=Math.pow(2,31);function Ne(r,e,t){e=e||[],t=t||0;for(var i=t;r>=Us;)e[t++]=r&255|ze,r/=128;for(;r&Ns;)e[t++]=r&255|ze,r>>>=7;return e[t]=r|0,Ne.bytes=t-i+1,e}var Ls=ae,$s=128,Ue=127;function ae(r,i){var t=0,i=i||0,s=0,n=i,a,o=r.length;do{if(n>=o)throw ae.bytes=0,new RangeError("Could not decode varint");a=r[n++],t+=s<28?(a&Ue)<<s:(a&Ue)*Math.pow(2,s),s+=7}while(a>=$s);return ae.bytes=n-i,t}var Fs=Math.pow(2,7),Ms=Math.pow(2,14),Ks=Math.pow(2,21),ks=Math.pow(2,28),Bs=Math.pow(2,35),js=Math.pow(2,42),Vs=Math.pow(2,49),qs=Math.pow(2,56),Ys=Math.pow(2,63),Gs=function(r){return r<Fs?1:r<Ms?2:r<Ks?3:r<ks?4:r<Bs?5:r<js?6:r<Vs?7:r<qs?8:r<Ys?9:10},Js={encode:As,decode:Ls,encodingLength:Gs},Le=Js;const $e=(r,e,t=0)=>(Le.encode(r,e,t),e),Fe=r=>Le.encodingLength(r),oe=(r,e)=>{const t=e.byteLength,i=Fe(r),s=i+Fe(t),n=new Uint8Array(s+t);return $e(r,n,0),$e(t,n,i),n.set(e,s),new Hs(r,t,e,n)};class Hs{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}}const Me=({name:r,code:e,encode:t})=>new Ws(r,e,t);class Ws{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?oe(this.code,t):t.then(i=>oe(this.code,i))}else throw Error("Unknown type, must be binary type")}}const Ke=r=>async e=>new Uint8Array(await crypto.subtle.digest(r,e)),Xs=Me({name:"sha2-256",code:18,encode:Ke("SHA-256")}),Zs=Me({name:"sha2-512",code:19,encode:Ke("SHA-512")});var Qs=Object.freeze({__proto__:null,sha256:Xs,sha512:Zs});const ke=0,er="identity",Be=Oe,tr=r=>oe(ke,Be(r)),ir={code:ke,name:er,encode:Be,digest:tr};var sr=Object.freeze({__proto__:null,identity:ir});new TextEncoder,new TextDecoder;const je={...Hi,...Xi,...Qi,...ts,...rs,...ps,...bs,...fs,..._s,...xs};({...Qs,...sr});function Ve(r){return globalThis.Buffer!=null?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r}function rr(r=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?Ve(globalThis.Buffer.allocUnsafe(r)):new Uint8Array(r)}function qe(r,e,t,i){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:i}}}const Ye=qe("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),he=qe("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=rr(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),nr={utf8:Ye,"utf-8":Ye,hex:je.base16,latin1:he,ascii:he,binary:he,...je};function ar(r,e="utf8"){const t=nr[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?Ve(globalThis.Buffer.from(r,"utf-8")):t.decoder.decode(`${t.prefix}${r}`)}const ce="wc",Ge=2,W="core",O=`${ce}@2:${W}:`,Je={name:W,logger:"error"},He={database:":memory:"},We="crypto",ue="client_ed25519_seed",Xe=U,Ze="keychain",Qe="0.3",et="messages",tt="0.3",it=Si,st="publisher",rt="irn",nt="error",le="wss://relay.walletconnect.com",de="wss://relay.walletconnect.org",at="relayer",g={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},ot="_subscription",L={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},ht=ve/2,or={database:":memory:"},ct="2.9.2",ut=1e4,lt="0.3",dt="WALLETCONNECT_CLIENT_ID",C={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},hr=J,gt="subscription",pt="0.3",Dt=ne*1e3,yt="pairing",bt="0.3",cr=J,$={wc_pairingDelete:{req:{ttl:U,prompt:!1,tag:1e3},res:{ttl:U,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:Ie,prompt:!1,tag:1002},res:{ttl:Ie,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:U,prompt:!1,tag:0},res:{ttl:U,prompt:!1,tag:0}}},_={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},mt="history",Et="0.3",ft="expirer",w={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},wt="0.3",ur=U,X="verify-api",ge="https://verify.walletconnect.com";class vt{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name=Ze,this.version=Qe,this.initialized=!1,this.storagePrefix=O,this.init=async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<"u"&&(this.keychain=i),this.initialized=!0}},this.has=i=>(this.isInitialized(),this.keychain.has(i)),this.set=async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist()},this.get=i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>"u"){const{message:n}=c("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(n)}return s},this.del=async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist()},this.core=e,this.logger=E(t,this.name)}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,be(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?me(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class It{constructor(e,t,i){this.core=e,this.logger=t,this.name=We,this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)},this.hasKeys=s=>(this.isInitialized(),this.keychain.has(s)),this.getClientId=async()=>{this.isInitialized();const s=await this.getClientSeed(),n=V.generateKeyPair(s);return V.encodeIss(n.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const s=ii();return this.setPrivateKey(s.publicKey,s.privateKey)},this.signJWT=async s=>{this.isInitialized();const n=await this.getClientSeed(),a=V.generateKeyPair(n),o=Q(),h=Xe;return await V.signJWT(o,s,h,a)},this.generateSharedKey=(s,n,a)=>{this.isInitialized();const o=this.getPrivateKey(s),h=si(o,n);return this.setSymKey(h,a)},this.setSymKey=async(s,n)=>{this.isInitialized();const a=n||ri(s);return await this.keychain.set(a,s),a},this.deleteKeyPair=async s=>{this.isInitialized(),await this.keychain.del(s)},this.deleteSymKey=async s=>{this.isInitialized(),await this.keychain.del(s)},this.encode=async(s,n,a)=>{this.isInitialized();const o=ni(a),h=ei(n);if(Ee(o)){const y=o.senderPublicKey,k=o.receiverPublicKey;s=await this.generateSharedKey(y,k)}const l=this.getSymKey(s),{type:d,senderPublicKey:b}=o;return ai({type:d,symKey:l,message:h,senderPublicKey:b})},this.decode=async(s,n,a)=>{this.isInitialized();const o=oi(n,a);if(Ee(o)){const h=o.receiverPublicKey,l=o.senderPublicKey;s=await this.generateSharedKey(h,l)}try{const h=this.getSymKey(s),l=hi({symKey:h,encoded:n});return ti(l)}catch(h){this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`),this.logger.error(h)}},this.getPayloadType=s=>{const n=fe(s);return ci(n.type)},this.getPayloadSenderPublicKey=s=>{const n=fe(s);return n.senderPublicKey?Ti(n.senderPublicKey,ui):void 0},this.core=e,this.logger=E(t,this.name),this.keychain=i||new vt(this.core,this.logger)}get context(){return f(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(ue)}catch{e=Q(),await this.keychain.set(ue,e)}return ar(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Ct extends qt{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name=et,this.version=tt,this.initialized=!1,this.storagePrefix=O,this.init=async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const i=await this.getRelayerMessages();typeof i<"u"&&(this.messages=i),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}finally{this.initialized=!0}}},this.set=async(i,s)=>{this.isInitialized();const n=ee(s);let a=this.messages.get(i);return typeof a>"u"&&(a={}),typeof a[n]<"u"||(a[n]=s,this.messages.set(i,a),await this.persist()),n},this.get=i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>"u"&&(s={}),s},this.has=(i,s)=>{this.isInitialized();const n=this.get(i),a=ee(s);return typeof n[a]<"u"},this.del=async i=>{this.isInitialized(),this.messages.delete(i),await this.persist()},this.logger=E(e,this.name),this.core=t}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,be(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?me(e):void 0}async persist(){await this.setRelayerMessages(this.messages)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class lr extends Yt{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new N,this.name=st,this.queue=new Map,this.publishTimeout=z(Pi),this.queueTimeout=z(ne),this.needsTransportRestart=!1,this.publish=async(i,s,n)=>{this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:n}});try{const a=n?.ttl||it,o=te(n),h=n?.prompt||!1,l=n?.tag||0,d=n?.id||Ai().toString(),b={topic:i,message:s,opts:{ttl:a,relay:o,prompt:h,tag:l,id:d}},y=setTimeout(()=>this.queue.set(d,b),this.queueTimeout);try{await await q(this.rpcPublish(i,s,a,o,h,l,d),this.publishTimeout),clearTimeout(y),this.relayer.events.emit(g.publish,b)}catch{this.logger.debug("Publishing Payload stalled"),this.needsTransportRestart=!0;return}this.logger.debug("Successfully Published Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:n}})}catch(a){throw this.logger.debug("Failed to Publish Payload"),this.logger.error(a),a}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.relayer=e,this.logger=E(t,this.name),this.registerEventListeners()}get context(){return f(this.logger)}rpcPublish(e,t,i,s,n,a,o){var h,l,d,b;const y={method:Y(s.protocol).publish,params:{topic:e,message:t,ttl:i,prompt:n,tag:a},id:o};return ie((h=y.params)==null?void 0:h.prompt)&&((l=y.params)==null||delete l.prompt),ie((d=y.params)==null?void 0:d.tag)&&((b=y.params)==null||delete b.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:y}),this.relayer.request(y)}onPublish(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async e=>{const{topic:t,message:i,opts:s}=e;await this.publish(t,i,s)})}registerEventListeners(){this.relayer.core.heartbeat.on(j.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(g.connection_stalled);return}this.checkQueue()}),this.relayer.on(g.message_ack,e=>{this.onPublish(e.id.toString())})}}class dr{constructor(){this.map=new Map,this.set=(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter(n=>n!==t);if(!s.length){this.map.delete(e);return}this.map.set(e,s)},this.clear=()=>{this.map.clear()}}get topics(){return Array.from(this.map.keys())}}var gr=Object.defineProperty,pr=Object.defineProperties,Dr=Object.getOwnPropertyDescriptors,_t=Object.getOwnPropertySymbols,yr=Object.prototype.hasOwnProperty,br=Object.prototype.propertyIsEnumerable,Rt=(r,e,t)=>e in r?gr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,K=(r,e)=>{for(var t in e||(e={}))yr.call(e,t)&&Rt(r,t,e[t]);if(_t)for(var t of _t(e))br.call(e,t)&&Rt(r,t,e[t]);return r},pe=(r,e)=>pr(r,Dr(e));class Tt extends Gt{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new dr,this.events=new N,this.name=gt,this.version=pt,this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel="pending_sub_watch_label",this.pollingInterval=20,this.storagePrefix=O,this.subscribeTimeout=1e4,this.restartInProgress=!1,this.batchSubscribeTopicsLimit=500,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restart(),this.registerEventListeners(),this.onEnable(),this.clientId=await this.relayer.core.crypto.getClientId())},this.subscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}});try{const n=te(s),a={topic:i,relay:n};this.pending.set(i,a);const o=await this.rpcSubscribe(i,n);return this.onSubscribe(o,a),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}}),o}catch(n){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(n),n}},this.unsubscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),typeof s?.id<"u"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s)},this.isSubscribed=async i=>this.topics.includes(i)?!0:await new Promise((s,n)=>{const a=new Oi;a.start(this.pendingSubscriptionWatchLabel);const o=setInterval(()=>{!this.pending.has(i)&&this.topics.includes(i)&&(clearInterval(o),a.stop(this.pendingSubscriptionWatchLabel),s(!0)),a.elapsed(this.pendingSubscriptionWatchLabel)>=Dt&&(clearInterval(o),a.stop(this.pendingSubscriptionWatchLabel),n(new Error("Subscription resolution timeout")))},this.pollingInterval)}).catch(()=>!1),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.restart=async()=>{this.restartInProgress=!0,await this.restore(),await this.reset(),this.restartInProgress=!1},this.relayer=e,this.logger=E(t,this.name),this.clientId=""}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}onEnable(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map(async s=>await this.unsubscribeById(e,s,t)))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=te(i);await this.rpcUnsubscribe(e,t,s);const n=F("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,n),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(s){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(s),s}}async rpcSubscribe(e,t){const i={method:Y(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{await await q(this.relayer.request(i),this.subscribeTimeout)}catch{this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(g.connection_stalled)}return ee(e+this.clientId)}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:Y(t.protocol).batchSubscribe,params:{topics:e.map(s=>s.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{return await await q(this.relayer.request(i),this.subscribeTimeout)}catch{this.logger.debug("Outgoing Relay Payload stalled"),this.relayer.events.emit(g.connection_stalled)}}rpcUnsubscribe(e,t,i){const s={method:Y(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,pe(K({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,K({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.subscriptions.has(e)||(this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t))}addSubscription(e,t){this.subscriptions.set(e,K({},t)),this.topicMap.set(t.topic,e),this.events.emit(C.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(C.deleted,pe(K({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(C.sync)}async reset(){if(this.cached.length){const e=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let t=0;t<e;t++){const i=this.cached.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(i)}}this.events.emit(C.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){if(!e.length)return;const t=await this.rpcBatchSubscribe(e);li(t)&&this.onBatchSubscribe(t.map((i,s)=>pe(K({},e[s]),{id:i})))}async onConnect(){this.restartInProgress||(await this.restart(),this.onEnable())}onDisconnect(){this.onDisable()}async checkPending(){if(this.relayer.transportExplicitlyClosed)return;const e=[];this.pending.forEach(t=>{e.push(t)}),await this.batchSubscribe(e)}registerEventListeners(){this.relayer.core.heartbeat.on(j.pulse,async()=>{await this.checkPending()}),this.relayer.on(g.connect,async()=>{await this.onConnect()}),this.relayer.on(g.disconnect,()=>{this.onDisconnect()}),this.events.on(C.created,async e=>{const t=C.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()}),this.events.on(C.deleted,async e=>{const t=C.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(){this.restartInProgress&&await new Promise(e=>{const t=setInterval(()=>{this.restartInProgress||(clearInterval(t),e())},this.pollingInterval)})}}var mr=Object.defineProperty,St=Object.getOwnPropertySymbols,Er=Object.prototype.hasOwnProperty,fr=Object.prototype.propertyIsEnumerable,Pt=(r,e,t)=>e in r?mr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,wr=(r,e)=>{for(var t in e||(e={}))Er.call(e,t)&&Pt(r,t,e[t]);if(St)for(var t of St(e))fr.call(e,t)&&Pt(r,t,e[t]);return r};class Ot extends Jt{constructor(e){super(e),this.protocol="wc",this.version=2,this.events=new N,this.name=at,this.transportExplicitlyClosed=!1,this.initialized=!1,this.reconnecting=!1,this.connectionStatusPollingInterval=20,this.staleConnectionErrors=["socket hang up","socket stalled"],this.request=async t=>{this.logger.debug("Publishing Request Payload");try{return await this.toEstablishConnection(),await this.provider.request(t)}catch(i){throw this.logger.debug("Failed to Publish Request"),this.logger.error(i),i}},this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?E(e.logger,this.name):De(ye({level:e.logger||nt})),this.messages=new Ct(this.logger,e.core),this.subscriber=new Tt(this,this.logger),this.publisher=new lr(this,this.logger),this.relayUrl=e?.relayUrl||le,this.projectId=e.projectId,this.provider={}}async init(){this.logger.trace("Initialized"),await this.createProvider(),await Promise.all([this.messages.init(),this.subscriber.init()]);try{await this.transportOpen()}catch{this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${de}...`),await this.restartTransport(de)}this.registerEventListeners(),this.initialized=!0,setTimeout(async()=>{this.subscriber.topics.length===0&&(this.logger.info("No topics subscribed to after init, closing transport"),await this.transportClose(),this.transportExplicitlyClosed=!1)},ut)}get context(){return f(this.logger)}get connected(){return this.provider.connection.connected}get connecting(){return this.provider.connection.connecting}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now()})}async subscribe(e,t){var i;this.isInitialized();let s=((i=this.subscriber.topicMap.get(e))==null?void 0:i[0])||"";return s||(await Promise.all([new Promise(n=>{this.subscriber.once(C.created,a=>{a.topic===e&&n()})}),new Promise(async n=>{s=await this.subscriber.subscribe(e,t),n()})]),s)}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportClose(){this.transportExplicitlyClosed=!0,this.connected&&(await this.provider.disconnect(),this.events.emit(g.transport_closed))}async transportOpen(e){if(this.transportExplicitlyClosed=!1,!this.reconnecting){this.relayUrl=e||this.relayUrl,this.reconnecting=!0;try{await Promise.all([new Promise(t=>{this.initialized||t(),this.subscriber.once(C.resubscribed,()=>{t()})}),await Promise.race([new Promise(async(t,i)=>{await q(this.provider.connect(),1e4,`Socket stalled when trying to connect to ${this.relayUrl}`).catch(s=>i(s)).then(()=>t()).finally(()=>this.removeListener(g.transport_closed,this.rejectTransportOpen))}),new Promise(t=>this.once(g.transport_closed,this.rejectTransportOpen))])])}catch(t){this.logger.error(t);const i=t;if(!this.isConnectionStalled(i.message))throw t;this.events.emit(g.transport_closed)}finally{this.reconnecting=!1}}}async restartTransport(e){this.transportExplicitlyClosed||this.reconnecting||(this.relayUrl=e||this.relayUrl,this.connected&&await Promise.all([new Promise(t=>{this.provider.once(L.disconnect,()=>{t()})}),this.transportClose()]),await this.createProvider(),await this.transportOpen())}isConnectionStalled(e){return this.staleConnectionErrors.some(t=>e.includes(t))}rejectTransportOpen(){throw new Error("Attempt to connect to relay via `transportOpen` has stalled. Retrying...")}async createProvider(){const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new xi(new Ui(di({sdkVersion:ct,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0}))),this.registerProviderListeners()}async recordMessageEvent(e){const{topic:t,message:i}=e;await this.messages.set(t,i)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;if(!i||i.length===0)return this.logger.debug(`Ignoring invalid/empty message: ${i}`),!0;if(!await this.subscriber.isSubscribed(t))return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`),!0;const s=this.messages.has(t,i);return s&&this.logger.debug(`Ignoring duplicate message: ${i}`),s}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),_e(e)){if(!e.method.endsWith(ot))return;const t=e.params,{topic:i,message:s,publishedAt:n}=t.data,a={topic:i,message:s,publishedAt:n};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(wr({type:"event",event:t.id},a)),this.events.emit(t.id,a),await this.acknowledgePayload(e),await this.onMessageEvent(a)}else Re(e)&&this.events.emit(g.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(g.message,e),await this.recordMessageEvent(e))}async acknowledgePayload(e){const t=Te(e.id,!0);await this.provider.connection.send(t)}registerProviderListeners(){this.provider.on(L.payload,e=>this.onProviderPayload(e)),this.provider.on(L.connect,()=>{this.events.emit(g.connect)}),this.provider.on(L.disconnect,()=>{this.onProviderDisconnect()}),this.provider.on(L.error,e=>{this.logger.error(e),this.events.emit(g.error,e)})}registerEventListeners(){this.events.on(g.connection_stalled,async()=>{await this.restartTransport()})}onProviderDisconnect(){this.events.emit(g.disconnect),this.attemptToReconnect()}attemptToReconnect(){this.transportExplicitlyClosed||setTimeout(async()=>{await this.restartTransport()},z(ht))}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(!this.connected){if(this.connecting)return await new Promise(e=>{const t=setInterval(()=>{this.connected&&(clearInterval(t),e())},this.connectionStatusPollingInterval)});await this.restartTransport()}}}var vr=Object.defineProperty,xt=Object.getOwnPropertySymbols,Ir=Object.prototype.hasOwnProperty,Cr=Object.prototype.propertyIsEnumerable,At=(r,e,t)=>e in r?vr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,zt=(r,e)=>{for(var t in e||(e={}))Ir.call(e,t)&&At(r,t,e[t]);if(xt)for(var t of xt(e))Cr.call(e,t)&&At(r,t,e[t]);return r};class Nt extends Ht{constructor(e,t,i,s=O,n=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,this.map=new Map,this.version=lt,this.cached=[],this.initialized=!1,this.storagePrefix=O,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(a=>{this.getKey&&a!==null&&!ie(a)?this.map.set(this.getKey(a),a):gi(a)?this.map.set(a.id,a):pi(a)&&this.map.set(a.topic,a)}),this.cached=[],this.initialized=!0)},this.set=async(a,o)=>{this.isInitialized(),this.map.has(a)?await this.update(a,o):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:a,value:o}),this.map.set(a,o),await this.persist())},this.get=a=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:a}),this.getData(a)),this.getAll=a=>(this.isInitialized(),a?this.values.filter(o=>Object.keys(a).every(h=>Li(o[h],a[h]))):this.values),this.update=async(a,o)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:a,update:o});const h=zt(zt({},this.getData(a)),o);this.map.set(a,h),await this.persist()},this.delete=async(a,o)=>{this.isInitialized(),this.map.has(a)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:a,reason:o}),this.map.delete(a),await this.persist())},this.logger=E(t,this.name),this.storagePrefix=s,this.getKey=n}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Ut{constructor(e,t){this.core=e,this.logger=t,this.name=yt,this.version=bt,this.events=new Bt,this.initialized=!1,this.storagePrefix=O,this.ignoredPayloadTypes=[Di],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))},this.register=({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])]},this.create=async()=>{this.isInitialized();const i=Q(),s=await this.core.crypto.setSymKey(i),n=G(Ce),a={protocol:rt},o={topic:s,expiry:n,relay:a,active:!1},h=yi({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:i,relay:a});return await this.pairings.set(s,o),await this.core.relayer.subscribe(s),this.core.expirer.set(s,n),{topic:s,uri:h}},this.pair=async i=>{this.isInitialized(),this.isValidPair(i);const{topic:s,symKey:n,relay:a}=bi(i.uri);if(this.pairings.keys.includes(s))throw new Error(`Pairing already exists: ${s}`);if(this.core.crypto.hasKeys(s))throw new Error(`Keychain already exists: ${s}`);const o=G(Ce),h={topic:s,relay:a,expiry:o,active:!1};return await this.pairings.set(s,h),await this.core.crypto.setSymKey(n,s),await this.core.relayer.subscribe(s,{relay:a}),this.core.expirer.set(s,o),i.activatePairing&&await this.activate({topic:s}),h},this.activate=async({topic:i})=>{this.isInitialized();const s=G(J);await this.pairings.update(i,{active:!0,expiry:s}),this.core.expirer.set(i,s)},this.ping=async i=>{this.isInitialized(),await this.isValidPing(i);const{topic:s}=i;if(this.pairings.keys.includes(s)){const n=await this.sendRequest(s,"wc_pairingPing",{}),{done:a,resolve:o,reject:h}=mi();this.events.once(se("pairing_ping",n),({error:l})=>{l?h(l):o()}),await a()}},this.updateExpiry=async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s})},this.updateMetadata=async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s})},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,"wc_pairingDelete",F("USER_DISCONNECTED")),await this.deletePairing(s))},this.sendRequest=async(i,s,n)=>{const a=Se(s,n),o=await this.core.crypto.encode(i,a),h=$[s].req;return this.core.history.set(i,a),this.core.relayer.publish(i,o,h),a.id},this.sendResult=async(i,s,n)=>{const a=Te(i,n),o=await this.core.crypto.encode(s,a),h=await this.core.history.get(s,i),l=$[h.request.method].res;await this.core.relayer.publish(s,o,l),await this.core.history.resolve(a)},this.sendError=async(i,s,n)=>{const a=zi(i,n),o=await this.core.crypto.encode(s,a),h=await this.core.history.get(s,i),l=$[h.request.method]?$[h.request.method].res:$.unregistered_method.res;await this.core.relayer.publish(s,o,l),await this.core.history.resolve(a)},this.deletePairing=async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,F("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)])},this.cleanup=async()=>{const i=this.pairings.getAll().filter(s=>we(s.expiry));await Promise.all(i.map(s=>this.deletePairing(s.topic)))},this.onRelayEventRequest=i=>{const{topic:s,payload:n}=i;switch(n.method){case"wc_pairingPing":return this.onPairingPingRequest(s,n);case"wc_pairingDelete":return this.onPairingDeleteRequest(s,n);default:return this.onUnknownRpcMethodRequest(s,n)}},this.onRelayEventResponse=async i=>{const{topic:s,payload:n}=i,a=(await this.core.history.get(s,n.id)).request.method;switch(a){case"wc_pairingPing":return this.onPairingPingResponse(s,n);default:return this.onUnknownRpcMethodResponse(a)}},this.onPairingPingRequest=async(i,s)=>{const{id:n}=s;try{this.isValidPing({topic:i}),await this.sendResult(n,i,!0),this.events.emit("pairing_ping",{id:n,topic:i})}catch(a){await this.sendError(n,i,a),this.logger.error(a)}},this.onPairingPingResponse=(i,s)=>{const{id:n}=s;setTimeout(()=>{Ni(s)?this.events.emit(se("pairing_ping",n),{}):Pe(s)&&this.events.emit(se("pairing_ping",n),{error:s.error})},500)},this.onPairingDeleteRequest=async(i,s)=>{const{id:n}=s;try{this.isValidDisconnect({topic:i}),await this.deletePairing(i),this.events.emit("pairing_delete",{id:n,topic:i})}catch(a){await this.sendError(n,i,a),this.logger.error(a)}},this.onUnknownRpcMethodRequest=async(i,s)=>{const{id:n,method:a}=s;try{if(this.registeredMethods.includes(a))return;const o=F("WC_METHOD_UNSUPPORTED",a);await this.sendError(n,i,o),this.logger.error(o)}catch(o){await this.sendError(n,i,o),this.logger.error(o)}},this.onUnknownRpcMethodResponse=i=>{this.registeredMethods.includes(i)||this.logger.error(F("WC_METHOD_UNSUPPORTED",i))},this.isValidPair=i=>{if(!re(i)){const{message:s}=c("MISSING_OR_INVALID",`pair() params: ${i}`);throw new Error(s)}if(!Ei(i.uri)){const{message:s}=c("MISSING_OR_INVALID",`pair() uri: ${i.uri}`);throw new Error(s)}},this.isValidPing=async i=>{if(!re(i)){const{message:n}=c("MISSING_OR_INVALID",`ping() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidDisconnect=async i=>{if(!re(i)){const{message:n}=c("MISSING_OR_INVALID",`disconnect() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidPairingTopic=async i=>{if(!fi(i,!1)){const{message:s}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(we(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=c("EXPIRED",`pairing topic: ${i}`);throw new Error(s)}},this.core=e,this.logger=E(t,this.name),this.pairings=new Nt(this.core,this.logger,this.name,this.storagePrefix)}get context(){return f(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(g.message,async e=>{const{topic:t,message:i}=e;if(!this.pairings.keys.includes(t)||this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))return;const s=await this.core.crypto.decode(t,i);try{_e(s)?(this.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):Re(s)&&(await this.core.history.resolve(s),await this.onRelayEventResponse({topic:t,payload:s}),this.core.history.delete(t,s.id))}catch(n){this.logger.error(n)}})}registerExpirerEvents(){this.core.expirer.on(w.expired,async e=>{const{topic:t}=wi(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit("pairing_expire",{topic:t}))})}}class Lt extends Wt{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new N,this.name=mt,this.version=Et,this.cached=[],this.initialized=!1,this.storagePrefix=O,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.records.set(i.id,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(i,s,n)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:i,request:s,chainId:n}),this.records.has(s.id))return;const a={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:n,expiry:G(J)};this.records.set(a.id,a),this.events.emit(_.created,a)},this.resolve=async i=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>"u"&&(s.response=Pe(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.events.emit(_.updated,s))},this.get=async(i,s)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:i,id:s}),await this.getRecord(s)),this.delete=(i,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach(n=>{if(n.topic===i){if(typeof s<"u"&&n.id!==s)return;this.records.delete(n.id),this.events.emit(_.deleted,n)}})},this.exists=async(i,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===i:!1),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=E(t,this.name)}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:Se(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(_.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(_.created,e=>{const t=_.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()}),this.events.on(_.updated,e=>{const t=_.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()}),this.events.on(_.deleted,e=>{const t=_.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()}),this.core.heartbeat.on(j.pulse,()=>{this.cleanup()})}cleanup(){try{this.records.forEach(e=>{z(e.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${e.id}`),this.delete(e.topic,e.id))})}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class $t extends Xt{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new N,this.name=ft,this.version=wt,this.cached=[],this.initialized=!1,this.storagePrefix=O,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.expirations.set(i.target,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<"u"}catch{return!1}},this.set=(i,s)=>{this.isInitialized();const n=this.formatTarget(i),a={target:n,expiry:s};this.expirations.set(n,a),this.checkExpiry(n,a),this.events.emit(w.created,{target:n,expiration:a})},this.get=i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)},this.del=i=>{if(this.isInitialized(),this.has(i)){const s=this.formatTarget(i),n=this.getExpiration(s);this.expirations.delete(s),this.events.emit(w.deleted,{target:s,expiration:n})}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=E(t,this.name)}get context(){return f(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return vi(e);if(typeof e=="number")return Ii(e);const{message:t}=c("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(w.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;z(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(w.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(j.pulse,()=>this.checkExpirations()),this.events.on(w.created,e=>{const t=w.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(w.expired,e=>{const t=w.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(w.deleted,e=>{const t=w.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Ft extends Zt{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.name=X,this.initialized=!1,this.init=async i=>{Ci()||!_i()||(this.verifyUrl=i?.verifyUrl||ge,await this.createIframe())},this.register=async i=>{var s;if(this.initialized||await this.init(),!!this.iframe)try{(s=this.iframe.contentWindow)==null||s.postMessage(i.attestationId,this.verifyUrl),this.logger.info(`postMessage sent: ${i.attestationId} ${this.verifyUrl}`)}catch{}},this.resolve=async i=>{var s;if(this.isDevEnv)return"";this.logger.info(`resolving attestation: ${i.attestationId}`);const n=this.startAbortTimer(ne),a=await fetch(`${this.verifyUrl}/attestation/${i.attestationId}`,{signal:this.abortController.signal});return clearTimeout(n),a.status===200?(s=await a.json())==null?void 0:s.origin:""},this.createIframe=async()=>{try{await Promise.race([new Promise((i,s)=>{if(document.getElementById(X))return i();const n=document.createElement("iframe");n.setAttribute("id",X),n.setAttribute("src",`${this.verifyUrl}/${this.projectId}`),n.style.display="none",n.addEventListener("load",()=>{this.initialized=!0,i()}),n.addEventListener("error",a=>{s(a)}),document.body.append(n),this.iframe=n}),new Promise(i=>{setTimeout(()=>i("iframe load timeout"),z(ve/2))})])}catch(i){this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`),this.logger.error(i)}},this.logger=E(t,this.name),this.verifyUrl=ge,this.abortController=new AbortController,this.isDevEnv=Ri()&&process.env.IS_VITEST}get context(){return f(this.logger)}startAbortTimer(e){return setTimeout(()=>this.abortController.abort(),z(e))}}var _r=Object.defineProperty,Mt=Object.getOwnPropertySymbols,Rr=Object.prototype.hasOwnProperty,Tr=Object.prototype.propertyIsEnumerable,Kt=(r,e,t)=>e in r?_r(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,kt=(r,e)=>{for(var t in e||(e={}))Rr.call(e,t)&&Kt(r,t,e[t]);if(Mt)for(var t of Mt(e))Tr.call(e,t)&&Kt(r,t,e[t]);return r};class Z extends Qt{constructor(e){super(e),this.protocol=ce,this.version=Ge,this.name=W,this.events=new N,this.initialized=!1,this.on=(i,s)=>this.events.on(i,s),this.once=(i,s)=>this.events.once(i,s),this.off=(i,s)=>this.events.off(i,s),this.removeListener=(i,s)=>this.events.removeListener(i,s),this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||le;const t=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:De(ye({level:e?.logger||Je.logger}));this.logger=E(t,this.name),this.heartbeat=new Vt,this.crypto=new It(this,this.logger,e?.keychain),this.history=new Lt(this,this.logger),this.expirer=new $t(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new jt(kt(kt({},He),e?.storageOptions)),this.relayer=new Ot({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new Ut(this,this.logger),this.verify=new Ft(this.projectId||"",this.logger)}static async init(e){const t=new Z(e);await t.initialize();const i=await t.crypto.getClientId();return await t.storage.setItem(dt,i),t}get context(){return f(this.logger)}async start(){this.initialized||await this.initialize()}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}}const Sr=Z;export{W as CORE_CONTEXT,Je as CORE_DEFAULT,ce as CORE_PROTOCOL,He as CORE_STORAGE_OPTIONS,O as CORE_STORAGE_PREFIX,Ge as CORE_VERSION,ue as CRYPTO_CLIENT_SEED,We as CRYPTO_CONTEXT,Xe as CRYPTO_JWT_TTL,Sr as Core,It as Crypto,ft as EXPIRER_CONTEXT,ur as EXPIRER_DEFAULT_TTL,w as EXPIRER_EVENTS,wt as EXPIRER_STORAGE_VERSION,$t as Expirer,mt as HISTORY_CONTEXT,_ as HISTORY_EVENTS,Et as HISTORY_STORAGE_VERSION,Lt as JsonRpcHistory,Ze as KEYCHAIN_CONTEXT,Qe as KEYCHAIN_STORAGE_VERSION,vt as KeyChain,et as MESSAGES_CONTEXT,tt as MESSAGES_STORAGE_VERSION,Ct as MessageTracker,yt as PAIRING_CONTEXT,cr as PAIRING_DEFAULT_TTL,$ as PAIRING_RPC_OPTS,bt as PAIRING_STORAGE_VERSION,Dt as PENDING_SUB_RESOLUTION_TIMEOUT,st as PUBLISHER_CONTEXT,it as PUBLISHER_DEFAULT_TTL,Ut as Pairing,at as RELAYER_CONTEXT,nt as RELAYER_DEFAULT_LOGGER,rt as RELAYER_DEFAULT_PROTOCOL,le as RELAYER_DEFAULT_RELAY_URL,g as RELAYER_EVENTS,de as RELAYER_FAILOVER_RELAY_URL,L as RELAYER_PROVIDER_EVENTS,ht as RELAYER_RECONNECT_TIMEOUT,ct as RELAYER_SDK_VERSION,or as RELAYER_STORAGE_OPTIONS,ot as RELAYER_SUBSCRIBER_SUFFIX,ut as RELAYER_TRANSPORT_CUTOFF,Ot as Relayer,lt as STORE_STORAGE_VERSION,gt as SUBSCRIBER_CONTEXT,hr as SUBSCRIBER_DEFAULT_TTL,C as SUBSCRIBER_EVENTS,pt as SUBSCRIBER_STORAGE_VERSION,Nt as Store,Tt as Subscriber,X as VERIFY_CONTEXT,ge as VERIFY_SERVER,Ft as Verify,dt as WALLETCONNECT_CLIENT_ID,Z as default};
//# sourceMappingURL=index.es.js.map
